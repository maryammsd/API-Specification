<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             
             #loadingBar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width: 100%;
                 height: 600px;
                 background-color:rgba(200,200,200,0.8);
                 -webkit-transition: all 0.5s ease;
                 -moz-transition: all 0.5s ease;
                 -ms-transition: all 0.5s ease;
                 -o-transition: all 0.5s ease;
                 transition: all 0.5s ease;
                 opacity:1;
             }

             #bar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width:20px;
                 height:20px;
                 margin:auto auto auto auto;
                 border-radius:11px;
                 border:2px solid rgba(30,30,30,0.05);
                 background: rgb(0, 173, 246); /* Old browsers */
                 box-shadow: 2px 0px 4px rgba(0,0,0,0.4);
             }

             #border {
                 position:absolute;
                 top:10px;
                 left:10px;
                 width:500px;
                 height:23px;
                 margin:auto auto auto auto;
                 box-shadow: 0px 0px 4px rgba(0,0,0,0.2);
                 border-radius:10px;
             }

             #text {
                 position:absolute;
                 top:8px;
                 left:530px;
                 width:30px;
                 height:50px;
                 margin:auto auto auto auto;
                 font-size:22px;
                 color: #000000;
             }

             div.outerBorder {
                 position:relative;
                 top:400px;
                 width:600px;
                 height:44px;
                 margin:auto auto auto auto;
                 border:8px solid rgba(0,0,0,0.1);
                 background: rgb(252,252,252); /* Old browsers */
                 background: -moz-linear-gradient(top,  rgba(252,252,252,1) 0%, rgba(237,237,237,1) 100%); /* FF3.6+ */
                 background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(252,252,252,1)), color-stop(100%,rgba(237,237,237,1))); /* Chrome,Safari4+ */
                 background: -webkit-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Chrome10+,Safari5.1+ */
                 background: -o-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Opera 11.10+ */
                 background: -ms-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* IE10+ */
                 background: linear-gradient(to bottom,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* W3C */
                 filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fcfcfc', endColorstr='#ededed',GradientType=0 ); /* IE6-9 */
                 border-radius:72px;
                 box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
             }
             

             

             
             /* position absolute is important and the container has to be relative or absolute as well. */
          div.popup {
                 position:absolute;
                 top:0px;
                 left:0px;
                 display:none;
                 background-color:#f5f4ed;
                 -moz-border-radius: 3px;
                 -webkit-border-radius: 3px;
                 border-radius: 3px;
                 border: 1px solid #808074;
                 box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
          }

          /* hide the original tooltip */
          .vis-tooltip {
            display:none;
          }
             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
            <div id="loadingBar">
              <div class="outerBorder">
                <div id="text">0%</div>
                <div id="border">
                  <div id="bar"></div>
                </div>
              </div>
            </div>
        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "android.telephony.TelephonyManager", "label": "android.telephony.TelephonyManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Provides access to information about the telephony services on\\n * the device. Applications can use the methods in this class to\\n * determine telephony services and states, as well as to access some\\n * types of subscriber information. Applications can also register\\n * a listener to receive notification of telephony state changes.\\n * \u003cp\u003e\\n * The returned TelephonyManager will use the default subscription for all calls.\\n * To call an API for a specific subscription, use {@link #createForSubscriptionId(int)}. e.g.\\n * \u003ccode\u003e\\n *   telephonyManager = defaultSubTelephonyManager.createForSubscriptionId(subId);\\n * \u003c/code\u003e\\n * \u003cp\u003e\\n * Note that access to some telephony information is\\n * permission-protected. Your application cannot access the protected\\n * information unless it has the appropriate permissions declared in\\n * its manifest file. Where permissions apply, they are noted in the\\n * the methods through which you access the protected information.\\n *\\n * \u003cp\u003eTelephonyManager is intended for use on devices that implement\\n * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. On devices\\n * that do not implement this feature, the behavior is not reliable.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getActiveModemCount()", "label": "public int getActiveModemCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of logical modems currently configured to be activated.\\n     *\\n     * Returns 0 if none of voice, sms, data is not supported\\n     * Returns 1 for Single standby mode (Single SIM functionality).\\n     * Returns 2 for Dual standby mode (Dual SIM functionality).\\n     * Returns 3 for Tri standby mode (Tri SIM functionality).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSupportedModemCount()", "label": "public int getSupportedModemCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return how many logical modem can be potentially active simultaneously, in terms of hardware\\n     * capability.\\n     * It might return different value from {@link #getActiveModemCount}. For example, for a\\n     * dual-SIM capable device operating in single SIM mode (only one logical modem is turned on),\\n     * {@link #getActiveModemCount} returns 1 while this API returns 2.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getActiveModemCount", "label": "getActiveModemCount", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public TelephonyManager createForSubscriptionId(int subId)", "label": "public TelephonyManager createForSubscriptionId(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create a new TelephonyManager object pinned to the given subscription ID.\\n     *\\n     * @return a TelephonyManager that uses the given subId for all calls.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public TelephonyManager createForPhoneAccountHandle(PhoneAccountHandle phoneAccountHandle)", "label": "public TelephonyManager createForPhoneAccountHandle(PhoneAccountHandle phoneAccountHandle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create a new TelephonyManager object pinned to the subscription ID associated with the given\\n     * phone account.\\n     *\\n     * @return a TelephonyManager that uses the given phone account for all calls, or {@code null}\\n     * if the phone account does not correspond to a valid subscription ID.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getDeviceSoftwareVersion()", "label": "public String getDeviceSoftwareVersion()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the software version number for the device, for example,\\n     * the IMEI/SV for GSM phones. Return null if the software version is\\n     * not available.\\n     * \u003cp\u003e\\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "READ_PHONE_STATE", "label": "READ_PHONE_STATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getImei()", "label": "public String getImei()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the IMEI (International Mobile Equipment Identity). Return null if IMEI is not\\n     * available.\\n     *\\n     * See {@link #getImei(int)} for details on the required permissions and behavior\\n     * when the caller does not hold sufficient permissions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getImei(int)", "label": "getImei(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getImei(int slotIndex)", "label": "public String getImei(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the IMEI (International Mobile Equipment Identity). Return null if IMEI is not\\n     * available.\\n     *\\n     * \u003cp\u003eStarting with API level 29, persistent device identifiers are guarded behind additional\\n     * restrictions, and apps are recommended to use resettable identifiers (see \u003ca\\n     * href=\"c\"\u003e Best practices for unique identifiers\u003c/a\u003e). This method can be invoked if one of\\n     * the following requirements is met:\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\\n     *     \u003cli\u003eIf the calling app is the device or profile owner and has been granted the\\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\\n     *     owns a managed profile on the device; for more details see \u003ca\\n     *     href=\"https://developer.android.com/work/managed-profiles\"\u003eWork profiles\u003c/a\u003e.\\n     *     Profile owner access is deprecated and will be removed in a future release.\\n     *     \u003cli\u003eIf the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\\n     *     active subscription.\\n     *     \u003cli\u003eIf the calling app is the default SMS role holder (see {@link\\n     *     RoleManager#isRoleHeld(String)}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf the calling app does not meet one of these requirements then this method will behave\\n     * as follows:\\n     *\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app has the\\n     *     READ_PHONE_STATE permission then null is returned.\u003c/li\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app does not have\\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\\n     *     higher, then a SecurityException is thrown.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * @param slotIndex of which IMEI is returned\\n     \u0027}"}, {"color": "#97c2fc", "id": "hasCarrierPrivileges", "label": "hasCarrierPrivileges", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isRoleHeld(String)", "label": "isRoleHeld(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.app.role.RoleManager", "label": "android.app.role.RoleManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class provides information about and manages roles.\\n * \u003cp\u003e\\n * A role is a unique name within the system associated with certain privileges. The list of\\n * available roles might change with a system app update, so apps should not make assumption about\\n * the availability of roles. Instead, they should always query if the role is available using\\n * {@link #isRoleAvailable(String)} before trying to do anything with it. Some predefined role names\\n * are available as constants in this class, and a list of possibly available roles can be found in\\n * the \u003ca href=\"{@docRoot}reference/androidx/core/role/package-summary.html\"\u003eAndroidX Role\\n * library\u003c/a\u003e.\\n * \u003cp\u003e\\n * There can be multiple applications qualifying for a role, but only a subset of them can become\\n * role holders. To qualify for a role, an application must meet certain requirements, including\\n * defining certain components in its manifest. These requirements can be found in the AndroidX\\n * Libraries. Then the application will need user consent to become a role holder, which can be\\n * requested using {@link android.app.Activity#startActivityForResult(Intent, int)} with the\\n * {@code Intent} obtained from {@link #createRequestRoleIntent(String)}.\\n * \u003cp\u003e\\n * Upon becoming a role holder, the application may be granted certain privileges that are role\\n * specific. When the application loses its role, these privileges will also be revoked.\\n \u0027}"}, {"color": "#97c2fc", "id": "public Intent createRequestRoleIntent(@NonNull String roleName)", "label": "public Intent createRequestRoleIntent(@NonNull String roleName)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code Intent} suitable for passing to\\n     * {@link android.app.Activity#startActivityForResult(Intent, int)} which prompts the user to\\n     * grant a role to this application.\\n     * \u003cp\u003e\\n     * If the role is granted, the {@code resultCode} will be\\n     * {@link android.app.Activity#RESULT_OK}, otherwise it will be\\n     * {@link android.app.Activity#RESULT_CANCELED}.\\n     *\\n     * @param roleName the name of requested role\\n     *\\n     * @return the {@code Intent} to prompt user to grant the role\\n     \u0027}"}, {"color": "#97c2fc", "id": "RESULT_CANCELED", "label": "RESULT_CANCELED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.app.Activity", "label": "android.app.Activity", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public boolean isRoleAvailable(@NonNull String roleName)", "label": "public boolean isRoleAvailable(@NonNull String roleName)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check whether a role is available in the system.\\n     *\\n     * @param roleName the name of role to checking for\\n     *\\n     * @return whether the role is available in the system\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isRoleHeld(@NonNull String roleName)", "label": "public boolean isRoleHeld(@NonNull String roleName)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check whether the calling application is holding a particular role.\\n     *\\n     * @param roleName the name of the role to check for\\n     *\\n     * @return whether the calling application is holding the role\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getTypeAllocationCode()", "label": "public String getTypeAllocationCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Type Allocation Code from the IMEI. Return null if Type Allocation Code is not\\n     * available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getTypeAllocationCode(int slotIndex)", "label": "public String getTypeAllocationCode(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Type Allocation Code from the IMEI. Return null if Type Allocation Code is not\\n     * available.\\n     *\\n     * @param slotIndex of which Type Allocation Code is returned\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMeid()", "label": "public String getMeid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not available.\\n     *\\n     * \u003cp\u003eStarting with API level 29, persistent device identifiers are guarded behind additional\\n     * restrictions, and apps are recommended to use resettable identifiers (see \u003ca\\n     * href=\"c\"\u003e Best practices for unique identifiers\u003c/a\u003e). This method can be invoked if one of\\n     * the following requirements is met:\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\\n     *     \u003cli\u003eIf the calling app is the device or profile owner and has been granted the\\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\\n     *     owns a managed profile on the device; for more details see \u003ca\\n     *     href=\"https://developer.android.com/work/managed-profiles\"\u003eWork profiles\u003c/a\u003e.\\n     *     Profile owner access is deprecated and will be removed in a future release.\\n     *     \u003cli\u003eIf the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\\n     *     active subscription.\\n     *     \u003cli\u003eIf the calling app is the default SMS role holder (see {@link\\n     *     RoleManager#isRoleHeld(String)}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf the calling app does not meet one of these requirements then this method will behave\\n     * as follows:\\n     *\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app has the\\n     *     READ_PHONE_STATE permission then null is returned.\u003c/li\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app does not have\\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\\n     *     higher, then a SecurityException is thrown.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMeid(int slotIndex)", "label": "public String getMeid(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the MEID (Mobile Equipment Identifier). Return null if MEID is not available.\\n     *\\n     * \u003cp\u003eStarting with API level 29, persistent device identifiers are guarded behind additional\\n     * restrictions, and apps are recommended to use resettable identifiers (see \u003ca\\n     * href=\"c\"\u003e Best practices for unique identifiers\u003c/a\u003e). This method can be invoked if one of\\n     * the following requirements is met:\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\\n     *     \u003cli\u003eIf the calling app is the device or profile owner and has been granted the\\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\\n     *     owns a managed profile on the device; for more details see \u003ca\\n     *     href=\"https://developer.android.com/work/managed-profiles\"\u003eWork profiles\u003c/a\u003e.\\n     *     Profile owner access is deprecated and will be removed in a future release.\\n     *     \u003cli\u003eIf the calling app has carrier privileges (see {@link #hasCarrierPrivileges}) on any\\n     *     active subscription.\\n     *     \u003cli\u003eIf the calling app is the default SMS role holder (see {@link\\n     *     RoleManager#isRoleHeld(String)}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf the calling app does not meet one of these requirements then this method will behave\\n     * as follows:\\n     *\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app has the\\n     *     READ_PHONE_STATE permission then null is returned.\u003c/li\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app does not have\\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\\n     *     higher, then a SecurityException is thrown.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * @param slotIndex of which MEID is returned\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getManufacturerCode()", "label": "public String getManufacturerCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Manufacturer Code from the MEID. Return null if Manufacturer Code is not\\n     * available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getManufacturerCode(int slotIndex)", "label": "public String getManufacturerCode(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Manufacturer Code from the MEID. Return null if Manufacturer Code is not\\n     * available.\\n     *\\n     * @param slotIndex of which Type Allocation Code is returned\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getNai()", "label": "public String getNai()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Network Access Identifier (NAI). Return null if NAI is not available.\\n     *\\n     * \u003cp\u003eStarting with API level 29, persistent device identifiers are guarded behind additional\\n     * restrictions, and apps are recommended to use resettable identifiers (see \u003ca\\n     * href=\"c\"\u003e Best practices for unique identifiers\u003c/a\u003e). This method can be invoked if one of\\n     * the following requirements is met:\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\\n     *     \u003cli\u003eIf the calling app is the device or profile owner and has been granted the\\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\\n     *     owns a managed profile on the device; for more details see \u003ca\\n     *     href=\"https://developer.android.com/work/managed-profiles\"\u003eWork profiles\u003c/a\u003e.\\n     *     Profile owner access is deprecated and will be removed in a future release.\\n     *     \u003cli\u003eIf the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *     \u003cli\u003eIf the calling app is the default SMS role holder (see {@link\\n     *     RoleManager#isRoleHeld(String)}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf the calling app does not meet one of these requirements then this method will behave\\n     * as follows:\\n     *\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app has the\\n     *     READ_PHONE_STATE permission then null is returned.\u003c/li\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app does not have\\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\\n     *     higher, then a SecurityException is thrown.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getPhoneType()", "label": "public int getPhoneType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a constant indicating the device phone type.  This\\n     * indicates the type of radio used to transmit voice calls.\\n     *\\n     * @see #PHONE_TYPE_NONE\\n     * @see #PHONE_TYPE_GSM\\n     * @see #PHONE_TYPE_CDMA\\n     * @see #PHONE_TYPE_SIP\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static String getProcCmdLine()", "label": "private static String getProcCmdLine()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The contents of the /proc/cmdline file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getNetworkOperatorName()", "label": "public String getNetworkOperatorName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the alphabetic name of current registered operator.\\n     * \u003cp\u003e\\n     * Availability: Only when user is registered to a network. Result may be\\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\\n     * on a CDMA network).\\n     \u0027}"}, {"color": "#97c2fc", "id": "getPhoneType()", "label": "getPhoneType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getNetworkOperator()", "label": "public String getNetworkOperator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the numeric name (MCC+MNC) of current registered operator.\\n     * \u003cp\u003e\\n     * Availability: Only when user is registered to a network. Result may be\\n     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if\\n     * on a CDMA network).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getNetworkSpecifier()", "label": "public String getNetworkSpecifier()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the network specifier of the subscription ID pinned to the TelephonyManager. The\\n     * network specifier is used by {@link\\n     * android.net.NetworkRequest.Builder#setNetworkSpecifier(String)} to create a {@link\\n     * android.net.NetworkRequest} that connects through the subscription.\\n     *\\n     * @see android.net.NetworkRequest.Builder#setNetworkSpecifier(String)\\n     * @see #createForSubscriptionId(int)\\n     * @see #createForPhoneAccountHandle(PhoneAccountHandle)\\n     \u0027}"}, {"color": "#97c2fc", "id": "setNetworkSpecifier(String)", "label": "setNetworkSpecifier(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.net.NetworkRequest", "label": "android.net.NetworkRequest", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Defines a request for a network, made through {@link NetworkRequest.Builder} and used\\n * to request a network via {@link ConnectivityManager#requestNetwork} or listen for changes\\n * via {@link ConnectivityManager#registerNetworkCallback}.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int describeContents()", "label": "public int describeContents()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Implement the Parcelable interface \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasCapability(@NetCapability int capability)", "label": "public boolean hasCapability(@NetCapability int capability)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests for the presence of a capability on this instance.\\n     *\\n     * @param capability the capabilities to be tested for.\\n     * @return {@code true} if set on this instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean canBeSatisfiedBy(@Nullable NetworkCapabilities nc)", "label": "public boolean canBeSatisfiedBy(@Nullable NetworkCapabilities nc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if and only if the capabilities requested in this NetworkRequest are satisfied\\n     * by the provided {@link NetworkCapabilities}.\\n     *\\n     * @param nc Capabilities that should satisfy this NetworkRequest. null capabilities do not\\n     *           satisfy any request.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.NetworkCapabilities", "label": "android.net.NetworkCapabilities", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Representation of the capabilities of an active network. Instances are\\n * typically obtained through\\n * {@link NetworkCallback#onCapabilitiesChanged(Network, NetworkCapabilities)}\\n * or {@link ConnectivityManager#getNetworkCapabilities(Network)}.\\n * \u003cp\u003e\\n * This replaces the old {@link ConnectivityManager#TYPE_MOBILE} method of\\n * network selection. Rather than indicate a need for Wi-Fi because an\\n * application needs high bandwidth and risk obsolescence when a new, fast\\n * network appears (like LTE), the application should specify it needs high\\n * bandwidth. Similarly if an application needs an unmetered network for a bulk\\n * transfer it can specify that rather than assuming all cellular based\\n * connections are metered and all Wi-Fi based connections are not.\\n \u0027}"}, {"color": "#97c2fc", "id": "private void combineNetCapabilities(@NonNull NetworkCapabilities nc)", "label": "private void combineNetCapabilities(@NonNull NetworkCapabilities nc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Note this method may result in having the same capability in wanted and unwanted lists. \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasTransport(@Transport int transportType)", "label": "public boolean hasTransport(@Transport int transportType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @see Builder#addTransportType(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getOwnerUid()", "label": "public int getOwnerUid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Retrieves the UID of the app that owns this network.\\n     *\\n     * \u003cp\u003eFor user privacy reasons, this field will only be populated if the following conditions\\n     * are met:\\n     *\\n     * \u003cp\u003eThe caller is the network owner, AND one of the following sets of requirements is met:\\n     *\\n     * \u003col\u003e\\n     *   \u003cli\u003eThe described Network is a VPN\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003eOR:\\n     *\\n     * \u003col\u003e\\n     *   \u003cli\u003eThe calling app is the network owner\\n     *   \u003cli\u003eThe calling app has the ACCESS_FINE_LOCATION permission granted\\n     *   \u003cli\u003eThe user\u0027s location toggle is on\\n     * \u003c/ol\u003e\\n     *\\n     * Instances of NetworkCapabilities sent to apps without the appropriate permissions will have\\n     * this field cleared out.\\n     \"}"}, {"color": "#97c2fc", "id": "private void combineAdministratorUids(@NonNull final NetworkCapabilities nc)", "label": "private void combineAdministratorUids(@NonNull final NetworkCapabilities nc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Combine the administrator UIDs of the capabilities.\\n     *\\n     * \u003cp\u003eThis is only legal if either of the administrators lists are empty, or if they are equal.\\n     * Combining administrator UIDs is only possible for combining non-overlapping sets of UIDs.\\n     *\\n     * \u003cp\u003eIf both administrator lists are non-empty but not equal, they conflict with each other. In\\n     * this case, it would not make sense to add them together.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLinkUpstreamBandwidthKbps()", "label": "public int getLinkUpstreamBandwidthKbps()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the upstream bandwidth for this network in Kbps.  This always only refers to\\n     * the estimated first hop transport bandwidth.\\n     *\\n     * @return The estimated first hop upstream (device to network) bandwidth.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLinkDownstreamBandwidthKbps()", "label": "public int getLinkDownstreamBandwidthKbps()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the downstream bandwidth for this network in Kbps.  This always only refers to\\n     * the estimated first hop transport bandwidth.\\n     *\\n     * @return The estimated first hop downstream (network to device) bandwidth.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public NetworkSpecifier getNetworkSpecifier()", "label": "public NetworkSpecifier getNetworkSpecifier()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @see Builder#setNetworkSpecifier(NetworkSpecifier)\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.NetworkSpecifier", "label": "android.net.NetworkSpecifier", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public TransportInfo getTransportInfo()", "label": "public TransportInfo getTransportInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a transport-specific information container. The application may cast this\\n     * container to a concrete sub-class based on its knowledge of the network request. The\\n     * application should be able to deal with a {@code null} return value or an invalid case,\\n     * e.g. use {@code instanceof} operator to verify expected type.\\n     *\\n     * @return A concrete implementation of the {@link TransportInfo} class or null if not\\n     * available for the network.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.TransportInfo", "label": "android.net.TransportInfo", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public int getSignalStrength()", "label": "public int getSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the signal strength.\\n     *\\n     * @return The bearer-specific signal strength.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void combineUids(@NonNull NetworkCapabilities nc)", "label": "private void combineUids(@NonNull NetworkCapabilities nc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Combine the UIDs this network currently applies to with the UIDs the passed\\n     * NetworkCapabilities apply to.\\n     * nc is assumed nonnull.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private boolean satisfiedByRequestor(NetworkCapabilities nc)", "label": "private boolean satisfiedByRequestor(NetworkCapabilities nc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Test whether the passed NetworkCapabilities satisfies the requestor restrictions of this\\n     * capabilities.\\n     *\\n     * This method is called on the NetworkCapabilities embedded in a request with the\\n     * capabilities of an available network. If the available network, sets a specific\\n     * requestor (by uid and optionally package name), then this will only match a request from the\\n     * same app. If either of the capabilities have an unset uid or package name, then it matches\\n     * everything.\\n     * \u003cp\u003e\\n     * nc is assumed nonnull. Else, NPE.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void combineRequestor(@NonNull NetworkCapabilities nc)", "label": "private void combineRequestor(@NonNull NetworkCapabilities nc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Combine requestor info of the capabilities.\\n     * \u003cp\u003e\\n     * This is only legal if either the requestor info of this object is reset, or both info are\\n     * equal.\\n     * nc is assumed nonnull.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle getCarrierConfig()", "label": "public PersistableBundle getCarrierConfig()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the carrier config of the subscription ID pinned to the TelephonyManager. If an\\n     * invalid subscription ID is pinned to the TelephonyManager, the returned config will contain\\n     * default values.\\n     *\\n     * \u003cp\u003eThis method may take several seconds to complete, so it should only be called from a\\n     * worker thread.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @see CarrierConfigManager#getConfigForSubId(int)\\n     * @see #createForSubscriptionId(int)\\n     * @see #createForPhoneAccountHandle(PhoneAccountHandle)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isNetworkRoaming()", "label": "public boolean isNetworkRoaming()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the device is considered roaming on the current\\n     * network, for GSM purposes.\\n     * \u003cp\u003e\\n     * Availability: Only when user registered to a network.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getNetworkCountryIso()", "label": "public String getNetworkCountryIso()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the ISO-3166-1 alpha-2 country code equivalent of the MCC (Mobile Country Code) of\\n     * the current registered operator or the cell nearby, if available.\\n     *\\n     * Note: Result may be unreliable on CDMA networks (use {@link #getPhoneType()} to determine\\n     * if on a CDMA network).\\n     * \u003cp\u003e\\n     * @return the lowercase 2 character ISO-3166-1 alpha-2 country code, or empty string if not\\n     * available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getNetworkCountryIso(int slotIndex)", "label": "public String getNetworkCountryIso(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the ISO-3166-1 alpha-2 country code equivalent of the MCC (Mobile Country Code) of\\n     * the current registered operator or the cell nearby, if available. This is same as\\n     * {@link #getNetworkCountryIso()} but allowing specifying the SIM slot index. This is used for\\n     * accessing network country info from the SIM slot that does not have SIM inserted.\\n     *\\n     * Note: Result may be unreliable on CDMA networks (use {@link #getPhoneType()} to determine\\n     * if on a CDMA network).\\n     * \u003cp\u003e\\n     *\\n     * @param slotIndex the SIM slot index to get network country ISO.\\n     *\\n     * @return the lowercase 2 character ISO-3166-1 alpha-2 country code, or empty string if not\\n     * available.\\n     *\\n     * @throws IllegalArgumentException when the slotIndex is invalid.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNetworkCountryIso()", "label": "getNetworkCountryIso()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getDataNetworkType()", "label": "public int getDataNetworkType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a constant indicating the radio technology (network type)\\n     * currently in use on the device for data transmission.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the given\\n     * subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return the network type\\n     *\\n     * @see #NETWORK_TYPE_UNKNOWN\\n     * @see #NETWORK_TYPE_GPRS\\n     * @see #NETWORK_TYPE_EDGE\\n     * @see #NETWORK_TYPE_UMTS\\n     * @see #NETWORK_TYPE_HSDPA\\n     * @see #NETWORK_TYPE_HSUPA\\n     * @see #NETWORK_TYPE_HSPA\\n     * @see #NETWORK_TYPE_CDMA\\n     * @see #NETWORK_TYPE_EVDO_0\\n     * @see #NETWORK_TYPE_EVDO_A\\n     * @see #NETWORK_TYPE_EVDO_B\\n     * @see #NETWORK_TYPE_1xRTT\\n     * @see #NETWORK_TYPE_IDEN\\n     * @see #NETWORK_TYPE_LTE\\n     * @see #NETWORK_TYPE_EHRPD\\n     * @see #NETWORK_TYPE_HSPAP\\n     * @see #NETWORK_TYPE_NR\\n     \u0027}"}, {"color": "#97c2fc", "id": "createForSubscriptionId", "label": "createForSubscriptionId", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getDefaultDataSubscriptionId()", "label": "getDefaultDataSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.SubscriptionManager", "label": "android.telephony.SubscriptionManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * SubscriptionManager is the application interface to SubscriptionController\\n * and provides information about the current Telephony Subscriptions.\\n \u0027}"}, {"color": "#97c2fc", "id": "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "label": "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Register for changes to the list of active {@link SubscriptionInfo} records or to the\\n     * individual records themselves. When a change occurs the onSubscriptionsChanged method of\\n     * the listener will be invoked immediately if there has been a notification. The\\n     * onSubscriptionChanged method will also be triggered once initially when calling this\\n     * function.\\n     *\\n     * @param listener an instance of {@link OnSubscriptionsChangedListener} with\\n     *                 onSubscriptionsChanged overridden.\\n     \u0027}"}, {"color": "#97c2fc", "id": "OnSubscriptionsChangedListener", "label": "OnSubscriptionsChangedListener", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "android.telephony.SubscriptionInfo", "label": "android.telephony.SubscriptionInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A Parcelable class for Subscription Information.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getSubscriptionId()", "label": "public int getSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return an appropriate subscription ID for any situation.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, then the provided\\n     * subscription ID is returned. Otherwise, the default subscription ID will be returned.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getIccId()", "label": "public String getIccId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the ICCID of the UICC. If the ICCID is not availble, returns null.\\n     * \u003cp\u003e\\n     * Note that this field may be omitted if the caller does not have the correct permissions\\n     * (see {@link TelephonyManager#getUiccCardsInfo()}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSimSlotIndex()", "label": "public int getSimSlotIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * @return the slot index of this Subscription\u0027s SIM card.\\n     \"}"}, {"color": "#97c2fc", "id": "public int getCarrierId()", "label": "public int getCarrierId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the carrier id of this Subscription carrier.\\n     * @see TelephonyManager#getSimCarrierId()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getDisplayName()", "label": "public CharSequence getDisplayName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the name displayed to the user that identifies this subscription\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getCarrierName()", "label": "public CharSequence getCarrierName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the name displayed to the user that identifies Subscription provider name\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Bitmap createIconBitmap(Context context)", "label": "public Bitmap createIconBitmap(Context context)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates and returns an icon {@code Bitmap} to represent this {@code SubscriptionInfo} in a\\n     * user interface.\\n     *\\n     * @param context A {@code Context} to get the {@code DisplayMetrics}s from.\\n     *\\n     * @return A bitmap icon for this {@code SubscriptionInfo}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getIconTint()", "label": "public int getIconTint()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A highlight color to use in displaying information about this {@code PhoneAccount}.\\n     *\\n     * @return A hexadecimal color value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getNumber()", "label": "public String getNumber()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Get the dialing number of the emergency number.\\n     *\\n     * The character in the number string is only the dial pad\\n     * character(\u00270\u0027-\u00279\u0027, \u0027*\u0027, \u0027+\u0027, or \u0027#\u0027). For example: 911.\\n     *\\n     * If the number starts with carrier prefix, the carrier prefix is configured in\\n     * {@link CarrierConfigManager#KEY_EMERGENCY_NUMBER_PREFIX_STRING_ARRAY}.\\n     *\\n     * @return the dialing number.\\n     \"}"}, {"color": "#97c2fc", "id": "public int getDataRoaming()", "label": "public int getDataRoaming()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the data roaming state for this subscription, either\\n     * {@link SubscriptionManager#DATA_ROAMING_ENABLE} or {@link SubscriptionManager#DATA_ROAMING_DISABLE}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMccString()", "label": "public String getMccString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Mobile Country Code in string version, null if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMncString()", "label": "public String getMncString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Mobile Network Code in string version, null if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getCountryIso()", "label": "public String getCountryIso()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the country code string (lowercase character) in ISO 3166 format of the emergency number.\\n     *\\n     * @return the country code string (lowercase character) in ISO 3166 format.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isEmbedded()", "label": "public boolean isEmbedded()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 @return whether the subscription is an eUICC one. \u0027}"}, {"color": "#97c2fc", "id": "public boolean isOpportunistic()", "label": "public boolean isOpportunistic()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * An opportunistic subscription connects to a network that is\\n     * limited in functionality and / or coverage.\\n     *\\n     * @return whether subscription is opportunistic.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ParcelUuid getGroupUuid()", "label": "public ParcelUuid getGroupUuid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Used in scenarios where different subscriptions are bundled as a group.\\n     * It\u0027s typically a primary and an opportunistic subscription. (see {@link #isOpportunistic()})\\n     * Such that those subscriptions will have some affiliated behaviors such as opportunistic\\n     * subscription may be invisible to the user.\\n     *\\n     * @return group UUID a String of group UUID if it belongs to a group. Otherwise\\n     * it will return null.\\n     \"}"}, {"color": "#97c2fc", "id": "isOpportunistic()", "label": "isOpportunistic()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getSubscriptionType()", "label": "public int getSubscriptionType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method returns the type of a subscription. It can be\\n     * {@link SubscriptionManager#SUBSCRIPTION_TYPE_LOCAL_SIM} or\\n     * {@link SubscriptionManager#SUBSCRIPTION_TYPE_REMOTE_SIM}.\\n     * @return the type of subscription\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCardId()", "label": "public int getCardId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the card ID of the UICC. See {@link TelephonyManager#getCardIdForDefaultEuicc()} for more\\n     * details on card ID.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getCardId()", "label": "getCardId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.UiccCardInfo", "label": "android.telephony.UiccCardInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The UiccCardInfo represents information about a currently inserted UICC or embedded eUICC.\\n \u0027}"}, {"color": "#97c2fc", "id": "public boolean isEuicc()", "label": "public boolean isEuicc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return whether the UICC is an eUICC.\\n     * @return true if the UICC is an eUICC.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getEid()", "label": "public String getEid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the embedded ID (EID) of the eUICC. If the UiccCardInfo is not an eUICC\\n     * (see {@link #isEuicc()}), or the EID is not available, returns null.\\n     * \u003cp\u003e\\n     * Note that this field may be omitted if the caller does not have the correct permissions\\n     * (see {@link TelephonyManager#getUiccCardsInfo()}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "isEuicc()", "label": "isEuicc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getSlotIndex()", "label": "public int getSlotIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the slot index for the slot that the UICC is currently inserted in.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isRemovable()", "label": "public boolean isRemovable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return whether the UICC or eUICC is removable.\\n     * \u003cp\u003e\\n     * UICCs are generally removable, but eUICCs may be removable or built in to the device.\\n     * @return true if the UICC or eUICC is removable\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)", "label": "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Register for changes to the list of active {@link SubscriptionInfo} records or to the\\n     * individual records themselves. When a change occurs the onSubscriptionsChanged method of\\n     * the listener will be invoked immediately if there has been a notification. The\\n     * onSubscriptionChanged method will also be triggered once initially when calling this\\n     * function.\\n     *\\n     * @param listener an instance of {@link OnSubscriptionsChangedListener} with\\n     *                 onSubscriptionsChanged overridden.\\n     * @param executor the executor that will execute callbacks.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "label": "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unregister the {@link OnSubscriptionsChangedListener}. This is not strictly necessary\\n     * as the listener will automatically be unregistered if an attempt to invoke the listener\\n     * fails.\\n     *\\n     * @param listener that is to be unregistered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)", "label": "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Register for changes to the list of opportunistic subscription records or to the\\n     * individual records themselves. When a change occurs the onOpportunisticSubscriptionsChanged\\n     * method of the listener will be invoked immediately if there has been a notification.\\n     *\\n     * @param listener an instance of {@link OnOpportunisticSubscriptionsChangedListener} with\\n     *                 onOpportunisticSubscriptionsChanged overridden.\\n     \u0027}"}, {"color": "#97c2fc", "id": "OnOpportunisticSubscriptionsChangedListener", "label": "OnOpportunisticSubscriptionsChangedListener", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)", "label": "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unregister the {@link OnOpportunisticSubscriptionsChangedListener} that is currently\\n     * listening opportunistic subscriptions change. This is not strictly necessary\\n     * as the listener will automatically be unregistered if an attempt to invoke the listener\\n     * fails.\\n     *\\n     * @param listener that is to be unregistered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SubscriptionInfo getActiveSubscriptionInfo(int subId)", "label": "public SubscriptionInfo getActiveSubscriptionInfo(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the active SubscriptionInfo with the input subId.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see\\n     * {@link TelephonyManager#hasCarrierPrivileges}).\\n     *\\n     * @param subId The unique SubscriptionInfo key in database.\\n     * @return SubscriptionInfo, maybe null if its not active.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)", "label": "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the active SubscriptionInfo associated with the slotIndex\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see\\n     * {@link TelephonyManager#hasCarrierPrivileges}).\\n     *\\n     * @param slotIndex the slot which the subscription is inserted\\n     * @return SubscriptionInfo, maybe null if its not active\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "label": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the SubscriptionInfo(s) of the currently active SIM(s). The records will be sorted\\n     * by {@link SubscriptionInfo#getSimSlotIndex} then by {@link SubscriptionInfo#getSubscriptionId}.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see\\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, only records accessible\\n     * to the calling app are returned.\\n     *\\n     * @return Sorted list of the currently {@link SubscriptionInfo} records available on the device.\\n     * \u003cul\u003e\\n     * \u003cli\u003e\\n     * If null is returned the current state is unknown but if a {@link OnSubscriptionsChangedListener}\\n     * has been registered {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be\\n     * invoked in the future.\\n     * \u003c/li\u003e\\n     * \u003cli\u003e\\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\\n     * \u003c/li\u003e\\n     * \u003cli\u003e\\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\\n     * \u003c/li\u003e\\n     * \u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "onSubscriptionsChanged", "label": "onSubscriptionsChanged", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()", "label": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get both hidden and visible SubscriptionInfo(s) of the currently active SIM(s).\\n     * The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex}\\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\\n     *\\n     * Hidden subscriptions refer to those are not meant visible to the users.\\n     * For example, an opportunistic subscription that is grouped with other\\n     * subscriptions should remain invisible to users as they are only functionally\\n     * supplementary to primary ones.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see\\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, only records accessible\\n     * to the calling app are returned.\\n     *\\n     * @return Sorted list of the currently available {@link SubscriptionInfo}\\n     * records on the device.\\n     * This is similar to {@link #getActiveSubscriptionInfoList} except that it will return\\n     * both active and hidden SubscriptionInfos.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "getActiveSubscriptionInfoList", "label": "getActiveSubscriptionInfoList", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public List\u003cSubscriptionInfo\u003e getAccessibleSubscriptionInfoList()", "label": "public List\u003cSubscriptionInfo\u003e getAccessibleSubscriptionInfoList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the SubscriptionInfo(s) of all embedded subscriptions accessible to the calling app, if\\n     * any.\\n     *\\n     * \u003cp\u003eOnly those subscriptions for which the calling app has carrier privileges per the\\n     * subscription metadata, if any, will be included in the returned list.\\n     *\\n     * \u003cp\u003eThe records will be sorted by {@link SubscriptionInfo#getSimSlotIndex} then by\\n     * {@link SubscriptionInfo#getSubscriptionId}.\\n     *\\n     * @return Sorted list of the current embedded {@link SubscriptionInfo} records available on the\\n     * device which are accessible to the caller.\\n     * \u003cul\u003e\\n     * \u003cli\u003e\\n     * If null is returned the current state is unknown but if a\\n     * {@link OnSubscriptionsChangedListener} has been registered\\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be invoked in the future.\\n     * \u003cli\u003e\\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\\n     * \u003cli\u003e\\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\\n     * \u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getActiveSubscriptionInfoCount()", "label": "public int getActiveSubscriptionInfoCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     *\\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see\\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, the count will include\\n     * only those subscriptions accessible to the caller.\\n     *\\n     * @return the current number of active subscriptions. There is no guarantee the value\\n     * returned by this method will be the same as the length of the list returned by\\n     * {@link #getActiveSubscriptionInfoList}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getActiveSubscriptionInfoCountMax()", "label": "public int getActiveSubscriptionInfoCountMax()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the maximum number of active subscriptions that will be returned by\\n     * {@link #getActiveSubscriptionInfoList} and the value returned by\\n     * {@link #getActiveSubscriptionInfoCount}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getActiveSubscriptionInfoCount", "label": "getActiveSubscriptionInfoCount", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int getSlotIndex(int subscriptionId)", "label": "public static int getSlotIndex(int subscriptionId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Get slotIndex associated with the subscription.\\n     *\\n     * @param subscriptionId the unique SubscriptionInfo index in database\\n     * @return slotIndex as a positive integer or {@link #INVALID_SIM_SLOT_INDEX} if the supplied\\n     * subscriptionId doesn\u0027t have an associated slot index.\\n     \"}"}, {"color": "#97c2fc", "id": "INVALID_SIM_SLOT_INDEX", "label": "INVALID_SIM_SLOT_INDEX", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int[] getSubscriptionIds(int slotIndex)", "label": "public int[] getSubscriptionIds(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get an array of Subscription Ids for specified slot Index.\\n     * @param slotIndex the slot index.\\n     * @return subscription Ids or null if the given slot Index is not valid or there are no active\\n     * subscriptions in the slot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int getDefaultSubscriptionId()", "label": "public static int getDefaultSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the system\\\u0027s default subscription id.\\n     *\\n     * For a voice capable device, it will return getDefaultVoiceSubscriptionId.\\n     * For a data only device, it will return the getDefaultDataSubscriptionId.\\n     * May return an INVALID_SUBSCRIPTION_ID on error.\\n     *\\n     * @return the \"system\" default subscription id.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int getDefaultVoiceSubscriptionId()", "label": "public static int getDefaultVoiceSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the system\u0027s default voice subscription id.\\n     *\\n     * On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.\\n     *\\n     * @return the default voice subscription Id.\\n     \"}"}, {"color": "#97c2fc", "id": "public static int getDefaultSmsSubscriptionId()", "label": "public static int getDefaultSmsSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get default sms subscription id.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003eThis returns a value different from\\n     * {@link SubscriptionManager#getDefaultSmsSubscriptionId} if the user has not chosen a default.\\n     * In this case it returns the active subscription id if there\\\u0027s only one active subscription\\n     * available.\\n     *\\n     * @return the user-defined default SMS subscription id, or the active subscription id if\\n     * there\\\u0027s only one active subscription available, otherwise\\n     * {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int getDefaultDataSubscriptionId()", "label": "public static int getDefaultDataSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the system\u0027s default data subscription id.\\n     *\\n     * On a voice only device or on error, will return INVALID_SUBSCRIPTION_ID.\\n     *\\n     * @return the default data subscription Id.\\n     \"}"}, {"color": "#97c2fc", "id": "public static boolean isValidSubscriptionId(int subscriptionId)", "label": "public static boolean isValidSubscriptionId(int subscriptionId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check if the supplied subscription ID is valid.\\n     *\\n     * \u003cp\u003eA valid subscription ID is not necessarily an active subscription ID\\n     * (see {@link #isActiveSubscriptionId(int)}) or an usable subscription ID\\n     * (see {@link #isUsableSubscriptionId(int)}). Unless specifically noted, subscription\\n     * APIs work with a valid subscription ID.\\n     *\\n     * @param subscriptionId The subscription ID.\\n     * @return {@code true} if the supplied subscriptionId is valid; {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUsableSubscriptionId(int)", "label": "isUsableSubscriptionId(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isActiveSubscriptionId(int)", "label": "isActiveSubscriptionId(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUsableSubscriptionId(int subscriptionId)", "label": "public static boolean isUsableSubscriptionId(int subscriptionId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check if the supplied subscription ID is usable.\\n     *\\n     * \u003cp\u003eA usable subscription ID is a valid subscription ID, but not necessarily an active\\n     * subscription ID (see {@link #isActiveSubscriptionId(int)}). Some subscription APIs\\n     * require a usable subscription ID, and this is noted in their documentation; otherwise, a\\n     * subscription ID does not need to be usable for subscription functions, only valid.\\n     *\\n     * @param subscriptionId the subscription ID\\n     * @return {@code true} if the subscription ID is usable; {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isNetworkRoaming(int subId)", "label": "public boolean isNetworkRoaming(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the device is considered roaming on the current\\n     * network for a subscription.\\n     * \u003cp\u003e\\n     * Availability: Only when user registered to a network.\\n     *\\n     * @param subId The subscription ID\\n     * @return true if the network for the subscription is roaming, false otherwise\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isActiveSubscriptionId(int subscriptionId)", "label": "public boolean isActiveSubscriptionId(int subscriptionId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Checks if the supplied subscription ID corresponds to a subscription which is actively in\\n     * use on the device. An active subscription ID is a valid and usable subscription ID.\\n     *\\n     * @param subscriptionId the subscription ID.\\n     * @return {@code true} if the supplied subscription ID corresponds to an active subscription;\\n     * {@code false} if it does not correspond to an active subscription; or throw a\\n     * SecurityException if the caller hasn\u0027t got the right permission.\\n     \"}"}, {"color": "#97c2fc", "id": "public List\u003cSubscriptionPlan\u003e getSubscriptionPlans(int subId)", "label": "public List\u003cSubscriptionPlan\u003e getSubscriptionPlans(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Get the description of the billing relationship plan between a carrier\\n     * and a specific subscriber.\\n     * \u003cp\u003e\\n     * This method is only accessible to the following narrow set of apps:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe carrier app for this subscriberId, as determined by\\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\\n     * \u003cli\u003eThe carrier app explicitly delegated access through\\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\\n     * \u003c/ul\u003e\\n     *\\n     * @param subId the subscriber this relationship applies to\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     \"}"}, {"color": "#97c2fc", "id": "KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "label": "KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CarrierConfigManager", "label": "android.telephony.CarrierConfigManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Provides access to telephony configuration values that are carrier-specific.\\n \u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle getConfigForSubId(int subId)", "label": "public PersistableBundle getConfigForSubId(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the configuration values for a particular subscription, which is associated with a\\n     * specific SIM card. If an invalid subId is used, the returned config will contain default\\n     * values. After using this method to get the configuration bundle,\\n     * {@link #isConfigForIdentifiedCarrier(PersistableBundle)} should be called to confirm whether\\n     * any carrier specific configuration has been applied.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     *\\n     * @param subId the subscription ID, normally obtained from {@link SubscriptionManager}.\\n     * @return A {@link PersistableBundle} containing the config for the given subId, or default\\n     *         values for an invalid subId.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.os.PersistableBundle", "label": "android.os.PersistableBundle", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A mapping from String keys to values of various types. The set of types\\n * supported by this class is purposefully restricted to simple objects that can\\n * safely be persisted to and restored from disk.\\n *\\n * @see Bundle\\n \u0027}"}, {"color": "#97c2fc", "id": "public Object clone()", "label": "public Object clone()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Clones the current Bundle. The internal map is cloned, but the keys and\\n     * values to which it refers are copied by reference.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle deepCopy()", "label": "public PersistableBundle deepCopy()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Make a deep copy of the given bundle.  Traverses into inner containers and copies\\n     * them as well, so they are not shared across bundles.  Will traverse in to\\n     * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of\\n     * primitive arrays.  Other types of objects (such as Parcelable or Serializable)\\n     * are referenced as-is and not copied in any way.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.os.Bundle", "label": "android.os.Bundle", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A mapping from String keys to various {@link Parcelable} values.\\n *\\n * @see PersistableBundle\\n \u0027}"}, {"color": "#97c2fc", "id": "private void maybePrefillHasFds()", "label": "private void maybePrefillHasFds()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If {@link #mParcelledData} is not null, copy the HAS FDS bit from it because it\u0027s fast.\\n     * Otherwise (if {@link #mParcelledData} is already null), leave {@link #FLAG_HAS_FDS_KNOWN}\\n     * unset, because scanning a map is slower.  We\u0027ll do it lazily in\\n     * {@link #hasFileDescriptors()}.\\n     \"}"}, {"color": "#97c2fc", "id": "FLAG_HAS_FDS_KNOWN", "label": "FLAG_HAS_FDS_KNOWN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "hasFileDescriptors()", "label": "hasFileDescriptors()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mParcelledData", "label": "mParcelledData", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setClassLoader(ClassLoader loader)", "label": "public void setClassLoader(ClassLoader loader)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Changes the ClassLoader this Bundle uses when instantiating objects.\\n     *\\n     * @param loader An explicit ClassLoader to use when instantiating objects\\n     * inside of the Bundle.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ClassLoader getClassLoader()", "label": "public ClassLoader getClassLoader()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the ClassLoader currently associated with this Bundle.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Bundle deepCopy()", "label": "public Bundle deepCopy()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Make a deep copy of the given bundle.  Traverses into inner containers and copies\\n     * them as well, so they are not shared across bundles.  Will traverse in to\\n     * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of\\n     * primitive arrays.  Other types of objects (such as Parcelable or Serializable)\\n     * are referenced as-is and not copied in any way.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.ArrayList", "label": "java.util.ArrayList", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void clear()", "label": "public void clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Clears this object to its initial state.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void remove(String key)", "label": "public void remove(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes any entry with the given key from the mapping of this Bundle.\\n     *\\n     * @param key a String key\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putAll(Bundle bundle)", "label": "public void putAll(Bundle bundle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts all mappings from the given Bundle into this Bundle.\\n     *\\n     * @param bundle a Bundle\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasFileDescriptors()", "label": "public boolean hasFileDescriptors()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reports whether the bundle contains any parcelled file descriptors.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putByte(@Nullable String key, byte value)", "label": "public void putByte(@Nullable String key, byte value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a byte value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.\\n     *\\n     * @param key a String, or null\\n     * @param value a byte\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putChar(@Nullable String key, char value)", "label": "public void putChar(@Nullable String key, char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a char value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.\\n     *\\n     * @param key a String, or null\\n     * @param value a char\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putShort(@Nullable String key, short value)", "label": "public void putShort(@Nullable String key, short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a short value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.\\n     *\\n     * @param key a String, or null\\n     * @param value a short\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putFloat(@Nullable String key, float value)", "label": "public void putFloat(@Nullable String key, float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a float value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.\\n     *\\n     * @param key a String, or null\\n     * @param value a float\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putCharSequence(@Nullable String key, @Nullable CharSequence value)", "label": "public void putCharSequence(@Nullable String key, @Nullable CharSequence value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a CharSequence value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a CharSequence, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putParcelable(@Nullable String key, @Nullable Parcelable value)", "label": "public void putParcelable(@Nullable String key, @Nullable Parcelable value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a Parcelable value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a Parcelable object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putSize(@Nullable String key, @Nullable Size value)", "label": "public void putSize(@Nullable String key, @Nullable Size value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a Size value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a Size object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putSizeF(@Nullable String key, @Nullable SizeF value)", "label": "public void putSizeF(@Nullable String key, @Nullable SizeF value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a SizeF value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a SizeF object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putParcelableArray(@Nullable String key, @Nullable Parcelable[] value)", "label": "public void putParcelableArray(@Nullable String key, @Nullable Parcelable[] value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts an array of Parcelable values into the mapping of this Bundle,\\n     * replacing any existing value for the given key.  Either key or value may\\n     * be null.\\n     *\\n     * @param key a String, or null\\n     * @param value an array of Parcelable objects, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putParcelableArrayList(@Nullable String key, @Nullable ArrayList\u003c? extends Parcelable\u003e value)", "label": "public void putParcelableArrayList(@Nullable String key, @Nullable ArrayList\u003c? extends Parcelable\u003e value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a List of Parcelable values into the mapping of this Bundle,\\n     * replacing any existing value for the given key.  Either key or value may\\n     * be null.\\n     *\\n     * @param key a String, or null\\n     * @param value an ArrayList of Parcelable objects, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putSparseParcelableArray(@Nullable String key, @Nullable SparseArray\u003c? extends Parcelable\u003e value)", "label": "public void putSparseParcelableArray(@Nullable String key, @Nullable SparseArray\u003c? extends Parcelable\u003e value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a SparceArray of Parcelable values into the mapping of this\\n     * Bundle, replacing any existing value for the given key.  Either key\\n     * or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a SparseArray of Parcelable objects, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putIntegerArrayList(@Nullable String key, @Nullable ArrayList\u003cInteger\u003e value)", "label": "public void putIntegerArrayList(@Nullable String key, @Nullable ArrayList\u003cInteger\u003e value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts an ArrayList\u003cInteger\u003e value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value an ArrayList\u003cInteger\u003e object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putStringArrayList(@Nullable String key, @Nullable ArrayList\u003cString\u003e value)", "label": "public void putStringArrayList(@Nullable String key, @Nullable ArrayList\u003cString\u003e value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts an ArrayList\u003cString\u003e value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value an ArrayList\u003cString\u003e object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putCharSequenceArrayList(@Nullable String key, @Nullable ArrayList\u003cCharSequence\u003e value)", "label": "public void putCharSequenceArrayList(@Nullable String key, @Nullable ArrayList\u003cCharSequence\u003e value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts an ArrayList\u003cCharSequence\u003e value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value an ArrayList\u003cCharSequence\u003e object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putSerializable(@Nullable String key, @Nullable Serializable value)", "label": "public void putSerializable(@Nullable String key, @Nullable Serializable value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a Serializable value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a Serializable object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putByteArray(@Nullable String key, @Nullable byte[] value)", "label": "public void putByteArray(@Nullable String key, @Nullable byte[] value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a byte array value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a byte array object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putShortArray(@Nullable String key, @Nullable short[] value)", "label": "public void putShortArray(@Nullable String key, @Nullable short[] value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a short array value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a short array object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putCharArray(@Nullable String key, @Nullable char[] value)", "label": "public void putCharArray(@Nullable String key, @Nullable char[] value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a char array value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a char array object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putFloatArray(@Nullable String key, @Nullable float[] value)", "label": "public void putFloatArray(@Nullable String key, @Nullable float[] value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a float array value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a float array object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putCharSequenceArray(@Nullable String key, @Nullable CharSequence[] value)", "label": "public void putCharSequenceArray(@Nullable String key, @Nullable CharSequence[] value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a CharSequence array value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a CharSequence array object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putBundle(@Nullable String key, @Nullable Bundle value)", "label": "public void putBundle(@Nullable String key, @Nullable Bundle value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a Bundle value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a Bundle object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putBinder(@Nullable String key, @Nullable IBinder value)", "label": "public void putBinder(@Nullable String key, @Nullable IBinder value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts an {@link IBinder} value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * \u003cp class=\"note\"\u003eYou should be very careful when using this function.  In many\\n     * places where Bundles are used (such as inside of Intent objects), the Bundle\\n     * can live longer inside of another process than the process that had originally\\n     * created it.  In that case, the IBinder you supply here will become invalid\\n     * when your process goes away, and no longer usable, even if a new process is\\n     * created for you later on.\u003c/p\u003e\\n     *\\n     * @param key a String, or null\\n     * @param value an IBinder object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.os.IBinder", "label": "android.os.IBinder", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public byte getByte(String key)", "label": "public byte getByte(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or (byte) 0 if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @return a byte value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Byte getByte(String key, byte defaultValue)", "label": "public Byte getByte(String key, byte defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or defaultValue if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @param defaultValue Value to return if key does not exist\\n     * @return a byte value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public char getChar(String key)", "label": "public char getChar(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or (char) 0 if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @return a char value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public char getChar(String key, char defaultValue)", "label": "public char getChar(String key, char defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or defaultValue if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @param defaultValue Value to return if key does not exist\\n     * @return a char value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public short getShort(String key)", "label": "public short getShort(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or (short) 0 if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @return a short value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public short getShort(String key, short defaultValue)", "label": "public short getShort(String key, short defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or defaultValue if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @param defaultValue Value to return if key does not exist\\n     * @return a short value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public float getFloat(String key)", "label": "public float getFloat(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or 0.0f if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @return a float value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public float getFloat(String key, float defaultValue)", "label": "public float getFloat(String key, float defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or defaultValue if\\n     * no mapping of the desired type exists for the given key.\\n     *\\n     * @param key a String\\n     * @param defaultValue Value to return if key does not exist\\n     * @return a float value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getCharSequence(@Nullable String key)", "label": "public CharSequence getCharSequence(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a CharSequence value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getCharSequence(@Nullable String key, CharSequence defaultValue)", "label": "public CharSequence getCharSequence(@Nullable String key, CharSequence defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or defaultValue if\\n     * no mapping of the desired type exists for the given key or if a null\\n     * value is explicitly associatd with the given key.\\n     *\\n     * @param key a String, or null\\n     * @param defaultValue Value to return if key does not exist or if a null\\n     *     value is associated with the given key.\\n     * @return the CharSequence value associated with the given key, or defaultValue\\n     *     if no valid CharSequence object is currently mapped to that key.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Size getSize(@Nullable String key)", "label": "public Size getSize(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a Size value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SizeF getSizeF(@Nullable String key)", "label": "public SizeF getSizeF(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a Size value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Bundle getBundle(@Nullable String key)", "label": "public Bundle getBundle(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a Bundle value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public T getParcelable(@Nullable String key)", "label": "public T getParcelable(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or {@code null} if\\n     * no mapping of the desired type exists for the given key or a {@code null}\\n     * value is explicitly associated with the key.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote: \u003c/b\u003e if the expected value is not a class provided by the Android platform,\\n     * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.\\n     * Otherwise, this method might throw an exception or return {@code null}.\\n     *\\n     * @param key a String, or {@code null}\\n     * @return a Parcelable value, or {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "ClassLoader", "label": "ClassLoader", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "setClassLoader(ClassLoader)", "label": "setClassLoader(ClassLoader)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Parcelable[] getParcelableArray(@Nullable String key)", "label": "public Parcelable[] getParcelableArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or {@code null} if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote: \u003c/b\u003e if the expected value is not a class provided by the Android platform,\\n     * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.\\n     * Otherwise, this method might throw an exception or return {@code null}.\\n     *\\n     * @param key a String, or {@code null}\\n     * @return a Parcelable[] value, or {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ArrayList\u003cT\u003e getParcelableArrayList(@Nullable String key)", "label": "public ArrayList\u003cT\u003e getParcelableArrayList(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or {@code null} if\\n     * no mapping of the desired type exists for the given key or a {@code null}\\n     * value is explicitly associated with the key.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote: \u003c/b\u003e if the expected value is not a class provided by the Android platform,\\n     * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.\\n     * Otherwise, this method might throw an exception or return {@code null}.\\n     *\\n     * @param key a String, or {@code null}\\n     * @return an ArrayList\u003cT\u003e value, or {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SparseArray\u003cT\u003e getSparseParcelableArray(@Nullable String key)", "label": "public SparseArray\u003cT\u003e getSparseParcelableArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     *\\n     * @return a SparseArray of T values, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Serializable getSerializable(@Nullable String key)", "label": "public Serializable getSerializable(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a Serializable value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ArrayList\u003cInteger\u003e getIntegerArrayList(@Nullable String key)", "label": "public ArrayList\u003cInteger\u003e getIntegerArrayList(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return an ArrayList\u003cString\u003e value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ArrayList\u003cString\u003e getStringArrayList(@Nullable String key)", "label": "public ArrayList\u003cString\u003e getStringArrayList(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return an ArrayList\u003cString\u003e value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ArrayList\u003cCharSequence\u003e getCharSequenceArrayList(@Nullable String key)", "label": "public ArrayList\u003cCharSequence\u003e getCharSequenceArrayList(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return an ArrayList\u003cCharSequence\u003e value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getByteArray(@Nullable String key)", "label": "public byte[] getByteArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a byte[] value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public short[] getShortArray(@Nullable String key)", "label": "public short[] getShortArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a short[] value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public char[] getCharArray(@Nullable String key)", "label": "public char[] getCharArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a char[] value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public float[] getFloatArray(@Nullable String key)", "label": "public float[] getFloatArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a float[] value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence[] getCharSequenceArray(@Nullable String key)", "label": "public CharSequence[] getCharSequenceArray(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a CharSequence[] value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public IBinder getBinder(@Nullable String key)", "label": "public IBinder getBinder(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return an IBinder value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeToParcel(Parcel parcel, int flags)", "label": "public void writeToParcel(Parcel parcel, int flags)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes the PersistableBundle contents to a Parcel, typically in order for\\n     * it to be passed through an IBinder connection.\\n     * @param parcel The parcel to copy this bundle to.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void readFromParcel(Parcel parcel)", "label": "public void readFromParcel(Parcel parcel)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the Parcel contents into this Bundle, typically in order for\\n     * it to be passed through an IBinder connection.\\n     * @param parcel The parcel to overwrite this bundle from.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void putPersistableBundle(@Nullable String key, @Nullable PersistableBundle value)", "label": "public void putPersistableBundle(@Nullable String key, @Nullable PersistableBundle value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts a PersistableBundle value into the mapping of this Bundle, replacing\\n     * any existing value for the given key.  Either key or value may be null.\\n     *\\n     * @param key a String, or null\\n     * @param value a Bundle object, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle getPersistableBundle(@Nullable String key)", "label": "public PersistableBundle getPersistableBundle(@Nullable String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value associated with the given key, or null if\\n     * no mapping of the desired type exists for the given key or a null\\n     * value is explicitly associated with the key.\\n     *\\n     * @param key a String, or null\\n     * @return a Bundle value, or null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeToStream(@NonNull OutputStream outputStream) throws IOException", "label": "public void writeToStream(@NonNull OutputStream outputStream) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes the content of the {@link PersistableBundle} to a {@link OutputStream}.\\n     *\\n     * \u003cp\u003eThe content can be read by a {@link #readFromStream}.\\n     *\\n     * @see #readFromStream\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.util.proto.ProtoOutputStream", "label": "android.util.proto.ProtoOutputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \" IMPLEMENTATION NOTES\\n *\\n * Because protobuf has inner values, and they are length prefixed, and\\n * those sizes themselves are stored with a variable length encoding, it\\n * is impossible to know how big an object will be in a single pass.\\n *\\n * The traditional way is to copy the in-memory representation of an object\\n * into the generated proto Message objects, do a traversal of those to\\n * cache the size, and then write the size-prefixed buffers.\\n *\\n * We are trying to avoid too much generated code here, but this class still\\n * needs to have a somewhat sane API.  We can\u0027t have the multiple passes be\\n * done by the calling code.  In addition, we want to avoid the memory high\\n * water mark of duplicating all of the values into the traditional in-memory\\n * Message objects. We need to find another way.\\n *\\n * So what we do here is to let the calling code write the data into a\\n * byte[] (actually a collection of them wrapped in the EncodedBuffer class),\\n * but not do the varint encoding of the sub-message sizes.  Then, we do a\\n * recursive traversal of the buffer itself, calculating the sizes (which are\\n * then knowable, although still not the actual sizes in the buffer because of\\n * possible further nesting).  Then we do a third pass, compacting the\\n * buffer and varint encoding the sizes.\\n *\\n * This gets us a relatively small number of fixed-size allocations,\\n * which is less likely to cause memory fragmentation or churn the GC, and\\n * the same number of data copies as we would have gotten with setting it\\n * field-by-field in generated code, and no code bloat from generated code.\\n * The final data copy is also done with System.arraycopy, which will be\\n * more efficient, in general, than doing the individual fields twice (as in\\n * the traditional way).\\n *\\n * To accomplish the multiple passes, whenever we write a\\n * WIRE_TYPE_LENGTH_DELIMITED field, we write the size occupied in our\\n * buffer as a fixed 32 bit int (called childRawSize), not a variable length\\n * one. We reserve another 32 bit slot for the computed size (called\\n * childEncodedSize).  If we know the size up front, as we do for strings\\n * and byte[], then we also put that into childEncodedSize, if we don\u0027t, we\\n * write the negative of childRawSize, as a sentinel that we need to\\n * compute it during the second pass and recursively compact it during the\\n * third pass.\\n *\\n * Unsigned size varints can be up to five bytes long, but we reserve eight\\n * bytes for overhead, so we know that when we compact the buffer, there\\n * will always be space for the encoded varint.\\n *\\n * When we can figure out the size ahead of time, we do, in order\\n * to save overhead with recalculating it, and with the later arraycopy.\\n *\\n * During the period between when the caller has called #start, but\\n * not yet called #end, we maintain a linked list of the tokens\\n * returned by #start, stored in those 8 bytes of size storage space.\\n * We use that linked list of tokens to ensure that the caller has\\n * correctly matched pairs of #start and #end calls, and issue\\n * errors if they are not matched.\\n \"}"}, {"color": "#97c2fc", "id": "public int getRawSize()", "label": "public int getRawSize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the total size of the data that has been written, after full\\n     * protobuf encoding has occurred.\\n     *\\n     * @return the uncompressed buffer size\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, double val)", "label": "public void write(long fieldId, double val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a value for the given fieldId.\\n     *\\n     * \u003cp\u003eWill automatically convert for the following field types, and\\n     * throw an exception for others: double, float, int32, int64, uint32, uint64,\\n     * sint32, sint64, fixed32, fixed64, sfixed32, sfixed64, bool, enum.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, float val)", "label": "public void write(long fieldId, float val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a value for the given fieldId.\\n     *\\n     * \u003cp\u003eWill automatically convert for the following field types, and\\n     * throw an exception for others: double, float, int32, int64, uint32, uint64,\\n     * sint32, sint64, fixed32, fixed64, sfixed32, sfixed64, bool, enum.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, int val)", "label": "public void write(long fieldId, int val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a value for the given fieldId.\\n     *\\n     * \u003cp\u003eWill automatically convert for the following field types, and\\n     * throw an exception for others: double, float, int32, int64, uint32, uint64,\\n     * sint32, sint64, fixed32, fixed64, sfixed32, sfixed64, bool, enum.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, long val)", "label": "public void write(long fieldId, long val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a value for the given fieldId.\\n     *\\n     * \u003cp\u003eWill automatically convert for the following field types, and\\n     * throw an exception for others: double, float, int32, int64, uint32, uint64,\\n     * sint32, sint64, fixed32, fixed64, sfixed32, sfixed64, bool, enum.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, boolean val)", "label": "public void write(long fieldId, boolean val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a boolean value for the given fieldId.\\n     *\\n     * \u003cp\u003eIf the field is not a bool field, an {@link IllegalStateException} will be thrown.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "IllegalStateException", "label": "IllegalStateException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, @Nullable String val)", "label": "public void write(long fieldId, @Nullable String val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a string value for the given fieldId.\\n     *\\n     * \u003cp\u003eIf the field is not a string field, an exception will be thrown.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(long fieldId, @Nullable byte[] val)", "label": "public void write(long fieldId, @Nullable byte[] val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a byte[] value for the given fieldId.\\n     *\\n     * \u003cp\u003eIf the field is not a bytes or object field, an exception will be thrown.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @param val The value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long start(long fieldId)", "label": "public long start(long fieldId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Start a sub object.\\n     *\\n     * @param fieldId The field identifier constant from the generated class.\\n     * @return The token to call {@link #end(long)} with.\\n     \u0027}"}, {"color": "#97c2fc", "id": "end(long)", "label": "end(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void end(long token)", "label": "public void end(long token)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * End the object started by start() that returned token.\\n     *\\n     * @param token The token returned from {@link #start(long)}\\n     \u0027}"}, {"color": "#97c2fc", "id": "start(long)", "label": "start(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private void writeUnsignedVarintFromSignedInt(int val)", "label": "private void writeUnsignedVarintFromSignedInt(int val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a java int as an usigned varint.\\n     *\\n     * \u003cp\u003eThe unadorned int32 type in protobuf is unfortunate because it\\n     * is stored in memory as a signed value, but encodes as unsigned\\n     * varints, which are formally always longs.  So here, we encode\\n     * negative values as 64 bits, which will get the sign-extension,\\n     * and positive values as 32 bits, which saves a marginal amount\\n     * of work in that it processes ints instead of longs.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeUtf8String(int id, String val)", "label": "private void writeUtf8String(int id, String val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a list of packed proto \"string\" type field value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private long startObjectImpl(final int id, boolean repeated)", "label": "private long startObjectImpl(final int id, boolean repeated)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Common implementation of startObject and startRepeatedObject.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void endObjectImpl(long token, boolean repeated)", "label": "private void endObjectImpl(long token, boolean repeated)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Common implementation of endObject and endRepeatedObject.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static long makeFieldId(int id, long fieldFlags)", "label": "public static long makeFieldId(int id, long fieldFlags)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Combine a fieldId (the field keys in the proto file) and the field flags.\\n     * Mostly useful for testing because the generated code contains the fieldId\\n     * constants.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int checkFieldId(long fieldId, long expectedFlags)", "label": "public static int checkFieldId(long fieldId, long expectedFlags)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Validates that the fieldId provided is of the type and count from expectedType.\\n     *\\n     * \u003cp\u003eThe type must match exactly to pass this check.\\n     *\\n     * \u003cp\u003eThe count must match according to this truth table to pass the check:\\n     *\\n     *                  expectedFlags\\n     *                  UNKNOWN     SINGLE      REPEATED    PACKED\\n     *    fieldId\\n     *    UNKNOWN       true        false       false       false\\n     *    SINGLE        x           true        false       false\\n     *    REPEATED      x           false       true        false\\n     *    PACKED        x           false       true        true\\n     *\\n     * @throws {@link IllegalArgumentException} if it is not.\\n     *\\n     * @return The raw ID of that field.\\n     \u0027}"}, {"color": "#97c2fc", "id": "IllegalArgumentException", "label": "IllegalArgumentException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "private static int getTagSize(int id)", "label": "private static int getTagSize(int id)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return how many bytes an encoded field tag will require.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeTag(int id, @WireType int wireType)", "label": "public void writeTag(int id, @WireType int wireType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write an individual field tag by hand.\\n     *\\n     * See \u003ca href=\"https://developers.google.com/protocol-buffers/docs/encoding\"\u003eProtobuf\\n     * Encoding\u003c/a\u003e for details on the structure of how tags and data are written.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeKnownLengthHeader(int id, int size)", "label": "private void writeKnownLengthHeader(int id, int size)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write the header of a WIRE_TYPE_LENGTH_DELIMITED field for one where\\n     * we know the size in advance and do not need to compute and compact.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void assertNotCompacted()", "label": "private void assertNotCompacted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assert that the compact call has not already occured.\\n     *\\n     * TODO: Will change when we add the OutputStream version of ProtoOutputStream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getBytes()", "label": "public byte[] getBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finish the encoding of the data, and return a byte[] with\\n     * the protobuf formatted data.\\n     *\\n     * \u003cp\u003eAfter this call, do not call any of the write* functions. The\\n     * behavior is undefined.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void compactIfNecessary()", "label": "private void compactIfNecessary()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If the buffer hasn\u0027t already had the nested object size fields compacted\\n     * and turned into an actual protobuf format, then do so.\\n     \"}"}, {"color": "#97c2fc", "id": "private int editEncodedSize(int rawSize)", "label": "private int editEncodedSize(int rawSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * First compaction pass. Iterate through the data, and fill in the\\n     * nested object sizes so the next pass can compact them.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void compactSizes(int rawSize)", "label": "private void compactSizes(int rawSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Second compaction pass.  Iterate through the data, and copy the data\\n     * forward in the buffer, converting the pairs of uint32s into a single\\n     * unsigned varint of the size.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void flush()", "label": "public void flush()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write remaining data to the output stream.  If there is no output stream,\\n     * this function does nothing. Any currently open objects (i.e. ones that\\n     * have not had {@link #end(long)} called for them will not be written).  Whether this\\n     * writes objects that are closed if there are remaining open objects is\\n     * undefined (current implementation does not write it, future ones will).\\n     * For now, can either call {@link #getBytes()} or {@link #flush()}, but not both.\\n     \u0027}"}, {"color": "#97c2fc", "id": "flush()", "label": "flush()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getBytes()", "label": "getBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private int readRawTag()", "label": "private int readRawTag()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read a raw tag from the buffer.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void dump(@NonNull String tag)", "label": "public void dump(@NonNull String tag)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Dump debugging data about the buffers with the given log tag.\\n     \u0027}"}, {"color": "#97c2fc", "id": "readFromStream", "label": "readFromStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static PersistableBundle readFromStream(@NonNull InputStream inputStream) throws IOException", "label": "public static PersistableBundle readFromStream(@NonNull InputStream inputStream) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a {@link PersistableBundle} from an {@link InputStream}.\\n     *\\n     * \u003cp\u003eThe stream must be generated by {@link #writeToStream}.\\n     *\\n     * @see #writeToStream\\n     \u0027}"}, {"color": "#97c2fc", "id": "writeToStream", "label": "writeToStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.InputStream", "label": "java.io.InputStream", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "isConfigForIdentifiedCarrier(PersistableBundle)", "label": "isConfigForIdentifiedCarrier(PersistableBundle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle getConfig()", "label": "public PersistableBundle getConfig()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the configuration values for the default subscription. After using this method to get\\n     * the configuration bundle, {@link #isConfigForIdentifiedCarrier(PersistableBundle)} should be\\n     * called to confirm whether any carrier specific configuration has been applied.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     *\\n     * @see #getConfigForSubId\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)", "label": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether a configuration {@link PersistableBundle} obtained from\\n     * {@link #getConfig()} or {@link #getConfigForSubId(int)} corresponds to an identified carrier.\\n     * \u003cp\u003e\\n     * When an app receives the {@link CarrierConfigManager#ACTION_CARRIER_CONFIG_CHANGED}\\n     * broadcast which informs it that the carrier configuration has changed, it is possible\\n     * that another reload of the carrier configuration has begun since the intent was sent.\\n     * In this case, the carrier configuration the app fetches (e.g. via {@link #getConfig()})\\n     * may not represent the configuration for the current carrier. It should be noted that it\\n     * does not necessarily mean the configuration belongs to current carrier when this function\\n     * return true because it may belong to another previous identified carrier. Users should\\n     * always call {@link #getConfig()} or {@link #getConfigForSubId(int)} after receiving the\\n     * broadcast {@link #ACTION_CARRIER_CONFIG_CHANGED}.\\n     * \u003c/p\u003e\\n     * \u003cp\u003e\\n     * After using {@link #getConfig()} or {@link #getConfigForSubId(int)} an app should always\\n     * use this method to confirm whether any carrier specific configuration has been applied.\\n     * Especially when an app misses the broadcast {@link #ACTION_CARRIER_CONFIG_CHANGED} but it\\n     * still needs to get the current configuration, it must use this method to verify whether the\\n     * configuration is default or carrier overridden.\\n     * \u003c/p\u003e\\n     *\\n     * @param bundle the configuration bundle to be checked.\\n     * @return boolean true if any carrier specific configuration bundle has been applied, false\\n     * otherwise or the bundle is null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "ACTION_CARRIER_CONFIG_CHANGED", "label": "ACTION_CARRIER_CONFIG_CHANGED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getConfigForSubId(int)", "label": "getConfigForSubId(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getConfig()", "label": "getConfig()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void notifyConfigChangedForSubId(int subId)", "label": "public void notifyConfigChangedForSubId(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Calling this method triggers telephony services to fetch the current carrier configuration.\\n     * \u003cp\u003e\\n     * Normally this does not need to be called because the platform reloads config on its own.\\n     * This should be called by a carrier service app if it wants to update config at an arbitrary\\n     * moment.\\n     * \u003c/p\u003e\\n     * \u003cp\u003eRequires that the calling app has carrier privileges.\\n     * \u003cp\u003e\\n     * This method returns before the reload has completed, and\\n     * {@link android.service.carrier.CarrierService#onLoadConfig} will be called from an\\n     * arbitrary thread.\\n     * \u003c/p\u003e\\n     * @see TelephonyManager#hasCarrierPrivileges\\n     \u0027}"}, {"color": "#97c2fc", "id": "onLoadConfig", "label": "onLoadConfig", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle getConfigByComponentForSubId(@NonNull String prefix, int subId)", "label": "public PersistableBundle getConfigByComponentForSubId(@NonNull String prefix, int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the configuration values for a component using its prefix.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     *\\n     * @param prefix prefix of the component.\\n     * @param subId the subscription ID, normally obtained from {@link SubscriptionManager}.\\n     *\\n     * @see #getConfigForSubId\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setSubscriptionPlans(int subId, @NonNull List\u003cSubscriptionPlan\u003e plans)", "label": "public void setSubscriptionPlans(int subId, @NonNull List\u003cSubscriptionPlan\u003e plans)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Set the description of the billing relationship plan between a carrier\\n     * and a specific subscriber.\\n     * \u003cp\u003e\\n     * This method is only accessible to the following narrow set of apps:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe carrier app for this subscriberId, as determined by\\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\\n     * \u003cli\u003eThe carrier app explicitly delegated access through\\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\\n     * \u003c/ul\u003e\\n     *\\n     * @param subId the subscriber this relationship applies to. An empty list\\n     *            may be sent to clear any existing plans.\\n     * @param plans the list of plans. The first plan is always the primary and\\n     *            most important plan. Any additional plans are secondary and\\n     *            may not be displayed or used by decision making logic.\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     * @throws IllegalArgumentException if plans don\u0027t meet the requirements\\n     *             defined in {@link SubscriptionPlan}.\\n     \"}"}, {"color": "#97c2fc", "id": "android.telephony.SubscriptionPlan", "label": "android.telephony.SubscriptionPlan", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Description of a billing relationship plan between a carrier and a specific\\n * subscriber. This information is used to present more useful UI to users, such\\n * as explaining how much mobile data they have remaining, and what will happen\\n * when they run out.\\n *\\n * If specifying network types, the developer must supply at least one plan\\n * that applies to all network types (default), and all additional plans\\n * may not include a particular network type more than once.\\n * This is enforced by {@link SubscriptionManager} when setting the plans.\\n *\\n * Plan selection will prefer plans that have specific network types defined\\n * over plans that apply to all network types.\\n *\\n * @see SubscriptionManager#setSubscriptionPlans(int, java.util.List)\\n * @see SubscriptionManager#getSubscriptionPlans(int)\\n \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getTitle()", "label": "public CharSequence getTitle()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Return the short title of this plan. \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getSummary()", "label": "public CharSequence getSummary()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Return the short summary of this plan. \u0027}"}, {"color": "#97c2fc", "id": "public long getDataLimitBytes()", "label": "public long getDataLimitBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the usage threshold at which data access changes according to\\n     * {@link #getDataLimitBehavior()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDataLimitBehavior()", "label": "getDataLimitBehavior()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getDataLimitBehavior()", "label": "public int getDataLimitBehavior()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the behavior of data access when usage reaches\\n     * {@link #getDataLimitBytes()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDataLimitBytes()", "label": "getDataLimitBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public long getDataUsageBytes()", "label": "public long getDataUsageBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return a snapshot of currently known mobile data usage at\\n     * {@link #getDataUsageTime()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDataUsageTime()", "label": "getDataUsageTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public long getDataUsageTime()", "label": "public long getDataUsageTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the time at which {@link #getDataUsageBytes()} was valid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDataUsageBytes()", "label": "getDataUsageBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int[] getNetworkTypes()", "label": "public int[] getNetworkTypes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return an array containing all {@link NetworkType}s this SubscriptionPlan applies to.\\n     * @see TelephonyManager for network types values\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.Annotation.NetworkType", "label": "android.telephony.Annotation.NetworkType", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public Iterator\u003cRange\u003cZonedDateTime\u003e\u003e cycleIterator()", "label": "public Iterator\u003cRange\u003cZonedDateTime\u003e\u003e cycleIterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return an iterator that will return all valid data usage cycles based on\\n     * any recurrence rules. The iterator starts from the currently active cycle\\n     * and walks backwards through time.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long timeoutMillis)", "label": "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long timeoutMillis)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Temporarily override the billing relationship plan between a carrier and\\n     * a specific subscriber to be considered unmetered. This will be reflected\\n     * to apps via {@link NetworkCapabilities#NET_CAPABILITY_NOT_METERED}.\\n     * \u003cp\u003e\\n     * This method is only accessible to the following narrow set of apps:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe carrier app for this subscriberId, as determined by\\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\\n     * \u003cli\u003eThe carrier app explicitly delegated access through\\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\\n     * \u003c/ul\u003e\\n     *\\n     * @param subId the subscriber this override applies to.\\n     * @param overrideUnmetered set if the billing relationship should be\\n     *            considered unmetered.\\n     * @param timeoutMillis the timeout after which the requested override will\\n     *            be automatically cleared, or {@code 0} to leave in the\\n     *            requested state until explicitly cleared, or the next reboot,\\n     *            whichever happens first.\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     \"}"}, {"color": "#97c2fc", "id": "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long timeoutMillis)", "label": "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long timeoutMillis)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Temporarily override the billing relationship plan between a carrier and\\n     * a specific subscriber to be considered congested. This will cause the\\n     * device to delay certain network requests when possible, such as developer\\n     * jobs that are willing to run in a flexible time window.\\n     * \u003cp\u003e\\n     * This method is only accessible to the following narrow set of apps:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe carrier app for this subscriberId, as determined by\\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\\n     * \u003cli\u003eThe carrier app explicitly delegated access through\\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\\n     * \u003c/ul\u003e\\n     *\\n     * @param subId the subscriber this override applies to.\\n     * @param overrideCongested set if the subscription should be considered\\n     *            congested.\\n     * @param timeoutMillis the timeout after which the requested override will\\n     *            be automatically cleared, or {@code 0} to leave in the\\n     *            requested state until explicitly cleared, or the next reboot,\\n     *            whichever happens first.\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean canManageSubscription(SubscriptionInfo info)", "label": "public boolean canManageSubscription(SubscriptionInfo info)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks whether the app with the given context is authorized to manage the given subscription\\n     * according to its metadata.\\n     *\\n     * @param info The subscription to check.\\n     * @return whether the app is authorized to manage this subscription per its metadata.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cSubscriptionInfo\u003e getOpportunisticSubscriptions()", "label": "public List\u003cSubscriptionInfo\u003e getOpportunisticSubscriptions()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return opportunistic subscriptions that can be visible to the caller.\\n     * Opportunistic subscriptions are for opportunistic networks, which are cellular\\n     * networks with limited capabilities and coverage, for example, CBRS.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see\\n     * {@link TelephonyManager#hasCarrierPrivileges}).\\n     *\\n     * @return the list of opportunistic subscription info. If none exists, an empty list.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)", "label": "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Switch to a certain subscription\\n     *\\n     *  @param subId sub id\\n     *  @param callbackIntent pending intent that will be sent after operation is done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setOpportunistic(boolean opportunistic, int subId)", "label": "public boolean setOpportunistic(boolean opportunistic, int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Set whether a subscription is opportunistic, that is, whether the network it connects\\n     * to has limited coverage. For example, CBRS. Setting a subscription opportunistic has\\n     * following impacts:\\n     *  1) Even if it\u0027s active, it will be dormant most of the time. The modem will not try\\n     *     to scan or camp until it knows an available network is nearby to save power.\\n     *  2) Telephony relies on system app or carrier input to notify nearby available networks.\\n     *     See {@link TelephonyManager#updateAvailableNetworks(List, Executor, Consumer)}\\n     *     for more information.\\n     *  3) In multi-SIM devices, when the network is nearby and camped, system may automatically\\n     *     switch internet data between it and default data subscription, based on carrier\\n     *     recommendation and its signal strength and metered-ness, etc.\\n     *\\n     *\\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE} or carrier\\n     * privilege permission of the subscription.\\n     *\\n     * @param opportunistic whether it\u2019s opportunistic subscription.\\n     * @param subId the unique SubscriptionInfo index in database\\n     * @return {@code true} if the operation is succeed, {@code false} otherwise.\\n     \"}"}, {"color": "#97c2fc", "id": "MODIFY_PHONE_STATE", "label": "MODIFY_PHONE_STATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public ParcelUuid createSubscriptionGroup(@NonNull List\u003cInteger\u003e subIdList)", "label": "public ParcelUuid createSubscriptionGroup(@NonNull List\u003cInteger\u003e subIdList)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Inform SubscriptionManager that subscriptions in the list are bundled\\n     * as a group. It can be multiple primary (non-opportunistic) subscriptions,\\n     * or one or more primary plus one or more opportunistic subscriptions.\\n     *\\n     * This API will always create a new immutable group and assign group UUID to all the\\n     * subscriptions, regardless whether they are in a group already or not.\\n     *\\n     * Grouped subscriptions will have below behaviors:\\n     * 1) They will share the same user settings.\\n     * 2) The opportunistic subscriptions in the group is considered invisible and will not\\n     *    return from {@link #getActiveSubscriptionInfoList()}, unless caller has carrier\\n     *    privilege permission of the subscriptions.\\n     * 3) The opportunistic subscriptions in the group can\u0027t be active by itself. If all other\\n     *    non-opportunistic ones are deactivated (unplugged or disabled in Settings),\\n     *    the opportunistic ones will be deactivated automatically.\\n     *\\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\\n     * permission or had carrier privilege permission on the subscriptions:\\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\\n     * {@link #canManageSubscription(SubscriptionInfo)}\\n     *\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     * @throws IllegalArgumentException if any of the subscriptions in the list doesn\u0027t exist.\\n     * @throws IllegalStateException if Telephony service is in bad state.\\n     *\\n     * @param subIdList list of subId that will be in the same group\\n     * @return groupUUID a UUID assigned to the subscription group.\\n     *\\n     \"}"}, {"color": "#97c2fc", "id": "getActiveSubscriptionInfoList()", "label": "getActiveSubscriptionInfoList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "canManageSubscription(SubscriptionInfo)", "label": "canManageSubscription(SubscriptionInfo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void addSubscriptionsIntoGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "label": "public void addSubscriptionsIntoGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Add a list of subscriptions into a group.\\n     * See {@link #createSubscriptionGroup(List)} for more details.\\n     *\\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\\n     * permission or had carrier privilege permission on the subscriptions:\\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\\n     * {@link #canManageSubscription(SubscriptionInfo)}\\n     *\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     * @throws IllegalArgumentException if the some subscriptions in the list doesn\u0027t exist.\\n     * @throws IllegalStateException if Telephony service is in bad state.\\n     *\\n     * @param subIdList list of subId that need adding into the group\\n     * @param groupUuid the groupUuid the subscriptions are being added to.\\n     *\\n     \"}"}, {"color": "#97c2fc", "id": "createSubscriptionGroup(List)", "label": "createSubscriptionGroup(List)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void removeSubscriptionsFromGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "label": "public void removeSubscriptionsFromGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Remove a list of subscriptions from their subscription group.\\n     * See {@link #createSubscriptionGroup(List)} for more details.\\n     *\\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\\n     * permission or had carrier privilege permission on the subscriptions:\\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\\n     * {@link #canManageSubscription(SubscriptionInfo)}\\n     *\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     * @throws IllegalArgumentException if the some subscriptions in the list doesn\u0027t belong\\n     *             the specified group.\\n     * @throws IllegalStateException if Telephony service is in bad state.\\n     *\\n     * @param subIdList list of subId that need removing from their groups.\\n     *\\n     \"}"}, {"color": "#97c2fc", "id": "public List\u003cSubscriptionInfo\u003e getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)", "label": "public List\u003cSubscriptionInfo\u003e getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Get subscriptionInfo list of subscriptions that are in the same group of given subId.\\n     * See {@link #createSubscriptionGroup(List)} for more details.\\n     *\\n     * Caller will either have {@link android.Manifest.permission#READ_PHONE_STATE}\\n     * permission or had carrier privilege permission on the subscription.\\n     * {@link TelephonyManager#hasCarrierPrivileges()}\\n     *\\n     * @throws IllegalStateException if Telephony service is in bad state.\\n     * @throws SecurityException if the caller doesn\u0027t meet the requirements\\n     *             outlined above.\\n     *\\n     * @param groupUuid of which list of subInfo will be returned.\\n     * @return list of subscriptionInfo that belong to the same group, including the given\\n     * subscription itself. It will return an empty list if no subscription belongs to the group.\\n     *\\n     \"}"}, {"color": "#97c2fc", "id": "public static int getActiveDataSubscriptionId()", "label": "public static int getActiveDataSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get active data subscription id. Active data subscription refers to the subscription\\n     * currently chosen to provide cellular internet connection to the user. This may be\\n     * different from getDefaultDataSubscriptionId(). Eg. Opportunistics data\\n     *\\n     * See {@link PhoneStateListener#onActiveDataSubscriptionIdChanged(int)} for the details.\\n     *\\n     * @return Active data subscription id if any is chosen, or\\n     * SubscriptionManager.INVALID_SUBSCRIPTION_ID if not.\\n     \u0027}"}, {"color": "#97c2fc", "id": "onActiveDataSubscriptionIdChanged(int)", "label": "onActiveDataSubscriptionIdChanged(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.PhoneStateListener", "label": "android.telephony.PhoneStateListener", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \"\\n * A listener class for monitoring changes in specific telephony states\\n * on the device, including service state, signal strength, message\\n * waiting indicator (voicemail), and others.\\n * \u003cp\u003e\\n * Override the methods for the state that you wish to receive updates for, and\\n * pass your PhoneStateListener object, along with bitwise-or of the LISTEN_\\n * flags to {@link TelephonyManager#listen TelephonyManager.listen()}. Methods are\\n * called when the state changes, as well as once on initial registration.\\n * \u003cp\u003e\\n * Note that access to some telephony information is\\n * permission-protected. Your application won\u0027t receive updates for protected\\n * information unless it has the appropriate permissions declared in\\n * its manifest file. Where permissions apply, they are noted in the\\n * appropriate LISTEN_ flags.\\n \"}"}, {"color": "#97c2fc", "id": "public void onServiceStateChanged(ServiceState serviceState)", "label": "public void onServiceStateChanged(ServiceState serviceState)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when device service state changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * The instance of {@link ServiceState} passed as an argument here will have various levels of\\n     * location information stripped from it depending on the location permissions that your app\\n     * holds. Only apps holding the {@link Manifest.permission#ACCESS_FINE_LOCATION} permission will\\n     * receive all the information in {@link ServiceState}.\\n     *\\n     * @see ServiceState#STATE_EMERGENCY_ONLY\\n     * @see ServiceState#STATE_IN_SERVICE\\n     * @see ServiceState#STATE_OUT_OF_SERVICE\\n     * @see ServiceState#STATE_POWER_OFF\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.ServiceState", "label": "android.telephony.ServiceState", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Contains phone state and service related information.\\n *\\n * The following phone information is included in returned ServiceState:\\n *\\n * \u003cul\u003e\\n *   \u003cli\u003eService state: IN_SERVICE, OUT_OF_SERVICE, EMERGENCY_ONLY, POWER_OFF\\n *   \u003cli\u003eDuplex mode: UNKNOWN, FDD, TDD\\n *   \u003cli\u003eRoaming indicator\\n *   \u003cli\u003eOperator name, short name and numeric id\\n *   \u003cli\u003eNetwork selection mode\\n * \u003c/ul\u003e\\n *\\n * For historical reasons this class is not declared as final; however,\\n * it should be treated as though it were final.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getState()", "label": "public int getState()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the high-level state of this data connection.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getDuplexMode()", "label": "public int getDuplexMode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the current duplex mode\\n     *\\n     * @see #DUPLEX_MODE_UNKNOWN\\n     * @see #DUPLEX_MODE_FDD\\n     * @see #DUPLEX_MODE_TDD\\n     *\\n     * @return Current {@code DuplexMode} for the phone\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getChannelNumber()", "label": "public int getChannelNumber()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the channel number of the current primary serving cell, or -1 if unknown\\n     *\\n     * \u003cp\u003eThis is EARFCN for LTE, UARFCN for UMTS, and ARFCN for GSM.\\n     *\\n     * @return Channel number of primary serving cell\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int[] getCellBandwidths()", "label": "public int[] getCellBandwidths()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get an array of cell bandwidths (kHz) for the current serving cells\\n     *\\n     * @return Current serving cell bandwidths\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean getRoaming()", "label": "public boolean getRoaming()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get current roaming indicator of phone\\n     * (note: not just decoding from TS 27.007 7.2)\\n     *\\n     * @return true if TS 27.007 7.2 roaming is true\\n     *              and ONS is different from SPN\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getOperatorAlphaLong()", "label": "public String getOperatorAlphaLong()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get current registered operator name in long alphanumeric format.\\n     *\\n     * In GSM/UMTS, long format can be up to 16 characters long.\\n     * In CDMA, returns the ERI text, if set. Otherwise, returns the ONS.\\n     *\\n     * @return long name of operator, null if unregistered or unknown\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getOperatorAlphaShort()", "label": "public String getOperatorAlphaShort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get current registered operator name in short alphanumeric format.\\n     *\\n     * In GSM/UMTS, short format can be up to 8 characters long.\\n     *\\n     * @return short name of operator, null if unregistered or unknown\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getOperatorNumeric()", "label": "public String getOperatorNumeric()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The country code can be decoded using\\n     * {@link com.android.internal.telephony.MccTable#countryCodeForMcc(int)}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "countryCodeForMcc(int)", "label": "countryCodeForMcc(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean getIsManualSelection()", "label": "public boolean getIsManualSelection()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get current network selection mode.\\n     *\\n     * @return true if manual mode, false if automatic mode\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean equalsHandlesNulls(Object a, Object b)", "label": "private static boolean equalsHandlesNulls(Object a, Object b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Test whether two objects hold the same data values or both are null.\\n     *\\n     * @param a first obj\\n     * @param b second obj\\n     * @return true if two objects equal or both are null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCdmaNetworkId()", "label": "public int getCdmaNetworkId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the CDMA NID (Network Identification Number), a number uniquely identifying a network\\n     * within a wireless system. (Defined in 3GPP2 C.S0023 3.4.8)\\n     * @return The CDMA NID or {@link #UNKNOWN_ID} if not available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNKNOWN_ID", "label": "UNKNOWN_ID", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getCdmaSystemId()", "label": "public int getCdmaSystemId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the CDMA SID (System Identification Number), a number uniquely identifying a wireless\\n     * system. (Defined in 3GPP2 C.S0023 3.4.8)\\n     * @return The CDMA SID or {@link #UNKNOWN_ID} if not available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cNetworkRegistrationInfo\u003e getNetworkRegistrationInfoList()", "label": "public List\u003cNetworkRegistrationInfo\u003e getNetworkRegistrationInfoList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get all of the available network registration info.\\n     *\\n     * @return List of {@link NetworkRegistrationInfo}\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.NetworkRegistrationInfo", "label": "android.telephony.NetworkRegistrationInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Description of a mobile network registration info\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getTransportType()", "label": "public int getTransportType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return The transport type.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getDomain()", "label": "public int getDomain()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return The network domain.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isRegistered()", "label": "public boolean isRegistered()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return {@code true} if registered on roaming network, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isSearching()", "label": "public boolean isSearching()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This indicates whether the device is searching for service.\\n     *\\n     * This API reports the modem searching status for\\n     * {@link AccessNetworkConstants#TRANSPORT_TYPE_WWAN} (cellular) service in either\\n     * {@link NetworkRegistrationInfo#DOMAIN_CS} or {@link NetworkRegistrationInfo#DOMAIN_PS}.\\n     * This API will not report searching status for\\n     * {@link AccessNetworkConstants#TRANSPORT_TYPE_WLAN}.\\n     *\\n     * @return {@code true} whenever the modem is searching for service.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getRegisteredPlmn()", "label": "public String getRegisteredPlmn()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the PLMN-ID for this Network Registration, also known as the RPLMN.\\n     *\\n     * \u003cp\u003eIf the device is registered, this will return the registered PLMN-ID. If registration\\n     * has failed, then this will return the PLMN ID of the last attempted registration. If the\\n     * device is not registered, or if is registered to a non-3GPP radio technology, then this\\n     * will return null.\\n     *\\n     * \u003cp\u003eSee 3GPP TS 23.122 for further information about the Registered PLMN.\\n     *\\n     * @return the registered PLMN-ID or null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isRoaming()", "label": "public boolean isRoaming()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return {@code true} if registered on roaming network, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cInteger\u003e getAvailableServices()", "label": "public List\u003cInteger\u003e getAvailableServices()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return List of available service types.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getAccessNetworkTechnology()", "label": "public int getAccessNetworkTechnology()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return The access network technology {@link NetworkType}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellIdentity getCellIdentity()", "label": "public CellIdentity getCellIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellIdentityNr} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "TRANSPORT_TYPE_WLAN", "label": "TRANSPORT_TYPE_WLAN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.AccessNetworkConstants", "label": "android.telephony.AccessNetworkConstants", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Contains access network related constants.\\n \u0027}"}, {"color": "#97c2fc", "id": "ACCESS_FINE_LOCATION", "label": "ACCESS_FINE_LOCATION", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void onMessageWaitingIndicatorChanged(boolean mwi)", "label": "public void onMessageWaitingIndicatorChanged(boolean mwi)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when the message-waiting indicator changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onCallForwardingIndicatorChanged(boolean cfi)", "label": "public void onCallForwardingIndicatorChanged(boolean cfi)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when the call-forwarding indicator changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onCellLocationChanged(CellLocation location)", "label": "public void onCellLocationChanged(CellLocation location)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when device cell location changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onCallStateChanged(@CallState int state, String phoneNumber)", "label": "public void onCallStateChanged(@CallState int state, String phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when device call state changes.\\n     * \u003cp\u003e\\n     * Reports the state of Telephony (mobile) calls on the device for the registered subscription.\\n     * \u003cp\u003e\\n     * Note: the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     * \u003cp\u003e\\n     * Note: The state returned here may differ from that returned by\\n     * {@link TelephonyManager#getCallState()}. Receivers of this callback should be aware that\\n     * calling {@link TelephonyManager#getCallState()} from within this callback may return a\\n     * different state than the callback reports.\\n     *\\n     * @param state call state\\n     * @param phoneNumber call phone number. If application does not have\\n     * {@link android.Manifest.permission#READ_CALL_LOG READ_CALL_LOG} permission or carrier\\n     * privileges (see {@link TelephonyManager#hasCarrierPrivileges}), an empty string will be\\n     * passed as an argument.\\n     \u0027}"}, {"color": "#97c2fc", "id": "READ_CALL_LOG", "label": "READ_CALL_LOG", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void onDataConnectionStateChanged(int state)", "label": "public void onDataConnectionStateChanged(int state)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when connection state changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @see TelephonyManager#DATA_DISCONNECTED\\n     * @see TelephonyManager#DATA_CONNECTING\\n     * @see TelephonyManager#DATA_CONNECTED\\n     * @see TelephonyManager#DATA_SUSPENDED\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onDataConnectionStateChanged(int state, int networkType)", "label": "public void onDataConnectionStateChanged(int state, int networkType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * same as above, but with the network type.  Both called.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onDataActivity(int direction)", "label": "public void onDataActivity(int direction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when data activity state changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @see TelephonyManager#DATA_ACTIVITY_NONE\\n     * @see TelephonyManager#DATA_ACTIVITY_IN\\n     * @see TelephonyManager#DATA_ACTIVITY_OUT\\n     * @see TelephonyManager#DATA_ACTIVITY_INOUT\\n     * @see TelephonyManager#DATA_ACTIVITY_DORMANT\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onSignalStrengthsChanged(SignalStrength signalStrength)", "label": "public void onSignalStrengthsChanged(SignalStrength signalStrength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when network signal strengths changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onCellInfoChanged(List\u003cCellInfo\u003e cellInfo)", "label": "public void onCellInfoChanged(List\u003cCellInfo\u003e cellInfo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when a observed cell info has changed or new cells have been added\\n     * or removed on the registered subscription.\\n     * Note, the registration subId s from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @param cellInfo is the list of currently visible cells.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onCallDisconnectCauseChanged(int disconnectCause, int preciseDisconnectCause)", "label": "public void onCallDisconnectCauseChanged(int disconnectCause, int preciseDisconnectCause)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when call disconnect cause changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @param disconnectCause {@link DisconnectCause}.\\n     * @param preciseDisconnectCause {@link PreciseDisconnectCause}.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.DisconnectCause", "label": "android.telephony.DisconnectCause", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Describes the cause of a disconnected call. Those disconnect causes can be converted into a more\\n * generic {@link android.telecom.DisconnectCause} object.\\n *\\n * @hide\\n \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.PreciseDisconnectCause", "label": "android.telephony.PreciseDisconnectCause", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Contains precise disconnect call causes generated by the framework and the RIL.\\n * @hide\\n \u0027}"}, {"color": "#97c2fc", "id": "public void onImsCallDisconnectCauseChanged(@NonNull ImsReasonInfo imsReasonInfo)", "label": "public void onImsCallDisconnectCauseChanged(@NonNull ImsReasonInfo imsReasonInfo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when Ims call disconnect cause changes on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @param imsReasonInfo {@link ImsReasonInfo} contains details on why IMS call failed.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.ims.ImsReasonInfo", "label": "android.telephony.ims.ImsReasonInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \"\\n * Provides details on why an IMS call failed. Applications can use the methods in this class to\\n * get local or network fault behind an IMS services failure. For example, if the code is\\n * CODE_CALL_BARRED, then the call was blocked by network call barring configuration and it is not\\n * the device\u0027s bug and the user can retry the call when network lift the barring.\\n * Typical use case includes call backs when IMS call state changed with this class as a param\\n * containing details on why IMS call changed state/failed.\\n \"}"}, {"color": "#97c2fc", "id": "public int getCode()", "label": "public int getCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return an integer representing more information about the completion of an operation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getExtraCode()", "label": "public int getExtraCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return an optional OEM specified code that provides extra information.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getExtraMessage()", "label": "public String getExtraMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return an optional OEM specified string that provides extra information about the operation\\n     * result.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toString()", "label": "public String toString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return string representation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onPreciseDataConnectionStateChanged(@NonNull PreciseDataConnectionState dataConnectionState)", "label": "public void onPreciseDataConnectionStateChanged(@NonNull PreciseDataConnectionState dataConnectionState)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback providing update about the default/internet data connection on the registered\\n     * subscription.\\n     *\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * \u003cp\u003eRequires permission {@link android.Manifest.permission#MODIFY_PHONE_STATE}\\n     * or the calling app has carrier privileges\\n     * (see {@link TelephonyManager#hasCarrierPrivileges}).\\n     *\\n     * @param dataConnectionState {@link PreciseDataConnectionState}\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.PreciseDataConnectionState", "label": "android.telephony.PreciseDataConnectionState", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Contains precise data connection state.\\n *\\n * The following data connection information is included in returned PreciseDataConnectionState:\\n *\\n * \u003cul\u003e\\n *   \u003cli\u003eData connection state.\\n *   \u003cli\u003eNetwork type of the connection.\\n *   \u003cli\u003eAPN types.\\n *   \u003cli\u003eAPN.\\n *   \u003cli\u003eThe properties of the network link.\\n *   \u003cli\u003eData connection fail cause.\\n * \u003c/ul\u003e\\n *\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getNetworkType()", "label": "public int getNetworkType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get current packet-switching cellular network type. This is the actual network type the\\n     * device is camped on.\\n     *\\n     * @return The network type.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public LinkProperties getLinkProperties()", "label": "public LinkProperties getLinkProperties()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the properties of the network link {@link LinkProperties}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.LinkProperties", "label": "android.net.LinkProperties", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Describes the properties of a network link.\\n *\\n * A link represents a connection to a network.\\n * It may have multiple addresses and multiple gateways,\\n * multiple dns servers but only one http proxy and one\\n * network interface.\\n *\\n * Note that this is just a holder of data.  Modifying it\\n * does not affect live networks.\\n *\\n \u0027}"}, {"color": "#97c2fc", "id": "public void setInterfaceName(@Nullable String iface)", "label": "public void setInterfaceName(@Nullable String iface)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the interface name for this link.  All {@link RouteInfo} already set for this\\n     * will have their interface changed to match this new value.\\n     *\\n     * @param iface The name of the network interface used for this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.RouteInfo", "label": "android.net.RouteInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Represents a network route.\\n * \u003cp\u003e\\n * This is used both to describe static network configuration and live network\\n * configuration information.\\n *\\n * A route contains three pieces of information:\\n * \u003cul\u003e\\n * \u003cli\u003ea destination {@link IpPrefix} specifying the network destinations covered by this route.\\n *     If this is {@code null} it indicates a default route of the address family (IPv4 or IPv6)\\n *     implied by the gateway IP address.\\n * \u003cli\u003ea gateway {@link InetAddress} indicating the next hop to use.  If this is {@code null} it\\n *     indicates a directly-connected route.\\n * \u003cli\u003ean interface (which may be unspecified).\\n * \u003c/ul\u003e\\n * Either the destination or the gateway may be {@code null}, but not both.  If the\\n * destination and gateway are both specified, they must be of the same address family\\n * (IPv4 or IPv6).\\n \u0027}"}, {"color": "#97c2fc", "id": "public IpPrefix getDestination()", "label": "public IpPrefix getDestination()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the destination address and prefix length in the form of an {@link IpPrefix}.\\n     *\\n     * @return {@link IpPrefix} specifying the destination.  This is never {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.IpPrefix", "label": "android.net.IpPrefix", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class represents an IP prefix, i.e., a contiguous block of IP addresses aligned on a\\n * power of two boundary (also known as an \"IP subnet\"). A prefix is specified by two pieces of\\n * information:\\n *\\n * \u003cul\u003e\\n * \u003cli\u003eA starting IP address (IPv4 or IPv6). This is the first IP address of the prefix.\\n * \u003cli\u003eA prefix length. This specifies the length of the prefix by specifing the number of bits\\n *     in the IP address, starting from the most significant bit in network byte order, that\\n *     are constant for all addresses in the prefix.\\n * \u003c/ul\u003e\\n *\\n * For example, the prefix \u003ccode\u003e192.0.2.0/24\u003c/code\u003e covers the 256 IPv4 addresses from\\n * \u003ccode\u003e192.0.2.0\u003c/code\u003e to \u003ccode\u003e192.0.2.255\u003c/code\u003e, inclusive, and the prefix\\n * \u003ccode\u003e2001:db8:1:2\u003c/code\u003e  covers the 2^64 IPv6 addresses from \u003ccode\u003e2001:db8:1:2::\u003c/code\u003e to\\n * \u003ccode\u003e2001:db8:1:2:ffff:ffff:ffff:ffff\u003c/code\u003e, inclusive.\\n *\\n * Objects of this class are immutable.\\n \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object obj)", "label": "public boolean equals(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this {@code LinkProperties} instance against the target\\n     * LinkProperties in {@code obj}. Two LinkPropertieses are equal if\\n     * all their fields are equal in values.\\n     *\\n     * For collection fields, such as mDnses, containsAll() is used to check\\n     * if two collections contains the same elements, independent of order.\\n     * There are two thoughts regarding containsAll()\\n     * 1. Duplicated elements. eg, (A, B, B) and (A, A, B) are equal.\\n     * 2. Worst case performance is O(n^2).\\n     *\\n     * @param obj the object to be tested for equality.\\n     * @return {@code true} if both objects are equal, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int hashCode()", "label": "public int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return hash code\\n     \u0027}"}, {"color": "#97c2fc", "id": "public InetAddress getAddress()", "label": "public InetAddress getAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@link InetAddress} of this {@code LinkAddress}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getRawAddress()", "label": "public byte[] getRawAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a copy of the IP address bytes in network order (the highest order byte is the zeroth\\n     * element). Modifying the returned array does not change this object\u0027s contents.\\n     *\\n     * @return the address in the form of a byte array.\\n     \"}"}, {"color": "#97c2fc", "id": "public int getPrefixLength()", "label": "public int getPrefixLength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the prefix length of this {@code LinkAddress}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contains(@NonNull InetAddress address)", "label": "public boolean contains(@NonNull InetAddress address)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the prefix contains the specified address.\\n     *\\n     * @param address An {@link InetAddress} to test.\\n     * @return {@code true} if the prefix covers the given address. {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.InetAddress", "label": "java.net.InetAddress", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void writeToParcel(Parcel dest, int flags)", "label": "public void writeToParcel(Parcel dest, int flags)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Implement the Parcelable interface \u0027}"}, {"color": "#97c2fc", "id": "public InetAddress getGateway()", "label": "public InetAddress getGateway()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the gateway or next hop {@link InetAddress} for this route.\\n     *\\n     * @return {@link InetAddress} specifying the gateway or next hop.  This may be\\n     *                             {@code null} for a directly-connected route.\"\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getInterface()", "label": "public String getInterface()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the interface used for this route if specified, else {@code null}.\\n     *\\n     * @return The name of the interface used for this route.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isDefaultRoute()", "label": "public boolean isDefaultRoute()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Indicates if this route is a default route (ie, has no destination specified).\\n     *\\n     * @return {@code true} if the destination has a prefix length of 0.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasGateway()", "label": "public boolean hasGateway()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Indicates if this route has a next hop ({@code true}) or is directly-connected\\n     * ({@code false}).\\n     *\\n     * @return {@code true} if a gateway is specified\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean matches(InetAddress destination)", "label": "public boolean matches(InetAddress destination)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the destination and prefix of this route includes the specified\\n     * address.\\n     *\\n     * @param destination A {@link InetAddress} to test to see if it would match this route.\\n     * @return {@code true} if the destination and prefix length cover the given address.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getInterfaceName()", "label": "public String getInterfaceName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the interface name for this link.  May be {@code null} if not set.\\n     *\\n     * @return The interface name set for this link or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cLinkAddress\u003e getLinkAddresses()", "label": "public List\u003cLinkAddress\u003e getLinkAddresses()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns all the {@link LinkAddress} on this link.  Typically a link will have\\n     * one IPv4 address and one or more IPv6 addresses.\\n     *\\n     * @return An unmodifiable {@link List} of {@link LinkAddress} for this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.LinkAddress", "label": "android.net.LinkAddress", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Identifies an IP address on a network link.\\n *\\n * A {@code LinkAddress} consists of:\\n * \u003cul\u003e\\n * \u003cli\u003eAn IP address and prefix length (e.g., {@code 2001:db8::1/64} or {@code 192.0.2.1/24}).\\n * The address must be unicast, as multicast addresses cannot be assigned to interfaces.\\n * \u003cli\u003eAddress flags: A bitmask of {@code OsConstants.IFA_F_*} values representing properties\\n * of the address (e.g., {@code android.system.OsConstants.IFA_F_OPTIMISTIC}).\\n * \u003cli\u003eAddress scope: One of the {@code OsConstants.IFA_F_*} values; defines the scope in which\\n * the address is unique (e.g.,\\n * {@code android.system.OsConstants.RT_SCOPE_LINK} or\\n * {@code android.system.OsConstants.RT_SCOPE_UNIVERSE}).\\n * \u003c/ul\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": "private boolean isIpv6ULA()", "label": "private boolean isIpv6ULA()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility function to check if |address| is a Unique Local IPv6 Unicast Address\\n     * (a.k.a. \"ULA\"; RFC 4193).\\n     *\\n     * Per RFC 4193 section 8, fc00::/7 identifies these addresses.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void init(InetAddress address, int prefixLength, int flags, int scope, long deprecationTime, long expirationTime)", "label": "private void init(InetAddress address, int prefixLength, int flags, int scope, long deprecationTime, long expirationTime)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility function for the constructors.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getFlags()", "label": "public int getFlags()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the flags of this {@code LinkAddress}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getScope()", "label": "public int getScope()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the scope of this {@code LinkAddress}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setLinkAddresses(@NonNull Collection\u003cLinkAddress\u003e addresses)", "label": "public void setLinkAddresses(@NonNull Collection\u003cLinkAddress\u003e addresses)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the {@link LinkAddress} in this {@code LinkProperties} with\\n     * the given {@link Collection} of {@link LinkAddress}.\\n     *\\n     * @param addresses The {@link Collection} of {@link LinkAddress} to set in this\\n     *                  object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.Collection", "label": "java.util.Collection", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void setDnsServers(@NonNull Collection\u003cInetAddress\u003e dnsServers)", "label": "public void setDnsServers(@NonNull Collection\u003cInetAddress\u003e dnsServers)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the DNS servers in this {@code LinkProperties} with\\n     * the given {@link Collection} of {@link InetAddress} objects.\\n     *\\n     * @param dnsServers The {@link Collection} of DNS servers to set in this object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cInetAddress\u003e getDnsServers()", "label": "public List\u003cInetAddress\u003e getDnsServers()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns all the {@link InetAddress} for DNS servers on this link.\\n     *\\n     * @return An unmodifiable {@link List} of {@link InetAddress} for DNS servers on\\n     *         this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isPrivateDnsActive()", "label": "public boolean isPrivateDnsActive()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether private DNS is currently in use on this network. When\\n     * private DNS is in use, applications must not send unencrypted DNS\\n     * queries as doing so could reveal private user information. Furthermore,\\n     * if private DNS is in use and {@link #getPrivateDnsServerName} is not\\n     * {@code null}, DNS queries must be sent to the specified DNS server.\\n     *\\n     * @return {@code true} if private DNS is in use, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getPrivateDnsServerName", "label": "getPrivateDnsServerName", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setDhcpServerAddress(@Nullable Inet4Address serverAddress)", "label": "public void setDhcpServerAddress(@Nullable Inet4Address serverAddress)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set DHCP server address.\\n     *\\n     * @param serverAddress the server address to set.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Inet4Address getDhcpServerAddress()", "label": "public Inet4Address getDhcpServerAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get DHCP server address\\n     *\\n     * @return The current DHCP server address.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getPrivateDnsServerName()", "label": "public String getPrivateDnsServerName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the private DNS server name that is in use. If not {@code null},\\n     * private DNS is in strict mode. In this mode, applications should ensure\\n     * that all DNS queries are encrypted and sent to this hostname and that\\n     * queries are only sent if the hostname\u0027s certificate is valid. If\\n     * {@code null} and {@link #isPrivateDnsActive} is {@code true}, private\\n     * DNS is in opportunistic mode, and applications should ensure that DNS\\n     * queries are encrypted and sent to a DNS server returned by\\n     * {@link #getDnsServers}. System DNS will handle each of these cases\\n     * correctly, but applications implementing their own DNS lookups must make\\n     * sure to follow these requirements.\\n     *\\n     * @return The private DNS server name.\\n     \"}"}, {"color": "#97c2fc", "id": "getDnsServers", "label": "getDnsServers", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isPrivateDnsActive", "label": "isPrivateDnsActive", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setDomains(@Nullable String domains)", "label": "public void setDomains(@Nullable String domains)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the DNS domain search path used on this link.\\n     *\\n     * @param domains A {@link String} listing in priority order the comma separated\\n     *                domains to search when resolving host names on this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "String", "label": "String", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public String getDomains()", "label": "public String getDomains()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the DNS domains search path set for this link. May be {@code null} if not set.\\n     *\\n     * @return A {@link String} containing the comma separated domains to search when resolving host\\n     *         names on this link or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setMtu(int mtu)", "label": "public void setMtu(int mtu)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the Maximum Transmission Unit size to use on this link.  This should not be used\\n     * unless the system default (1500) is incorrect.  Values less than 68 or greater than\\n     * 10000 will be ignored.\\n     *\\n     * @param mtu The MTU to use for this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getMtu()", "label": "public int getMtu()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets any non-default MTU size set for this link.  Note that if the default is being used\\n     * this will return 0.\\n     *\\n     * @return The mtu value set for this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean addRoute(@NonNull RouteInfo route)", "label": "public boolean addRoute(@NonNull RouteInfo route)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adds a {@link RouteInfo} to this {@code LinkProperties}, if a {@link RouteInfo}\\n     * with the same {@link RouteInfo.RouteKey} with different properties\\n     * (e.g., different MTU), it will be updated. If the {@link RouteInfo} had an\\n     * interface name set and that differs from the interface set for this\\n     * {@code LinkProperties} an {@link IllegalArgumentException} will be thrown.\\n     * The proper course is to add either un-named or properly named {@link RouteInfo}.\\n     *\\n     * @param route A {@link RouteInfo} to add to this object.\\n     * @return {@code true} was added or updated, false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "RouteInfo.RouteKey", "label": "RouteInfo.RouteKey", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public List\u003cRouteInfo\u003e getRoutes()", "label": "public List\u003cRouteInfo\u003e getRoutes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns all the {@link RouteInfo} set on this link.\\n     *\\n     * @return An unmodifiable {@link List} of {@link RouteInfo} for this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setHttpProxy(@Nullable ProxyInfo proxy)", "label": "public void setHttpProxy(@Nullable ProxyInfo proxy)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the recommended {@link ProxyInfo} to use on this link, or {@code null} for none.\\n     * Note that Http Proxies are only a hint - the system recommends their use, but it does\\n     * not enforce it and applications may ignore them.\\n     *\\n     * @param proxy A {@link ProxyInfo} defining the HTTP Proxy to use on this link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.ProxyInfo", "label": "android.net.ProxyInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \"\\n * Describes a proxy configuration.\\n *\\n * Proxy configurations are already integrated within the {@code java.net} and\\n * Apache HTTP stack. So {@link URLConnection} and Apache\u0027s {@code HttpClient} will use\\n * them automatically.\\n *\\n * Other HTTP stacks will need to obtain the proxy info from\\n * {@link Proxy#PROXY_CHANGE_ACTION} broadcast as the extra {@link Proxy#EXTRA_PROXY_INFO}.\\n \"}"}, {"color": "#97c2fc", "id": "public static ProxyInfo buildDirectProxy(String host, int port)", "label": "public static ProxyInfo buildDirectProxy(String host, int port)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a {@link ProxyInfo} object that points at a Direct proxy\\n     * on the specified host and port.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ProxyInfo buildDirectProxy(String host, int port, List\u003cString\u003e exclList)", "label": "public static ProxyInfo buildDirectProxy(String host, int port, List\u003cString\u003e exclList)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a {@link ProxyInfo} object that points at a Direct proxy\\n     * on the specified host and port.\\n     *\\n     * The proxy will not be used to access any host in exclusion list, exclList.\\n     *\\n     * @param exclList Hosts to exclude using the proxy on connections for.  These\\n     *                 hosts can use wildcards such as *.example.com.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ProxyInfo buildPacProxy(Uri pacUri)", "label": "public static ProxyInfo buildPacProxy(Uri pacUri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Construct a {@link ProxyInfo} that will download and run the PAC script\\n     * at the specified URL.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ProxyInfo buildPacProxy(@NonNull Uri pacUrl, int port)", "label": "public static ProxyInfo buildPacProxy(@NonNull Uri pacUrl, int port)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Construct a {@link ProxyInfo} object that will download and run the PAC script at the\\n     * specified URL and port.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Uri getPacFileUrl()", "label": "public Uri getPacFileUrl()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the URL of the current PAC script or null if there is\\n     * no PAC script.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getHost()", "label": "public String getHost()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * When configured to use a Direct Proxy this returns the host\\n     * of the proxy.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getPort()", "label": "public int getPort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * When configured to use a Direct Proxy this returns the port\\n     * of the proxy\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] getExclusionList()", "label": "public String[] getExclusionList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * When configured to use a Direct Proxy this returns the list\\n     * of hosts for which the proxy is ignored.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isValid()", "label": "public boolean isValid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return true if the pattern of proxy is valid, otherwise return false.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ProxyInfo getHttpProxy()", "label": "public ProxyInfo getHttpProxy()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the recommended {@link ProxyInfo} (or {@code null}) set on this link.\\n     *\\n     * @return The {@link ProxyInfo} set on this link or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public IpPrefix getNat64Prefix()", "label": "public IpPrefix getNat64Prefix()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the NAT64 prefix in use on this link, if any.\\n     *\\n     * @return the NAT64 prefix or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setNat64Prefix(@Nullable IpPrefix prefix)", "label": "public void setNat64Prefix(@Nullable IpPrefix prefix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the NAT64 prefix in use on this link.\\n     *\\n     * Currently, only 96-bit prefixes (i.e., where the 32-bit IPv4 address is at the end of the\\n     * 128-bit IPv6 address) are supported or {@code null} for no prefix.\\n     *\\n     * @param prefix the NAT64 prefix.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private boolean hasIpv4AddressOnInterface(String iface)", "label": "private boolean hasIpv4AddressOnInterface(String iface)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if this link or any of its stacked interfaces has an IPv4 address.\\n     *\\n     * @return {@code true} if there is an IPv4 address, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isWakeOnLanSupported()", "label": "public boolean isWakeOnLanSupported()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether the network interface supports WakeOnLAN\\n     *\\n     * @return {@code true} if interface supports WakeOnLAN, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLastCauseCode()", "label": "public int getLastCauseCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the cause code generated by the most recent state change.\\n     *\\n     * Return the cause code for the most recent change in {@link #getState}. In the event of an\\n     * error, this cause code will be non-zero.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getState", "label": "getState", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public ApnSetting getApnSetting()", "label": "public ApnSetting getApnSetting()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the APN Settings for this data connection.\\n     *\\n     * @return the ApnSetting that was used to configure this data connection.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onUserMobileDataStateChanged(boolean enabled)", "label": "public void onUserMobileDataStateChanged(boolean enabled)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when the user mobile data state has changed on the registered subscription.\\n     * Note, the registration subId comes from {@link TelephonyManager} object which registers\\n     * PhoneStateListener by {@link TelephonyManager#listen(PhoneStateListener, int)}.\\n     * If this TelephonyManager object was created with\\n     * {@link TelephonyManager#createForSubscriptionId(int)}, then the callback applies to the\\n     * subId. Otherwise, this callback applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @param enabled indicates whether the current user mobile data state is enabled or disabled.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onDisplayInfoChanged(@NonNull TelephonyDisplayInfo telephonyDisplayInfo)", "label": "public void onDisplayInfoChanged(@NonNull TelephonyDisplayInfo telephonyDisplayInfo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when the display info has changed on the registered subscription.\\n     * \u003cp\u003e The {@link TelephonyDisplayInfo} contains status information shown to the user based on\\n     * carrier policy.\\n     *\\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE} or that the calling\\n     * app has carrier privileges (see {@link TelephonyManager#hasCarrierPrivileges}).\\n     *\\n     * @param telephonyDisplayInfo The display information.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.TelephonyDisplayInfo", "label": "android.telephony.TelephonyDisplayInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * TelephonyDisplayInfo contains telephony-related information used for display purposes only. This\\n * information is provided in accordance with carrier policy and branding preferences; it is not\\n * necessarily a precise or accurate representation of the current state and should be treated\\n * accordingly.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getOverrideNetworkType()", "label": "public int getOverrideNetworkType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the override network type. Note the override network type is for market branding\\n     * or visualization purposes only. It cannot be treated as the actual network type device is\\n     * camped on.\\n     *\\n     * @return The override network type.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onActiveDataSubscriptionIdChanged(int subId)", "label": "public void onActiveDataSubscriptionIdChanged(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Callback invoked when active data subId changes.\\n     * Note, this callback triggers regardless of registered subscription.\\n     *\\n     * Requires the READ_PHONE_STATE permission.\\n     * @param subId current subscription used to setup Cellular Internet data.\\n     *              For example, it could be the current active opportunistic subscription in use,\\n     *              or the subscription user selected as default data subscription in DSDS mode.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void onRegistrationFailed(@NonNull CellIdentity cellIdentity, @NonNull String chosenPlmn, int domain, int causeCode, int additionalCauseCode)", "label": "public void onRegistrationFailed(@NonNull CellIdentity cellIdentity, @NonNull String chosenPlmn, int domain, int causeCode, int additionalCauseCode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Report that Registration or a Location/Routing/Tracking Area update has failed.\\n     *\\n     * \u003cp\u003eIndicate whenever a registration procedure, including a location, routing, or tracking\\n     * area update fails. This includes procedures that do not necessarily result in a change of\\n     * the modem\u0027s registration status. If the modem\u0027s registration status changes, that is\\n     * reflected in the onNetworkStateChanged() and subsequent get{Voice/Data}RegistrationState().\\n     *\\n     * \u003cp\u003eBecause registration failures are ephemeral, this callback is not sticky.\\n     * Registrants will not receive the most recent past value when registering.\\n     *\\n     * @param cellIdentity the CellIdentity, which must include the globally unique identifier\\n     *        for the cell (for example, all components of the CGI or ECGI).\\n     * @param chosenPlmn a 5 or 6 digit alphanumeric PLMN (MCC|MNC) among those broadcast by the\\n     *         cell that was chosen for the failed registration attempt.\\n     * @param domain DOMAIN_CS, DOMAIN_PS or both in case of a combined procedure.\\n     * @param causeCode the primary failure cause code of the procedure.\\n     *        For GSM/UMTS (MM), values are in TS 24.008 Sec 10.5.95\\n     *        For GSM/UMTS (GMM), values are in TS 24.008 Sec 10.5.147\\n     *        For LTE (EMM), cause codes are TS 24.301 Sec 9.9.3.9\\n     *        For NR (5GMM), cause codes are TS 24.501 Sec 9.11.3.2\\n     *        Integer.MAX_VALUE if this value is unused.\\n     * @param additionalCauseCode the cause code of any secondary/combined procedure if appropriate.\\n     *        For UMTS, if a combined attach succeeds for PS only, then the GMM cause code shall be\\n     *        included as an additionalCauseCode. For LTE (ESM), cause codes are in\\n     *        TS 24.301 9.9.4.4. Integer.MAX_VALUE if this value is unused.\\n     \"}"}, {"color": "#97c2fc", "id": "public void onBarringInfoChanged(@NonNull BarringInfo barringInfo)", "label": "public void onBarringInfoChanged(@NonNull BarringInfo barringInfo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Report updated barring information for the current camped/registered cell.\\n     *\\n     * \u003cp\u003eBarring info is provided for all services applicable to the current camped/registered\\n     * cell, for the registered PLMN and current access class/access category.\\n     *\\n     * @param barringInfo for all services on the current cell.\\n     *\\n     * @see android.telephony.BarringInfo\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getVoiceNetworkType()", "label": "public int getVoiceNetworkType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the NETWORK_TYPE_xxxx for voice\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasIccCard()", "label": "public boolean hasIccCard()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return true if a ICC card is present\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasIccCard(int slotIndex)", "label": "public boolean hasIccCard(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 FIXME Input argument slotIndex should be of type int\u0027}"}, {"color": "#97c2fc", "id": "public int getSimState()", "label": "public int getSimState()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a constant indicating the state of the default SIM card.\\n     *\\n     * @see #SIM_STATE_UNKNOWN\\n     * @see #SIM_STATE_ABSENT\\n     * @see #SIM_STATE_PIN_REQUIRED\\n     * @see #SIM_STATE_PUK_REQUIRED\\n     * @see #SIM_STATE_NETWORK_LOCKED\\n     * @see #SIM_STATE_READY\\n     * @see #SIM_STATE_NOT_READY\\n     * @see #SIM_STATE_PERM_DISABLED\\n     * @see #SIM_STATE_CARD_IO_ERROR\\n     * @see #SIM_STATE_CARD_RESTRICTED\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getSimCardStateFromSimState(int simState)", "label": "private int getSimCardStateFromSimState(int simState)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts SIM state to SIM card state.\\n     * @param simState\\n     * @return SIM card state\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getLogicalSlotIndex(int physicalSlotIndex)", "label": "private int getLogicalSlotIndex(int physicalSlotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts a physical slot index to logical slot index.\\n     * @param physicalSlotIndex physical slot index\\n     * @return logical slot index\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getSimApplicationStateFromSimState(int simState)", "label": "private int getSimApplicationStateFromSimState(int simState)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts SIM state to SIM application state.\\n     * @param simState\\n     * @return SIM application state\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSimState(int slotIndex)", "label": "public int getSimState(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a constant indicating the state of the device SIM card in a logical slot.\\n     *\\n     * @param slotIndex logical slot index\\n     *\\n     * @see #SIM_STATE_UNKNOWN\\n     * @see #SIM_STATE_ABSENT\\n     * @see #SIM_STATE_PIN_REQUIRED\\n     * @see #SIM_STATE_PUK_REQUIRED\\n     * @see #SIM_STATE_NETWORK_LOCKED\\n     * @see #SIM_STATE_READY\\n     * @see #SIM_STATE_NOT_READY\\n     * @see #SIM_STATE_PERM_DISABLED\\n     * @see #SIM_STATE_CARD_IO_ERROR\\n     * @see #SIM_STATE_CARD_RESTRICTED\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getSimOperator()", "label": "public String getSimOperator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the MCC+MNC (mobile country code + mobile network code) of the\\n     * provider of the SIM. 5 or 6 decimal digits.\\n     * \u003cp\u003e\\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\\n     *\\n     * @see #getSimState\\n     \u0027}"}, {"color": "#97c2fc", "id": "SIM_STATE_READY", "label": "SIM_STATE_READY", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getSimOperatorName()", "label": "public String getSimOperatorName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Service Provider Name (SPN).\\n     * \u003cp\u003e\\n     * Availability: SIM state must be {@link #SIM_STATE_READY}\\n     *\\n     * @see #getSimState\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getSimCountryIso()", "label": "public String getSimCountryIso()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the ISO-3166-1 alpha-2 country code equivalent for the SIM provider\u0027s country code.\\n     * \u003cp\u003e\\n     * The ISO-3166-1 alpha-2 country code is provided in lowercase 2 character format.\\n     * @return the lowercase 2 character ISO-3166-1 alpha-2 country code, or empty string is not\\n     * available.\\n     \"}"}, {"color": "#97c2fc", "id": "public String getSimSerialNumber()", "label": "public String getSimSerialNumber()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the serial number of the SIM, if applicable. Return null if it is\\n     * unavailable.\\n     *\\n     * \u003cp\u003eStarting with API level 29, persistent device identifiers are guarded behind additional\\n     * restrictions, and apps are recommended to use resettable identifiers (see \u003ca\\n     * href=\"c\"\u003e Best practices for unique identifiers\u003c/a\u003e). This method can be invoked if one of\\n     * the following requirements is met:\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\\n     *     \u003cli\u003eIf the calling app is the device or profile owner and has been granted the\\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\\n     *     owns a managed profile on the device; for more details see \u003ca\\n     *     href=\"https://developer.android.com/work/managed-profiles\"\u003eWork profiles\u003c/a\u003e.\\n     *     Profile owner access is deprecated and will be removed in a future release.\\n     *     \u003cli\u003eIf the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *     \u003cli\u003eIf the calling app is the default SMS role holder (see {@link\\n     *     RoleManager#isRoleHeld(String)}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf the calling app does not meet one of these requirements then this method will behave\\n     * as follows:\\n     *\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app has the\\n     *     READ_PHONE_STATE permission then null is returned.\u003c/li\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app does not have\\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\\n     *     higher, then a SecurityException is thrown.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCardIdForDefaultEuicc()", "label": "public int getCardIdForDefaultEuicc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the card ID of the default eUICC card. If the eUICCs have not yet been loaded, returns\\n     * {@link #UNINITIALIZED_CARD_ID}. If there is no eUICC or the device does not support card IDs\\n     * for eUICCs, returns {@link #UNSUPPORTED_CARD_ID}.\\n     *\\n     * \u003cp\u003eThe card ID is a unique identifier associated with a UICC or eUICC card. Card IDs are\\n     * unique to a device, and always refer to the same UICC or eUICC card unless the device goes\\n     * through a factory reset.\\n     *\\n     * @return card ID of the default eUICC card, if loaded.\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNINITIALIZED_CARD_ID", "label": "UNINITIALIZED_CARD_ID", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "UNSUPPORTED_CARD_ID", "label": "UNSUPPORTED_CARD_ID", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()", "label": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets information about currently inserted UICCs and eUICCs.\\n     * \u003cp\u003e\\n     * Requires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     * \u003cp\u003e\\n     * If the caller has carrier priviliges on any active subscription, then they have permission to\\n     * get simple information like the card ID ({@link UiccCardInfo#getCardId()}), whether the card\\n     * is an eUICC ({@link UiccCardInfo#isEuicc()}), and the slot index where the card is inserted\\n     * ({@link UiccCardInfo#getSlotIndex()}).\\n     * \u003cp\u003e\\n     * To get private information such as the EID ({@link UiccCardInfo#getEid()}) or ICCID\\n     * ({@link UiccCardInfo#getIccId()}), the caller must have carrier priviliges on that specific\\n     * UICC or eUICC card.\\n     * \u003cp\u003e\\n     * See {@link UiccCardInfo} for more details on the kind of information available.\\n     *\\n     * @return a list of UiccCardInfo objects, representing information on the currently inserted\\n     * UICCs and eUICCs. Each UiccCardInfo in the list will have private information filtered out if\\n     * the caller does not have adequate permissions for that card.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getSubscriberId()", "label": "public String getSubscriberId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unique subscriber ID, for example, the IMSI for a GSM phone.\\n     * Return null if it is unavailable.\\n     *\\n     * \u003cp\u003eStarting with API level 29, persistent device identifiers are guarded behind additional\\n     * restrictions, and apps are recommended to use resettable identifiers (see \u003ca\\n     * href=\"c\"\u003e Best practices for unique identifiers\u003c/a\u003e). This method can be invoked if one of\\n     * the following requirements is met:\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app has been granted the READ_PRIVILEGED_PHONE_STATE permission; this\\n     *     is a privileged permission that can only be granted to apps preloaded on the device.\\n     *     \u003cli\u003eIf the calling app is the device or profile owner and has been granted the\\n     *     {@link Manifest.permission#READ_PHONE_STATE} permission. The profile owner is an app that\\n     *     owns a managed profile on the device; for more details see \u003ca\\n     *     href=\"https://developer.android.com/work/managed-profiles\"\u003eWork profiles\u003c/a\u003e.\\n     *     Profile owner access is deprecated and will be removed in a future release.\\n     *     \u003cli\u003eIf the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *     \u003cli\u003eIf the calling app is the default SMS role holder (see {@link\\n     *     RoleManager#isRoleHeld(String)}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf the calling app does not meet one of these requirements then this method will behave\\n     * as follows:\\n     *\\n     * \u003cul\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app has the\\n     *     READ_PHONE_STATE permission then null is returned.\u003c/li\u003e\\n     *     \u003cli\u003eIf the calling app\\\u0027s target SDK is API level 28 or lower and the app does not have\\n     *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or\\n     *     higher, then a SecurityException is thrown.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getGroupIdLevel1()", "label": "public String getGroupIdLevel1()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Group Identifier Level1 for a GSM phone.\\n     * Return null if it is unavailable.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getLine1Number()", "label": "public String getLine1Number()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the phone number string for line 1, for example, the MSISDN\\n     * for a GSM phone for a particular subscription. Return null if it is unavailable.\\n     * \u003cp\u003e\\n     * The default SMS app can also use this.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     *     {@link android.Manifest.permission#READ_SMS READ_SMS},\\n     *     {@link android.Manifest.permission#READ_PHONE_NUMBERS READ_PHONE_NUMBERS},\\n     *     that the caller is the default SMS app,\\n     *     or that the caller has carrier privileges (see {@link #hasCarrierPrivileges})\\n     *     for any API level.\\n     *     {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     *     for apps targeting SDK API level 29 and below.\\n     \u0027}"}, {"color": "#97c2fc", "id": "READ_SMS", "label": "READ_SMS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "READ_PHONE_NUMBERS", "label": "READ_PHONE_NUMBERS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean setLine1NumberForDisplay(String alphaTag, String number)", "label": "public boolean setLine1NumberForDisplay(String alphaTag, String number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Set the line 1 phone number string and its alphatag for the current ICCID\\n     * for display purpose only, for example, displayed in Phone Status. It won\u0027t\\n     * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null\\n     * value.\\n     *\\n     * \u003cp\u003eRequires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param alphaTag alpha-tagging of the dailing nubmer\\n     * @param number The dialing number\\n     * @return true if the operation was executed correctly.\\n     \"}"}, {"color": "#97c2fc", "id": "public String getVoiceMailNumber()", "label": "public String getVoiceMailNumber()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the voice mail number. Return null if it is unavailable.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setVoiceMailNumber(String alphaTag, String number)", "label": "public boolean setVoiceMailNumber(String alphaTag, String number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the voice mail number.\\n     *\\n     * \u003cp\u003eRequires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param alphaTag The alpha tag to display.\\n     * @param number The voicemail number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getVisualVoicemailPackageName()", "label": "public String getVisualVoicemailPackageName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the package responsible of processing visual voicemail for the subscription ID pinned\\n     * to the TelephonyManager. Returns {@code null} when there is no package responsible for\\n     * processing visual voicemail for the subscription.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @see #createForSubscriptionId(int)\\n     * @see #createForPhoneAccountHandle(PhoneAccountHandle)\\n     * @see VisualVoicemailService\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setVisualVoicemailSmsFilterSettings(VisualVoicemailSmsFilterSettings settings)", "label": "public void setVisualVoicemailSmsFilterSettings(VisualVoicemailSmsFilterSettings settings)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the visual voicemail SMS filter settings for the subscription ID pinned\\n     * to the TelephonyManager.\\n     * When the filter is enabled, {@link\\n     * VisualVoicemailService#onSmsReceived(VisualVoicemailTask, VisualVoicemailSms)} will be\\n     * called when a SMS matching the settings is received. Caller must be the default dialer,\\n     * system dialer, or carrier visual voicemail app.\\n     *\\n     * @param settings The settings for the filter, or {@code null} to disable the filter.\\n     *\\n     * @see TelecomManager#getDefaultDialerPackage()\\n     * @see CarrierConfigManager#KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY\\n     \u0027}"}, {"color": "#97c2fc", "id": "onSmsReceived(VisualVoicemailTask", "label": "onSmsReceived(VisualVoicemailTask", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)", "label": "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Send a visual voicemail SMS. The caller must be the current default dialer.\\n     * A {@link VisualVoicemailService} uses this method to send a command via SMS to the carrier\u0027s\\n     * visual voicemail server.  Some examples for carriers using the OMTP standard include\\n     * activating and deactivating visual voicemail, or requesting the current visual voicemail\\n     * provisioning status.  See the OMTP Visual Voicemail specification for more information on the\\n     * format of these SMS messages.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#SEND_SMS SEND_SMS}\\n     *\\n     * @param number The destination number.\\n     * @param port The destination port for data SMS, or 0 for text SMS.\\n     * @param text The message content. For data sms, it will be encoded as a UTF-8 byte stream.\\n     * @param sentIntent The sent intent passed to the {@link SmsManager}\\n     *\\n     * @throws SecurityException if the caller is not the current default dialer\\n     *\\n     * @see SmsManager#sendDataMessage(String, String, short, byte[], PendingIntent, PendingIntent)\\n     * @see SmsManager#sendTextMessage(String, String, String, PendingIntent, PendingIntent)\\n     \"}"}, {"color": "#97c2fc", "id": "android.telephony.SmsManager", "label": "android.telephony.SmsManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Manages SMS operations such as sending data, text, and pdu SMS messages.\\n * Get this object by calling the static method {@link #getDefault()}. To create an instance of\\n * {@link SmsManager} associated with a specific subscription ID, call\\n * {@link #getSmsManagerForSubscriptionId(int)}. This is typically used for devices that support\\n * multiple active subscriptions at once.\\n *\\n * \u003cp\u003eFor information about how to behave as the default SMS app on Android 4.4 (API level 19)\\n * and higher, see {@link android.provider.Telephony}.\\n *\\n * @see SubscriptionManager#getActiveSubscriptionInfoList()\\n \u0027}"}, {"color": "#97c2fc", "id": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "label": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a text based SMS.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Using this method requires that your app has the\\n     * {@link android.Manifest.permission#SEND_SMS} permission.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Beginning with Android 4.4 (API level 19), if\\n     * \u003cem\u003eand only if\u003c/em\u003e an app is not selected as the default SMS app, the system automatically\\n     * writes messages sent using this method to the SMS Provider (the default SMS app is always\\n     * responsible for writing its sent messages to the SMS Provider). For information about\\n     * how to behave as the default SMS app, see {@link android.provider.Telephony}.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If {@link #getDefault()} is used to instantiate this\\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\\n     * non-null, then the {@link PendingIntent} will be sent with an error code\\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\\n     * where this operation may fail.\\n     * \u003c/p\u003e\\n     *\\n     *\\n     * @param destinationAddress the address to send the message to\\n     * @param scAddress is the service center address or null to use\\n     *  the current default SMSC\\n     * @param text the body of the message to send\\n     * @param sentIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is successfully sent, or failed.\\n     *  The result code will be \u003ccode\u003eActivity.RESULT_OK\u003c/code\u003e for success,\\n     *  or one of these errors:\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_GENERIC_FAILURE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_RADIO_OFF\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NULL_PDU\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NO_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NO_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_LIMIT_EXCEEDED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_FDN_CHECK_FAILURE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_SHORT_CODE_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_SHORT_CODE_NEVER_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RADIO_NOT_AVAILABLE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NETWORK_REJECT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_ARGUMENTS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_MEMORY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_SMS_FORMAT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SYSTEM_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_MODEM_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NETWORK_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ENCODING_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_SMSC_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_OPERATION_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INTERNAL_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_RESOURCES\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_CANCELLED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_REQUEST_NOT_SUPPORTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_BLUETOOTH_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_BLUETOOTH_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_BLUETOOTH_DISCONNECTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_UNEXPECTED_EVENT_STOP_SENDING\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SMS_BLOCKED_DURING_EMERGENCY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SMS_SEND_RETRY_FAILED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_REMOTE_EXCEPTION\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_DEFAULT_SMS_APP\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_RADIO_NOT_AVAILABLE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SMS_SEND_FAIL_RETRY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_REJECT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_ARGUMENTS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NO_MEMORY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_REQUEST_RATE_LIMITED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_SMS_FORMAT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SYSTEM_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_ENCODING_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_SMSC_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_MODEM_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INTERNAL_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_REQUEST_NOT_SUPPORTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_MODEM_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_NOT_READY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_OPERATION_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NO_RESOURCES\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_CANCELLED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SIM_ABSENT\u003c/code\u003e\u003cbr\u003e\\n     *  For \u003ccode\u003eRESULT_ERROR_GENERIC_FAILURE\u003c/code\u003e or any of the RESULT_RIL errors,\\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\\n     *  value, generally only useful for troubleshooting.\u003cbr\u003e\\n     *  The per-application based SMS control checks sentIntent. If sentIntent\\n     *  is NULL the caller will be checked against all unknown applications,\\n     *  which cause smaller number of SMS to be sent in checking period.\\n     * @param deliveryIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is delivered to the recipient.  The\\n     *  raw pdu of the status report is in the extended data (\"pdu\").\\n     *\\n     * @throws IllegalArgumentException if destinationAddress or text are empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.provider.Telephony", "label": "android.provider.Telephony", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The Telephony provider contains data related to phone operation, specifically SMS and MMS\\n * messages, access to the APN list, including the MMSC to use, and the service state.\\n *\\n * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e These APIs are not available on all Android-powered\\n * devices. If your app depends on telephony features such as for managing SMS messages, include\\n * a \u003ca href=\"{@docRoot}guide/topics/manifest/uses-feature-element.html\"\u003e{@code \u003cuses-feature\u003e}\\n * \u003c/a\u003e element in your manifest that declares the {@code \"android.hardware.telephony\"} hardware\\n * feature. Alternatively, you can check for telephony availability at runtime using either\\n * {@link android.content.pm.PackageManager#hasSystemFeature\\n * hasSystemFeature(PackageManager.FEATURE_TELEPHONY)} or {@link\\n * android.telephony.TelephonyManager#getPhoneType}.\u003c/p\u003e\\n *\\n * \u003ch3\u003eCreating an SMS app\u003c/h3\u003e\\n *\\n * \u003cp\u003eOnly the default SMS app (selected by the user in system settings) is able to write to the\\n * SMS Provider (the tables defined within the {@code Telephony} class) and only the default SMS\\n * app receives the {@link android.provider.Telephony.Sms.Intents#SMS_DELIVER_ACTION} broadcast\\n * when the user receives an SMS or the {@link\\n * android.provider.Telephony.Sms.Intents#WAP_PUSH_DELIVER_ACTION} broadcast when the user\\n * receives an MMS.\u003c/p\u003e\\n *\\n * \u003cp\u003eAny app that wants to behave as the user\\\u0027s default SMS app must handle the following intents:\\n * \u003cul\u003e\\n * \u003cli\u003eIn a broadcast receiver, include an intent filter for {@link Sms.Intents#SMS_DELIVER_ACTION}\\n * (\u003ccode\u003e\"android.provider.Telephony.SMS_DELIVER\"\u003c/code\u003e). The broadcast receiver must also\\n * require the {@link android.Manifest.permission#BROADCAST_SMS} permission.\\n * \u003cp\u003eThis allows your app to directly receive incoming SMS messages.\u003c/p\u003e\u003c/li\u003e\\n * \u003cli\u003eIn a broadcast receiver, include an intent filter for {@link\\n * Sms.Intents#WAP_PUSH_DELIVER_ACTION}} ({@code \"android.provider.Telephony.WAP_PUSH_DELIVER\"})\\n * with the MIME type \u003ccode\u003e\"application/vnd.wap.mms-message\"\u003c/code\u003e.\\n * The broadcast receiver must also require the {@link\\n * android.Manifest.permission#BROADCAST_WAP_PUSH} permission.\\n * \u003cp\u003eThis allows your app to directly receive incoming MMS messages.\u003c/p\u003e\u003c/li\u003e\\n * \u003cli\u003eIn your activity that delivers new messages, include an intent filter for\\n * {@link android.content.Intent#ACTION_SENDTO} (\u003ccode\u003e\"android.intent.action.SENDTO\"\\n * \u003c/code\u003e) with schemas, \u003ccode\u003esms:\u003c/code\u003e, \u003ccode\u003esmsto:\u003c/code\u003e, \u003ccode\u003emms:\u003c/code\u003e, and\\n * \u003ccode\u003emmsto:\u003c/code\u003e.\\n * \u003cp\u003eThis allows your app to receive intents from other apps that want to deliver a\\n * message.\u003c/p\u003e\u003c/li\u003e\\n * \u003cli\u003eIn a service, include an intent filter for {@link\\n * android.telephony.TelephonyManager#ACTION_RESPOND_VIA_MESSAGE}\\n * (\u003ccode\u003e\"android.intent.action.RESPOND_VIA_MESSAGE\"\u003c/code\u003e) with schemas,\\n * \u003ccode\u003esms:\u003c/code\u003e, \u003ccode\u003esmsto:\u003c/code\u003e, \u003ccode\u003emms:\u003c/code\u003e, and \u003ccode\u003emmsto:\u003c/code\u003e.\\n * This service must also require the {@link\\n * android.Manifest.permission#SEND_RESPOND_VIA_MESSAGE} permission.\\n * \u003cp\u003eThis allows users to respond to incoming phone calls with an immediate text message\\n * using your app.\u003c/p\u003e\u003c/li\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eOther apps that are not selected as the default SMS app can only \u003cem\u003eread\u003c/em\u003e the SMS\\n * Provider, but may also be notified when a new SMS arrives by listening for the {@link\\n * Sms.Intents#SMS_RECEIVED_ACTION}\\n * broadcast, which is a non-abortable broadcast that may be delivered to multiple apps. This\\n * broadcast is intended for apps that\u0026mdash;while not selected as the default SMS app\u0026mdash;need to\\n * read special incoming messages such as to perform phone number verification.\u003c/p\u003e\\n *\\n * \u003cp\u003eFor more information about building SMS apps, read the blog post, \u003ca\\n * href=\"http://android-developers.blogspot.com/2013/10/getting-your-sms-apps-ready-for-kitkat.html\"\\n * \u003eGetting Your SMS Apps Ready for KitKat\u003c/a\u003e.\u003c/p\u003e\\n *\\n \u0027}"}, {"color": "#97c2fc", "id": "getDefault()", "label": "getDefault()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "SEND_SMS", "label": "SEND_SMS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.app.PendingIntent", "label": "android.app.PendingIntent", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \" the problem, but it doesn\u0027t seem like it\u0027s currently needed.\"}"}, {"color": "#97c2fc", "id": "public void create()", "label": "public void create()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Benchmark time to create a PendingIntent.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void createWithCancelFlag()", "label": "public void createWithCancelFlag()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Benchmark time to create a PendingIntent with FLAG_CANCEL_CURRENT, already having an active\\n     * PendingIntent.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void createWithUpdateFlag()", "label": "public void createWithUpdateFlag()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Benchmark time to create a PendingIntent with FLAG_UPDATE_CURRENT, already having an active\\n     * PendingIntent.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void cancel()", "label": "public void cancel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Benchmark time to cancel a PendingIntent.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId)", "label": "public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a text based SMS. Same as {@link #sendTextMessage( String destinationAddress,\\n     * String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)}, but\\n     * adds an optional messageId.\\n     * @param messageId An id that uniquely identifies the message requested to be sent.\\n     * Used for logging and diagnostics purposes. The id may be 0.\\n     *\\n     * @throws IllegalArgumentException if destinationAddress or text are empty\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "sendTextMessage(", "label": "sendTextMessage(", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "label": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a text based SMS without writing it into the SMS Provider.\\n     *\\n     * \u003cp\u003e\\n     * The message will be sent directly over the network and will not be visible in SMS\\n     * applications. Intended for internal carrier use only.\\n     * \u003c/p\u003e\\n     *\\n     * \u003cp\u003eRequires Permission: Both {@link android.Manifest.permission#SEND_SMS} and\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE}, or that the calling app has carrier\\n     * privileges (see {@link TelephonyManager#hasCarrierPrivileges}), or that the calling app is\\n     * the default IMS app (see\\n     * {@link CarrierConfigManager#KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING}).\\n     * \u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method is intended for internal use by carrier\\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the SMS being sent on the subscription associated with logical\\n     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the\\n     * correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @see #sendTextMessage(String, String, String, PendingIntent, PendingIntent)\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSmsManagerForSubscriptionId(int)", "label": "getSmsManagerForSubscriptionId(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "label": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     *\\n     * Inject an SMS PDU into the android application framework.\\n     *\\n     * \u003cp\u003eRequires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE} or carrier\\n     * privileges per {@link android.telephony.TelephonyManager#hasCarrierPrivileges}.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method is intended for internal use by carrier\\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the SMS being injected on the subscription associated with\\n     * logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is\\n     * delivered to the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param pdu is the byte array of pdu to be injected into android application framework\\n     * @param format is the format of SMS pdu ({@link SmsMessage#FORMAT_3GPP} or\\n     *  {@link SmsMessage#FORMAT_3GPP2})\\n     * @param receivedIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is successfully received by the\\n     *  android application framework, or failed. This intent is broadcasted at\\n     *  the same time an SMS received from radio is acknowledged back.\\n     *  The result code will be {@link android.provider.Telephony.Sms.Intents#RESULT_SMS_HANDLED}\\n     *  for success, or {@link android.provider.Telephony.Sms.Intents#RESULT_SMS_GENERIC_ERROR} or\\n     *  {@link #RESULT_REMOTE_EXCEPTION} for error.\\n     *\\n     * @throws IllegalArgumentException if the format is invalid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "RESULT_SMS_GENERIC_ERROR", "label": "RESULT_SMS_GENERIC_ERROR", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "FORMAT_3GPP2", "label": "FORMAT_3GPP2", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.SmsMessage", "label": "android.telephony.SmsMessage", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A Short Message Service message.\\n * @see android.provider.Telephony.Sms.Intents#getMessagesFromIntent\\n \u0027}"}, {"color": "#97c2fc", "id": "public static SmsMessage createFromPdu(byte[] pdu, String format)", "label": "public static SmsMessage createFromPdu(byte[] pdu, String format)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create an SmsMessage from a raw PDU with the specified message format. The\\n     * message format is passed in the\\n     * {@link android.provider.Telephony.Sms.Intents#SMS_RECEIVED_ACTION} as the {@code format}\\n     * String extra, and will be either \"3gpp\" for GSM/UMTS/LTE messages in 3GPP format\\n     * or \"3gpp2\" for CDMA/LTE messages in 3GPP2 format.\\n     *\\n     * @param pdu the message PDU from the\\n     * {@link android.provider.Telephony.Sms.Intents#SMS_RECEIVED_ACTION} intent\\n     * @param format the format extra from the\\n     * {@link android.provider.Telephony.Sms.Intents#SMS_RECEIVED_ACTION} intent\\n     \u0027}"}, {"color": "#97c2fc", "id": "SMS_RECEIVED_ACTION", "label": "SMS_RECEIVED_ACTION", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int getTPLayerLengthForPDU(String pdu)", "label": "public static int getTPLayerLengthForPDU(String pdu)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Get the TP-Layer-Length for the given SMS-SUBMIT PDU Basically, the\\n     * length in bytes (not hex chars) less the SMSC header\\n     *\\n     * FIXME: This method is only used by a CTS test case that isn\u0027t run on CDMA devices.\\n     * We should probably deprecate it and remove the obsolete test case.\\n     \"}"}, {"color": "#97c2fc", "id": "public static int[] calculateLength(CharSequence msgBody, boolean use7bitOnly)", "label": "public static int[] calculateLength(CharSequence msgBody, boolean use7bitOnly)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Calculates the number of SMS\u0027s required to encode the message body and the number of\\n     * characters remaining until the next message.\\n     *\\n     * @param msgBody the message to encode\\n     * @param use7bitOnly if true, characters that are not part of the radio-specific 7-bit encoding\\n     *     are counted as single space chars. If false, and if the messageBody contains non-7-bit\\n     *     encodable characters, length is calculated using a 16-bit encoding.\\n     * @return an int[6] with int[0] being the number of SMS\u0027s required, int[1] the number of code\\n     *     units used, and int[2] is the number of code units remaining until the next message.\\n     *     int[3] is an indicator of the encoding code unit size (see the ENCODING_* definitions in\\n     *     SmsConstants). int[4] is the GSM national language table to use, or 0 for the default\\n     *     7-bit alphabet. int[5] The GSM national language shift table to use, or 0 for the default\\n     *     7-bit extension table.\\n     \"}"}, {"color": "#97c2fc", "id": "public static int[] calculateLength(String messageBody, boolean use7bitOnly)", "label": "public static int[] calculateLength(String messageBody, boolean use7bitOnly)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Calculates the number of SMS\u0027s required to encode the message body and the number of\\n     * characters remaining until the next message, given the current encoding.\\n     *\\n     * @param messageBody the message to encode\\n     * @param use7bitOnly if true, characters that are not part of the radio specific (GSM / CDMA)\\n     *     alphabet encoding are converted to as a single space characters. If false, a messageBody\\n     *     containing non-GSM or non-CDMA alphabet characters are encoded using 16-bit encoding.\\n     * @return an int[4] with int[0] being the number of SMS\u0027s required, int[1] the number of code\\n     *     units used, and int[2] is the number of code units remaining until the next message.\\n     *     int[3] is the encoding type that should be used for the message.\\n     \"}"}, {"color": "#97c2fc", "id": "public static SubmitPdu getSubmitPdu(String scAddress, String destinationAddress, String message, boolean statusReportRequested)", "label": "public static SubmitPdu getSubmitPdu(String scAddress, String destinationAddress, String message, boolean statusReportRequested)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets an SMS-SUBMIT PDU for a destination address and a message.\\n     * This method will not attempt to use any GSM national language 7 bit encodings.\\n     *\\n     * @param scAddress Service Centre address. Null means use default.\\n     * @param destinationAddress the address of the destination for the message.\\n     * @param message string representation of the message payload.\\n     * @param statusReportRequested indicates whether a report is requested for this message.\\n     * @return a \u003ccode\u003eSubmitPdu\u003c/code\u003e containing the encoded SC address if applicable and the\\n     *         encoded message. Returns null on encode error.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static SubmitPdu getSubmitPdu(String scAddress, String destinationAddress, short destinationPort, byte[] data, boolean statusReportRequested)", "label": "public static SubmitPdu getSubmitPdu(String scAddress, String destinationAddress, short destinationPort, byte[] data, boolean statusReportRequested)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets an SMS-SUBMIT PDU for a data message to a destination address \u0026amp; port.\\n     * This method will not attempt to use any GSM national language 7 bit encodings.\\n     *\\n     * @param scAddress Service Centre address. Null means use default.\\n     * @param destinationAddress the address of the destination for the message.\\n     * @param destinationPort the port to deliver the message to at the destination.\\n     * @param data the data for the message.\\n     * @param statusReportRequested indicates whether a report is requested for this message.\\n     * @return a \u003ccode\u003eSubmitPdu\u003c/code\u003e containing the encoded SC address if applicable and the\\n     *         encoded message. Returns null on encode error.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getServiceCenterAddress()", "label": "public String getServiceCenterAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the address of the SMS service center that relayed this message\\n     * or null if there is none.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getOriginatingAddress()", "label": "public String getOriginatingAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the originating address (sender) of this SMS message in String\\n     * form or null if unavailable.\\n     *\\n     * \u003cp\u003eIf the address is a GSM-formatted address, it will be in a format specified by 3GPP\\n     * 23.040 Sec 9.1.2.5. If it is a CDMA address, it will be a format specified by 3GPP2\\n     * C.S005-D Table 2.7.1.3.2.4-2. The choice of format is carrier-specific, so callers of the\\n     * should be careful to avoid assumptions about the returned content.\\n     *\\n     * @return a String representation of the address; null if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getDisplayOriginatingAddress()", "label": "public String getDisplayOriginatingAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the originating address, or email from address if this message\\n     * was from an email gateway. Returns null if originating address\\n     * unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMessageBody()", "label": "public String getMessageBody()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the message body as a String, if it exists and is text based.\\n     * @return message body if there is one, otherwise null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public MessageClass getMessageClass()", "label": "public MessageClass getMessageClass()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the class of this message.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getDisplayMessageBody()", "label": "public String getDisplayMessageBody()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the message body, or email message body if this message was from\\n     * an email gateway. Returns null if message body unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getPseudoSubject()", "label": "public String getPseudoSubject()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unofficial convention of a subject line enclosed in parens empty string\\n     * if not present\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getTimestampMillis()", "label": "public long getTimestampMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the service centre timestamp in currentTimeMillis() format\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isEmail()", "label": "public boolean isEmail()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if message is an email.\\n     *\\n     * @return true if this message came through an email gateway and email\\n     *         sender / subject / parsed body are available\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getEmailBody()", "label": "public String getEmailBody()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return if isEmail() is true, body of the email sent through the gateway.\\n     *         null otherwise\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getEmailFrom()", "label": "public String getEmailFrom()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return if isEmail() is true, email from address of email sent through\\n     *         the gateway. null otherwise\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getProtocolIdentifier()", "label": "public int getProtocolIdentifier()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get protocol identifier.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isReplace()", "label": "public boolean isReplace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * See TS 23.040 9.2.3.9 returns true if this is a \"replace short message\"\\n     * SMS\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isCphsMwiMessage()", "label": "public boolean isCphsMwiMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true for CPHS MWI toggle message.\\n     *\\n     * @return true if this is a CPHS MWI toggle message See CPHS 4.2 section\\n     *         B.4.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMWIClearMessage()", "label": "public boolean isMWIClearMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * returns true if this message is a CPHS voicemail / message waiting\\n     * indicator (MWI) clear message\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMWISetMessage()", "label": "public boolean isMWISetMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * returns true if this message is a CPHS voicemail / message waiting\\n     * indicator (MWI) set message\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMwiDontStore()", "label": "public boolean isMwiDontStore()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * returns true if this message is a \"Message Waiting Indication Group:\\n     * Discard Message\" notification and should not be stored.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getUserData()", "label": "public byte[] getUserData()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * returns the user data section minus the user data header if one was\\n     * present.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getPdu()", "label": "public byte[] getPdu()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the raw PDU for the message.\\n     *\\n     * @return the raw PDU for the message.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getStatusOnIcc()", "label": "public int getStatusOnIcc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the status of the message on the ICC (read, unread, sent, unsent).\\n     *\\n     * @return the status of the message on the ICC.  These are:\\n     *         SmsManager.STATUS_ON_ICC_FREE\\n     *         SmsManager.STATUS_ON_ICC_READ\\n     *         SmsManager.STATUS_ON_ICC_UNREAD\\n     *         SmsManager.STATUS_ON_ICC_SEND\\n     *         SmsManager.STATUS_ON_ICC_UNSENT\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getIndexOnIcc()", "label": "public int getIndexOnIcc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the record index of the message on the ICC (1-based index).\\n     * @return the record index of the message on the ICC, or -1 if this\\n     *         SmsMessage was not created from a ICC SMS EF record.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getStatus()", "label": "public int getStatus()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * GSM: For an SMS-STATUS-REPORT message, this returns the status field from the status report.\\n     * This field indicates the status of a previously submitted SMS, if requested.\\n     * See TS 23.040, 9.2.3.15 TP-Status for a description of values.\\n     * CDMA: For not interfering with status codes from GSM, the value is shifted to the bits 31-16.\\n     * The value is composed of an error class (bits 25-24) and a status code (bits 23-16). Possible\\n     * codes are described in C.S0015-B, v2.0, 4.5.21.\\n     *\\n     * @return 0 for GSM or 2 shifted left by 16 for CDMA indicates the previously sent message was\\n     *         received. See TS 23.040, 9.2.3.15 and C.S0015-B, v2.0, 4.5.21 for a description of\\n     *         other possible values.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isStatusReportMessage()", "label": "public boolean isStatusReportMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return true iff the message is a SMS-STATUS-REPORT message.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isReplyPathPresent()", "label": "public boolean isReplyPathPresent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true iff the \u003ccode\u003eTP-Reply-Path\u003c/code\u003e bit is set in\\n     * this message.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean useCdmaFormatForMoSms()", "label": "private static boolean useCdmaFormatForMoSms()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether or not to use CDMA format for MO SMS.\\n     * If SMS over IMS is supported, then format is based on IMS SMS format,\\n     * otherwise format is based on current phone type.\\n     *\\n     * @return true if Cdma format should be used for MO SMS, false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean useCdmaFormatForMoSms(int subId)", "label": "private static boolean useCdmaFormatForMoSms(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether or not to use CDMA format for MO SMS.\\n     * If SMS over IMS is supported, then format is based on IMS SMS format,\\n     * otherwise format is based on current phone type.\\n     *\\n     * @param subId Subscription for which phone type is returned.\\n     *\\n     * @return true if Cdma format should be used for MO SMS, false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean isCdmaVoice()", "label": "private static boolean isCdmaVoice()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether or not to current phone type is cdma.\\n     *\\n     * @return true if current phone type is cdma, false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean isCdmaVoice(int subId)", "label": "private static boolean isCdmaVoice(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n      * Determines whether or not to current phone type is cdma\\n      *\\n      * @return true if current phone type is cdma, false otherwise.\\n      \u0027}"}, {"color": "#97c2fc", "id": "RESULT_SMS_HANDLED", "label": "RESULT_SMS_HANDLED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "RESULT_REMOTE_EXCEPTION", "label": "RESULT_REMOTE_EXCEPTION", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public ArrayList\u003cString\u003e divideMessage(String text)", "label": "public ArrayList\u003cString\u003e divideMessage(String text)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Divide a message text into several fragments, none bigger than the maximum SMS message size.\\n     *\\n     * @param text the original message. Must not be null.\\n     * @return an \u003ccode\u003eArrayList\u003c/code\u003e of strings that, in order, comprise the original message.\\n     * @throws IllegalArgumentException if text is null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)", "label": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a multi-part text based SMS.  The callee should have already\\n     * divided the message into correctly sized parts by calling\\n     * \u003ccode\u003edivideMessage\u003c/code\u003e.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Using this method requires that your app has the\\n     * {@link android.Manifest.permission#SEND_SMS} permission.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Beginning with Android 4.4 (API level 19), if\\n     * \u003cem\u003eand only if\u003c/em\u003e an app is not selected as the default SMS app, the system automatically\\n     * writes messages sent using this method to the SMS Provider (the default SMS app is always\\n     * responsible for writing its sent messages to the SMS Provider). For information about\\n     * how to behave as the default SMS app, see {@link android.provider.Telephony}.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If {@link #getDefault()} is used to instantiate this\\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\\n     * non-null, then the {@link PendingIntent} will be sent with an error code\\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\\n     * where this operation may fail.\\n     * \u003c/p\u003e\\n     *\\n     *\\n     * @param destinationAddress the address to send the message to\\n     * @param scAddress is the service center address or null to use\\n     *   the current default SMSC\\n     * @param parts an \u003ccode\u003eArrayList\u003c/code\u003e of strings that, in order,\\n     *   comprise the original message\\n     * @param sentIntents if not null, an \u003ccode\u003eArrayList\u003c/code\u003e of\\n     *   \u003ccode\u003ePendingIntent\u003c/code\u003es (one for each message part) that is\\n     *   broadcast when the corresponding message part has been sent.\\n     *   The result code will be \u003ccode\u003eActivity.RESULT_OK\u003c/code\u003e for success,\\n     *   or one of these errors:\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_GENERIC_FAILURE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_RADIO_OFF\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NULL_PDU\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NO_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NO_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_LIMIT_EXCEEDED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_FDN_CHECK_FAILURE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_SHORT_CODE_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_SHORT_CODE_NEVER_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RADIO_NOT_AVAILABLE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NETWORK_REJECT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_ARGUMENTS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_MEMORY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_SMS_FORMAT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SYSTEM_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_MODEM_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NETWORK_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ENCODING_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_SMSC_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_OPERATION_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INTERNAL_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_RESOURCES\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_CANCELLED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_REQUEST_NOT_SUPPORTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_BLUETOOTH_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_BLUETOOTH_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_BLUETOOTH_DISCONNECTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_UNEXPECTED_EVENT_STOP_SENDING\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SMS_BLOCKED_DURING_EMERGENCY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SMS_SEND_RETRY_FAILED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_REMOTE_EXCEPTION\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_DEFAULT_SMS_APP\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_RADIO_NOT_AVAILABLE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SMS_SEND_FAIL_RETRY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_REJECT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_ARGUMENTS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NO_MEMORY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_REQUEST_RATE_LIMITED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_SMS_FORMAT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SYSTEM_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_ENCODING_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_SMSC_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_MODEM_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INTERNAL_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_REQUEST_NOT_SUPPORTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_MODEM_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_NOT_READY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_OPERATION_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NO_RESOURCES\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_CANCELLED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SIM_ABSENT\u003c/code\u003e\u003cbr\u003e\\n     *  For \u003ccode\u003eRESULT_ERROR_GENERIC_FAILURE\u003c/code\u003e or any of the RESULT_RIL errors,\\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\\n     *  value, generally only useful for troubleshooting.\u003cbr\u003e\\n     *   The per-application based SMS control checks sentIntent. If sentIntent\\n     *   is NULL the caller will be checked against all unknown applications,\\n     *   which cause smaller number of SMS to be sent in checking period.\\n     * @param deliveryIntents if not null, an \u003ccode\u003eArrayList\u003c/code\u003e of\\n     *   \u003ccode\u003ePendingIntent\u003c/code\u003es (one for each message part) that is\\n     *   broadcast when the corresponding message part has been delivered\\n     *   to the recipient.  The raw pdu of the status report is in the\\n     *   extended data (\"pdu\").\\n     *\\n     * @throws IllegalArgumentException if destinationAddress or data are empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, long messageId)", "label": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, long messageId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a multi-part text based SMS. Same as #sendMultipartTextMessage(String, String,\\n     * ArrayList, ArrayList, ArrayList), but adds an optional messageId.\\n     * @param messageId An id that uniquely identifies the message requested to be sent.\\n     * Used for logging and diagnostics purposes. The id may be 0.\\n     *\\n     * @throws IllegalArgumentException if destinationAddress or data are empty\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)", "label": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Similar method as #sendMultipartTextMessage(String, String, ArrayList, ArrayList, ArrayList)\\n     * With an additional argument.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method is intended for internal use the Telephony\\n     * framework and will never trigger an SMS disambiguation dialog. If this method is called on a\\n     * device that has multiple active subscriptions, this {@link SmsManager} instance has been\\n     * created with {@link #getDefault()}, and no user-defined default subscription is defined, the\\n     * subscription ID associated with this message will be INVALID, which will result in the SMS\\n     * being sent on the subscription associated with logical slot 0. Use\\n     * {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the correct\\n     * subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param packageName serves as the default package name if the package name that is\\n     *        associated with the user id is null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)", "label": "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a data based SMS to a specific application port.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Using this method requires that your app has the\\n     * {@link android.Manifest.permission#SEND_SMS} permission.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If {@link #getDefault()} is used to instantiate this\\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\\n     * non-null, then the {@link PendingIntent} will be sent with an error code\\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\\n     * where this operation may fail.\\n     * \u003c/p\u003e\\n     *\\n     * @param destinationAddress the address to send the message to\\n     * @param scAddress is the service center address or null to use\\n     *  the current default SMSC\\n     * @param destinationPort the port to deliver the message to\\n     * @param data the body of the message to send\\n     * @param sentIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is successfully sent, or failed.\\n     *  The result code will be \u003ccode\u003eActivity.RESULT_OK\u003c/code\u003e for success,\\n     *  or one of these errors:\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_GENERIC_FAILURE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_RADIO_OFF\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NULL_PDU\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NO_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_NO_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_LIMIT_EXCEEDED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_FDN_CHECK_FAILURE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_SHORT_CODE_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ERROR_SHORT_CODE_NEVER_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RADIO_NOT_AVAILABLE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NETWORK_REJECT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_ARGUMENTS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_MEMORY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_SMS_FORMAT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SYSTEM_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_MODEM_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NETWORK_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_ENCODING_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_SMSC_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_OPERATION_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INTERNAL_ERROR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_RESOURCES\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_CANCELLED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_REQUEST_NOT_SUPPORTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_BLUETOOTH_SERVICE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_INVALID_BLUETOOTH_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_BLUETOOTH_DISCONNECTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_UNEXPECTED_EVENT_STOP_SENDING\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SMS_BLOCKED_DURING_EMERGENCY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_SMS_SEND_RETRY_FAILED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_REMOTE_EXCEPTION\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_NO_DEFAULT_SMS_APP\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_RADIO_NOT_AVAILABLE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SMS_SEND_FAIL_RETRY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_REJECT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_ARGUMENTS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NO_MEMORY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_REQUEST_RATE_LIMITED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_SMS_FORMAT\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SYSTEM_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_ENCODING_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_SMSC_ADDRESS\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_MODEM_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INTERNAL_ERR\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_REQUEST_NOT_SUPPORTED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_INVALID_MODEM_STATE\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NETWORK_NOT_READY\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_OPERATION_NOT_ALLOWED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_NO_RESOURCES\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_CANCELLED\u003c/code\u003e\u003cbr\u003e\\n     *  \u003ccode\u003eRESULT_RIL_SIM_ABSENT\u003c/code\u003e\u003cbr\u003e\\n     *  For \u003ccode\u003eRESULT_ERROR_GENERIC_FAILURE\u003c/code\u003e or any of the RESULT_RIL errors,\\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\\n     *  value, generally only useful for troubleshooting.\u003cbr\u003e\\n     *  The per-application based SMS control checks sentIntent. If sentIntent\\n     *  is NULL the caller will be checked against all unknown applications,\\n     *  which cause smaller number of SMS to be sent in checking period.\\n     * @param deliveryIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is delivered to the recipient.  The\\n     *  raw pdu of the status report is in the extended data (\"pdu\").\\n     *\\n     * @throws IllegalArgumentException if destinationAddress or data are empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static SmsManager getDefault()", "label": "public static SmsManager getDefault()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the SmsManager associated with the default subscription id. The instance will always be\\n     * associated with the default subscription id, even if the default subscription id changes.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For devices that support multiple active subscriptions\\n     * at a time, SmsManager will track the subscription set by the user as the default SMS\\n     * subscription. If the user has not set a default, {@link SmsManager} may\\n     * start an activity to kick off a subscription disambiguation dialog. Most operations will not\\n     * complete until the user has chosen the subscription that will be associated with the\\n     * operation. If the user cancels the dialog without choosing a subscription, one of the\\n     * following will happen, depending on the target SDK version of the application. For\\n     * compatibility purposes, if the target SDK level is \u003c= 28, telephony will still send the SMS\\n     * over the first available subscription. If the target SDK level is \u003e 28, the operation will\\n     * fail to complete.\\n     * \u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If this method is used to perform an operation on a\\n     * device that has multiple active subscriptions, the user has not set a default SMS\\n     * subscription, and the operation is being performed while the application is not in the\\n     * foreground, the SMS disambiguation dialog will not be shown. The result of the operation will\\n     * conclude as if the user cancelled the disambiguation dialog and the operation will finish as\\n     * outlined above, depending on the target SDK version of the calling application. It is safer\\n     * to use {@link #getSmsManagerForSubscriptionId(int)} if the application will perform the\\n     * operation while in the background because this can cause unpredictable results, such as the\\n     * operation being sent over the wrong subscription or failing completely, depending on the\\n     * user\\\u0027s default SMS subscription setting.\\n     * \u003c/p\u003e\\n     *\\n     * @return the {@link SmsManager} associated with the default subscription id.\\n     *\\n     * @see SubscriptionManager#getDefaultSmsSubscriptionId()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static SmsManager getSmsManagerForSubscriptionId(int subId)", "label": "public static SmsManager getSmsManagerForSubscriptionId(int subId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the instance of the SmsManager associated with a particular subscription ID.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Constructing an {@link SmsManager} in this manner will\\n     * never cause an SMS disambiguation dialog to appear, unlike {@link #getDefault()}.\\n     * \u003c/p\u003e\\n     *\\n     * @param subId an SMS subscription ID, typically accessed using {@link SubscriptionManager}\\n     * @return the instance of the SmsManager associated with subscription\\n     *\\n     * @see SubscriptionManager#getActiveSubscriptionInfoList()\\n     * @see SubscriptionManager#getDefaultSmsSubscriptionId()\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)", "label": "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resolves the subscription id to use for the associated operation if\\n     * {@link #getSubscriptionId()} returns {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}.\\n     *\\n     * If app targets API level 28 or below and they are either sending the SMS from the background\\n     * or the device has more than one active subscription available and no default is set, we will\\n     * use the first logical slot to send the SMS and possibly fail later in the SMS sending\\n     * process.\\n     *\\n     * Regardless of the API level, if the app is the foreground app, then we will show the SMS\\n     * disambiguation dialog. If the app is in the background and tries to perform an operation, we\\n     * will not show the disambiguation dialog.\\n     *\\n     * See {@link #getDefault()} for a detailed explanation of how this method operates.\\n     *\\n     * @param resolverResult The callback that will be called when the subscription is resolved or\\n     *                       fails to be resolved.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSubscriptionId()", "label": "getSubscriptionId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private static ISms getISmsServiceOrThrow()", "label": "private static ISms getISmsServiceOrThrow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the ISms service, or throws an UnsupportedOperationException if\\n     * the service does not exist.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private ArrayList\u003cSmsMessage\u003e createMessageListFromRawRecords(List\u003cSmsRawData\u003e records)", "label": "private ArrayList\u003cSmsMessage\u003e createMessageListFromRawRecords(List\u003cSmsRawData\u003e records)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a list of \u003ccode\u003eSmsMessage\u003c/code\u003es from a list of SmsRawData records.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method is intended for internal use by carrier\\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\\n     * operation is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param records SMS EF records.\\n     * @return \u003ccode\u003eArrayList\u003c/code\u003e of \u003ccode\u003eSmsMessage\u003c/code\u003e objects.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)", "label": "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send an MMS message\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\\n     * operation is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param context application context\\n     * @param contentUri the content Uri from which the message pdu will be read\\n     * @param locationUrl the optional location url where message should be sent to\\n     * @param configOverrides the carrier-specific messaging configuration values to override for\\n     *  sending the message.\\n     * @param sentIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is successfully sent, or failed\\n     * @throws IllegalArgumentException if contentUri is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)", "label": "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Download an MMS message from carrier by a given location URL\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\\n     * operation is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param context application context\\n     * @param locationUrl the location URL of the MMS message to be downloaded, usually obtained\\n     *  from the MMS WAP push notification\\n     * @param contentUri the content uri to which the downloaded pdu will be written\\n     * @param configOverrides the carrier-specific messaging configuration values to override for\\n     *  downloading the message.\\n     * @param downloadedIntent if not NULL this \u003ccode\u003ePendingIntent\u003c/code\u003e is\\n     *  broadcast when the message is downloaded, or the download is failed\\n     * @throws IllegalArgumentException if locationUrl or contentUri is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Bundle getCarrierConfigValues()", "label": "public Bundle getCarrierConfigValues()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get carrier-dependent MMS configuration values.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method is intended for internal use by carrier\\n     * applications or the Telephony framework and will never trigger an SMS disambiguation dialog.\\n     * If this method is called on a device that has multiple active subscriptions, this {@link\\n     * SmsManager} instance has been created with {@link #getDefault()}, and no user-defined default\\n     * subscription is defined, the subscription ID associated with this message will be INVALID,\\n     * which will result in the operation being completed on the subscription associated with\\n     * logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation is\\n     * performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @return the bundle key/values pairs that contains MMS configuration values\\n     *  or an empty Bundle if they cannot be found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String createAppSpecificSmsToken(PendingIntent intent)", "label": "public String createAppSpecificSmsToken(PendingIntent intent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create a single use app specific incoming SMS request for the calling package.\\n     *\\n     * This method returns a token that if included in a subsequent incoming SMS message will cause\\n     * {@code intent} to be sent with the SMS data.\\n     *\\n     * The token is only good for one use, after an SMS has been received containing the token all\\n     * subsequent SMS messages with the token will be routed as normal.\\n     *\\n     * An app can only have one request at a time, if the app already has a request pending it will\\n     * be replaced with a new request.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\\n     * operation is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @return Token to include in an SMS message. The token will be 11 characters long.\\n     * @see android.provider.Telephony.Sms.Intents#getMessagesFromIntent\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)", "label": "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get SMS messages for the calling financial app.\\n     * The result will be delivered asynchronously in the passing in callback interface.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\\n     * operation is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param params the parameters to filter SMS messages returned.\\n     * @param executor the executor on which callback will be invoked.\\n     * @param callback a callback to receive CursorWindow with SMS messages.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)", "label": "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create a single use app specific incoming SMS request for the calling package.\\n     *\\n     * This method returns a token that if included in a subsequent incoming SMS message, and the\\n     * SMS message has a prefix from the given prefixes list, the provided {@code intent} will be\\n     * sent with the SMS data to the calling package.\\n     *\\n     * The token is only good for one use within a reasonable amount of time. After an SMS has been\\n     * received containing the token all subsequent SMS messages with the token will be routed as\\n     * normal.\\n     *\\n     * An app can only have one request at a time, if the app already has a request pending it will\\n     * be replaced with a new request.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this message will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\\n     * operation is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param prefixes this is a list of prefixes string separated by REGEX_PREFIX_DELIMITER. The\\n     *  matching SMS message should have at least one of the prefixes in the beginning of the\\n     *  message.\\n     * @param intent this intent is sent when the matching SMS message is received.\\n     * @return Token to include in an SMS message.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getSmscAddress()", "label": "public String getSmscAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the SMSC address from (U)SIM.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Using this method requires that your app is the\\n     * default SMS application, or READ_PRIVILEGED_PHONE_STATE permission, or has the carrier\\n     * privileges.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this method will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation\\n     * is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @return the SMSC address string, null if failed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setSmscAddress(@NonNull String smsc)", "label": "public boolean setSmscAddress(@NonNull String smsc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the SMSC address on (U)SIM.\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Using this method requires that your app is the\\n     * default SMS application, or has {@link android.Manifest.permission#MODIFY_PHONE_STATE}\\n     * permission, or has the carrier privileges.\u003c/p\u003e\\n     *\\n     * \u003cp class=\"note\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This method will never trigger an SMS disambiguation\\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\\n     * default subscription is defined, the subscription ID associated with this method will be\\n     * INVALID, which will result in the operation being completed on the subscription associated\\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation\\n     * is performed on the correct subscription.\\n     * \u003c/p\u003e\\n     *\\n     * @param smsc the SMSC address string.\\n     * @return true for success, false otherwise. Failure can be due modem returning an error.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.VisualVoicemailService", "label": "android.telephony.VisualVoicemailService", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public String getVoiceMailAlphaTag()", "label": "public String getVoiceMailAlphaTag()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the alphabetic identifier associated with the voice\\n     * mail number.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendDialerSpecialCode(String inputCode)", "label": "public void sendDialerSpecialCode(String inputCode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send the special dialer code. The IPC caller must be the current default dialer or have\\n     * carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param inputCode The special dialer code to send\\n     *\\n     * @throws SecurityException if the caller does not have carrier privileges or is not the\\n     *         current default dialer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCallState()", "label": "public int getCallState()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the state of all calls on the device.\\n     * \u003cp\u003e\\n     * This method considers not only calls in the Telephony stack, but also calls via other\\n     * {@link android.telecom.ConnectionService} implementations.\\n     * \u003cp\u003e\\n     * Note: The call state returned via this method may differ from what is reported by\\n     * {@link PhoneStateListener#onCallStateChanged(int, String)}, as that callback only considers\\n     * Telephony (mobile) calls.\\n     *\\n     * @return the current call state.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telecom.ConnectionService", "label": "android.telecom.ConnectionService", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A component that provides an RPC servant implementation of {@link IConnectionServiceAdapter},\\n * posting incoming messages on the main thread on a client-supplied delegate object.\\n *\\n * TODO: Generate this and similar classes using a compiler starting from AIDL interfaces.\\n *\\n * @hide\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getDataActivity()", "label": "public int getDataActivity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a constant indicating the type of activity on a data connection\\n     * (cellular).\\n     *\\n     * @see #DATA_ACTIVITY_NONE\\n     * @see #DATA_ACTIVITY_IN\\n     * @see #DATA_ACTIVITY_OUT\\n     * @see #DATA_ACTIVITY_INOUT\\n     * @see #DATA_ACTIVITY_DORMANT\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getDataState()", "label": "public int getDataState()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a constant indicating the current data connection state\\n     * (cellular).\\n     *\\n     * @see #DATA_DISCONNECTED\\n     * @see #DATA_CONNECTING\\n     * @see #DATA_CONNECTED\\n     * @see #DATA_SUSPENDED\\n     * @see #DATA_DISCONNECTING\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void listen(PhoneStateListener listener, int events)", "label": "public void listen(PhoneStateListener listener, int events)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers a listener object to receive notification of changes\\n     * in specified telephony states.\\n     * \u003cp\u003e\\n     * To register a listener, pass a {@link PhoneStateListener} and specify at least one telephony\\n     * state of interest in the events argument.\\n     *\\n     * At registration, and when a specified telephony state changes, the telephony manager invokes\\n     * the appropriate callback method on the listener object and passes the current (updated)\\n     * values.\\n     * \u003cp\u003e\\n     * To un-register a listener, pass the listener object and set the events argument to\\n     * {@link PhoneStateListener#LISTEN_NONE LISTEN_NONE} (0).\\n     *\\n     * If this TelephonyManager object has been created with {@link #createForSubscriptionId},\\n     * applies to the given subId. Otherwise, applies to\\n     * {@link SubscriptionManager#getDefaultSubscriptionId()}. To listen events for multiple subIds,\\n     * pass a separate listener object to each TelephonyManager object created with\\n     * {@link #createForSubscriptionId}.\\n     *\\n     * Note: if you call this method while in the middle of a binder transaction, you \u003cb\u003emust\u003c/b\u003e\\n     * call {@link android.os.Binder#clearCallingIdentity()} before calling this method. A\\n     * {@link SecurityException} will be thrown otherwise.\\n     *\\n     * This API should be used sparingly -- large numbers of listeners will cause system\\n     * instability. If a process has registered too many listeners without unregistering them, it\\n     * may encounter an {@link IllegalStateException} when trying to register more listeners.\\n     *\\n     * @param listener The {@link PhoneStateListener} object to register\\n     *                 (or unregister)\\n     * @param events The telephony state(s) of interest to the listener,\\n     *               as a bitwise-OR combination of {@link PhoneStateListener}\\n     *               LISTEN_ flags.\\n     \u0027}"}, {"color": "#97c2fc", "id": "clearCallingIdentity()", "label": "clearCallingIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.os.Binder", "label": "android.os.Binder", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Delegate overriding selected methods of android.os.Binder\\n *\\n * Through the layoutlib_create tool, selected methods of Binder have been replaced\\n * by calls to methods of the same name in this delegate class.\\n *\\n *\\n \u0027}"}, {"color": "#97c2fc", "id": "SecurityException", "label": "SecurityException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public boolean isVoiceCapable()", "label": "public boolean isVoiceCapable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return true if the current device is \"voice capable\".\\n     * \u003cp\u003e\\n     * \"Voice capable\" means that this device supports circuit-switched\\n     * (i.e. voice) phone calls over the telephony network, and is allowed\\n     * to display the in-call UI while a cellular voice call is active.\\n     * This will be false on \"data only\" devices which can\\\u0027t make voice\\n     * calls and don\\\u0027t support any in-call UI.\\n     * \u003cp\u003e\\n     * Note: the meaning of this flag is subtly different from the\\n     * PackageManager.FEATURE_TELEPHONY system feature, which is available\\n     * on any device with a telephony radio, even if the device is\\n     * data-only.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isSmsCapable()", "label": "public boolean isSmsCapable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * @return true if the current device supports sms service.\\n     * \u003cp\u003e\\n     * If true, this means that the device supports both sending and\\n     * receiving sms via the telephony network.\\n     * \u003cp\u003e\\n     * Note: Voicemail waiting sms, cell broadcasting sms, and MMS are\\n     *       disabled when device doesn\u0027t support sms.\\n     \"}"}, {"color": "#97c2fc", "id": "public List\u003cCellInfo\u003e getAllCellInfo()", "label": "public List\u003cCellInfo\u003e getAllCellInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Requests all available cell information from all radios on the device including the\\n     * camped/registered, serving, and neighboring cells.\\n     *\\n     * \u003cp\u003eThe response can include one or more {@link android.telephony.CellInfoGsm CellInfoGsm},\\n     * {@link android.telephony.CellInfoCdma CellInfoCdma},\\n     * {@link android.telephony.CellInfoTdscdma CellInfoTdscdma},\\n     * {@link android.telephony.CellInfoLte CellInfoLte}, and\\n     * {@link android.telephony.CellInfoWcdma CellInfoWcdma} objects, in any combination.\\n     * It is typical to see instances of one or more of any these in the list. In addition, zero\\n     * or more of the returned objects may be considered registered; that is, their\\n     * {@link android.telephony.CellInfo#isRegistered CellInfo.isRegistered()}\\n     * methods may return true, indicating that the cell is being used or would be used for\\n     * signaling communication if necessary.\\n     *\\n     * \u003cp\u003eBeginning with {@link android.os.Build.VERSION_CODES#Q Android Q},\\n     * if this API results in a change of the cached CellInfo, that change will be reported via\\n     * {@link android.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}.\\n     *\\n     * \u003cp\u003eApps targeting {@link android.os.Build.VERSION_CODES#Q Android Q} or higher will no\\n     * longer trigger a refresh of the cached CellInfo by invoking this API. Instead, those apps\\n     * will receive the latest cached results, which may not be current. Apps targeting\\n     * {@link android.os.Build.VERSION_CODES#Q Android Q} or higher that wish to request updated\\n     * CellInfo should call\\n     * {@link android.telephony.TelephonyManager#requestCellInfoUpdate requestCellInfoUpdate()};\\n     * however, in all cases, updates will be rate-limited and are not guaranteed. To determine the\\n     * recency of CellInfo data, callers should check\\n     * {@link android.telephony.CellInfo#getTimeStamp CellInfo#getTimeStamp()}.\\n     *\\n     * \u003cp\u003eThis method returns valid data for devices with\\n     * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. In cases\\n     * where only partial information is available for a particular CellInfo entry, unavailable\\n     * fields will be reported as {@link android.telephony.CellInfo#UNAVAILABLE}. All reported\\n     * cells will include at least a valid set of technology-specific identification info and a\\n     * power level measurement.\\n     *\\n     * \u003cp\u003eThis method is preferred over using {@link\\n     * android.telephony.TelephonyManager#getCellLocation getCellLocation()}.\\n     *\\n     * @return List of {@link android.telephony.CellInfo}; null if cell\\n     * information is unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellInfoLte", "label": "android.telephony.CellInfoLte", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link CellInfo} representing an LTE cell that provides identity and measurement info.\\n \u0027}"}, {"color": "#97c2fc", "id": "public CellIdentityLte getCellIdentity()", "label": "public CellIdentityLte getCellIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellIdentityLte} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellIdentityLte", "label": "android.telephony.CellIdentityLte", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * CellIdentity is to represent a unique LTE cell\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getCi()", "label": "public int getCi()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 28-bit Cell Identity,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNAVAILABLE", "label": "UNAVAILABLE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellInfo", "label": "android.telephony.CellInfo", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link CellInfo} representing an 5G NR cell that provides identity and measurement info.\\n \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellIdentityNr", "label": "android.telephony.CellIdentityNr", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Information to represent a unique NR(New Radio 5G) cell.\\n \u0027}"}, {"color": "#97c2fc", "id": "public long getNci()", "label": "public long getNci()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the NR(New Radio 5G) Cell Identity.\\n     *\\n     * @return The 36-bit NR Cell Identity in range [0, 68719476735] or\\n     *         {@link CellInfo#UNAVAILABLE_LONG} if unknown.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getNrarfcn()", "label": "public int getNrarfcn()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the New Radio Absolute Radio Frequency Channel Number.\\n     *\\n     * Reference: 3GPP TS 38.101-1 section 5.4.2.1 NR-ARFCN and channel raster.\\n     * Reference: 3GPP TS 38.101-2 section 5.4.2.1 NR-ARFCN and channel raster.\\n     *\\n     * @return Integer value in range [0, 3279165] or {@link CellInfo#UNAVAILABLE} if unknown.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int[] getBands()", "label": "public int[] getBands()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get bands of the cell\\n     *\\n     * Reference: 3GPP TS 36.101 section 5.5\\n     *\\n     * @return Array of band number or empty array if not available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getPci()", "label": "public int getPci()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Physical Cell Id 0..503,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getTac()", "label": "public int getTac()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 16-bit Tracking Area Code,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Set\u003cString\u003e getAdditionalPlmns()", "label": "public Set\u003cString\u003e getAdditionalPlmns()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a list of additional PLMN IDs supported by this cell.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellSignalStrength getCellSignalStrength()", "label": "public CellSignalStrength getCellSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellSignalStrengthNr} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellSignalStrengthNr", "label": "android.telephony.CellSignalStrengthNr", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * 5G NR signal strength related information.\\n \u0027}"}, {"color": "#97c2fc", "id": "private static int flip(int val)", "label": "private static int flip(int val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flip sign cell strength value when taking in the value from hal\\n     * @param val cell strength value\\n     * @return flipped value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSsRsrp()", "label": "public int getSsRsrp()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reference: 3GPP TS 38.215.\\n     * Range: -140 dBm to -44 dBm.\\n     * @return SS reference signal received power, {@link CellInfo#UNAVAILABLE} means unreported\\n     * value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSsRsrq()", "label": "public int getSsRsrq()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reference: 3GPP TS 38.215.\\n     * Range: -20 dB to -3 dB.\\n     * @return SS reference signal received quality, {@link CellInfo#UNAVAILABLE} means unreported\\n     * value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSsSinr()", "label": "public int getSsSinr()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reference: 3GPP TS 38.215 Sec 5.1.*, 3GPP TS 38.133 10.1.16.1\\n     * Range: -23 dB to 40 dB\\n     * @return SS signal-to-noise and interference ratio, {@link CellInfo#UNAVAILABLE} means\\n     * unreported value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCsiRsrp()", "label": "public int getCsiRsrp()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reference: 3GPP TS 38.215.\\n     * Range: -140 dBm to -44 dBm.\\n     * @return CSI reference signal received power, {@link CellInfo#UNAVAILABLE} means unreported\\n     * value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCsiRsrq()", "label": "public int getCsiRsrq()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reference: 3GPP TS 38.215.\\n     * Range: -20 dB to -3 dB.\\n     * @return CSI reference signal received quality, {@link CellInfo#UNAVAILABLE} means unreported\\n     * value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCsiSinr()", "label": "public int getCsiSinr()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reference: 3GPP TS 38.215 Sec 5.1.*, 3GPP TS 38.133 10.1.16.1\\n     * Range: -23 dB to 23 dB\\n     * @return CSI signal-to-noise and interference ratio, {@link CellInfo#UNAVAILABLE} means\\n     * unreported value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLevel()", "label": "public int getLevel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 {@inheritDoc} \u0027}"}, {"color": "#97c2fc", "id": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)", "label": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks if the given parameter type is considered to use for {@link #getLevel()}.\\n     *\\n     * Note: if multiple parameter types are considered, the smaller level for one of the\\n     * parameters would be returned by {@link #getLevel()}\\n     *\\n     * @param parameterType bitwise OR of {@link #USE_SSRSRP}, {@link #USE_SSRSRQ},\\n     *         {@link #USE_SSSINR}\\n     * @return {@code true} if the level is calculated based on the given parameter type;\\n     *      {@code false} otherwise.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "USE_SSSINR", "label": "USE_SSSINR", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getLevel()", "label": "getLevel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "USE_SSRSRP", "label": "USE_SSRSRP", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "USE_SSRSRQ", "label": "USE_SSRSRQ", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private int updateLevelWithMeasure(int measure, int[] thresholds)", "label": "private int updateLevelWithMeasure(int measure, int[] thresholds)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Update level with corresponding measure and thresholds.\\n     *\\n     * @param measure corresponding signal measure\\n     * @param thresholds corresponding signal thresholds\\n     * @return level of the signal strength\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getAsuLevel()", "label": "public int getAsuLevel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the RSCP in ASU.\\n     *\\n     * Asu is calculated based on 3GPP RSCP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69\\n     *\\n     * @return RSCP in ASU 0..96, 255, or UNAVAILABLE\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getDbm()", "label": "public int getDbm()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the RSCP as dBm value -120..-24dBm or {@link CellInfo#UNAVAILABLE UNAVAILABLE}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getEarfcn()", "label": "public int getEarfcn()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 18-bit Absolute RF Channel Number,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getBandwidth()", "label": "public int getBandwidth()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Cell bandwidth in kHz,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMobileNetworkOperator()", "label": "public String getMobileNetworkOperator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a 5 or 6 character string (MCC+MNC), null if any field is unknown\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ClosedSubscriberGroupInfo getClosedSubscriberGroupInfo()", "label": "public ClosedSubscriberGroupInfo getClosedSubscriberGroupInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return closed subscriber group information about the cell if available, otherwise null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellSignalStrengthLte getCellSignalStrength()", "label": "public CellSignalStrengthLte getCellSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellSignalStrengthLte} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellSignalStrengthLte", "label": "android.telephony.CellSignalStrengthLte", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * LTE signal strength related information.\\n \u0027}"}, {"color": "#97c2fc", "id": "private boolean isLevelForParameter(int parameterType)", "label": "private boolean isLevelForParameter(int parameterType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks if the given parameter type is considered to use for {@link #getLevel()}.\\n     *\\n     * Note: if multiple parameter types are considered, the smaller level for one of the\\n     * parameters would be returned by {@link #getLevel()}\\n     *\\n     * @param parameterType bitwise OR of {@link #USE_RSRP}, {@link #USE_RSRQ},\\n     *         {@link #USE_RSSNR}\\n     * @return {@code true} if the level is calculated based on the given parameter type;\\n     *      {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "USE_RSSNR", "label": "USE_RSSNR", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "USE_RSRQ", "label": "USE_RSRQ", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "USE_RSRP", "label": "USE_RSRP", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getRsrq()", "label": "public int getRsrq()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get reference signal received quality\\n     *\\n     * @return the RSRQ if available or\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getRssi()", "label": "public int getRssi()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the Received Signal Strength Indicator.\\n     *\\n     * @return the RSSI in dBm (-113, -51) or\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getRssnr()", "label": "public int getRssnr()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get reference signal signal-to-noise ratio\\n     *\\n     * @return the RSSNR if available or\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getRsrp()", "label": "public int getRsrp()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get reference signal received power in dBm\\n     *\\n     * @return the RSRP of the measured cell.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCqi()", "label": "public int getCqi()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get channel quality indicator\\n     *\\n     * @return the CQI if available or\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getTimingAdvance()", "label": "public int getTimingAdvance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the GSM timing advance between 0..219 symbols (normally 0..63).\\n     * \u003cp\u003e{@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} is reported when there is no RR\\n     * connection. Refer to 3GPP 45.010 Sec 5.8.\\n     *\\n     * @return the current GSM timing advance, if available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void log(String s)", "label": "private static void log(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * log\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellInfoTdscdma", "label": "android.telephony.CellInfoTdscdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link CellInfo} representing a TD-SCDMA cell that provides identity and measurement info.\\n *\\n * @see android.telephony.CellInfo\\n * @see android.telephony.CellSignalStrengthTdscdma\\n * @see android.telephony.CellIdentityTdscdma\\n \u0027}"}, {"color": "#97c2fc", "id": "public CellIdentityTdscdma getCellIdentity()", "label": "public CellIdentityTdscdma getCellIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellIdentityTdscdma} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellIdentityTdscdma", "label": "android.telephony.CellIdentityTdscdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * CellIdentity is to represent a unique TD-SCDMA cell\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getLac()", "label": "public int getLac()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 16-bit Location Area Code, 0..65535,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCid()", "label": "public int getCid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return CID\\n     * 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCpid()", "label": "public int getCpid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 8-bit Cell Parameters ID described in TS 25.331, 0..127,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getUarfcn()", "label": "public int getUarfcn()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 16-bit UMTS Absolute RF Channel Number,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellSignalStrengthTdscdma getCellSignalStrength()", "label": "public CellSignalStrengthTdscdma getCellSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellSignalStrengthTdscdma} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellSignalStrengthTdscdma", "label": "android.telephony.CellSignalStrengthTdscdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Tdscdma signal strength related information.\\n *\\n * This class provides signal strength and signal quality information for the TD-SCDMA air\\n * interface. For more information see 3gpp 25.225.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getRscp()", "label": "public int getRscp()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the RSCP as dBm value -120..-24dBm or {@link CellInfo#UNAVAILABLE UNAVAILABLE}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellInfoGsm", "label": "android.telephony.CellInfoGsm", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link CellInfo} representing a GSM cell that provides identity and measurement info.\\n \u0027}"}, {"color": "#97c2fc", "id": "public CellIdentityGsm getCellIdentity()", "label": "public CellIdentityGsm getCellIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellIdentityGsm} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellIdentityGsm", "label": "android.telephony.CellIdentityGsm", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * CellIdentity to represent a unique GSM cell\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getArfcn()", "label": "public int getArfcn()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 16-bit GSM Absolute RF Channel Number,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getBsic()", "label": "public int getBsic()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 6-bit Base Station Identity Code,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellSignalStrengthGsm getCellSignalStrength()", "label": "public CellSignalStrengthGsm getCellSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellSignalStrengthGsm} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellSignalStrengthGsm", "label": "android.telephony.CellSignalStrengthGsm", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * GSM signal strength related information.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getBitErrorRate()", "label": "public int getBitErrorRate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the Bit Error Rate.\\n     *\\n     * @return the bit error rate (0-7, 99) as defined in TS 27.007 8.5 or\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellInfoCdma", "label": "android.telephony.CellInfoCdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link CellInfo} representing a CDMA cell that provides identity and measurement info.\\n \u0027}"}, {"color": "#97c2fc", "id": "public CellIdentityCdma getCellIdentity()", "label": "public CellIdentityCdma getCellIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellIdentityCdma} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellIdentityCdma", "label": "android.telephony.CellIdentityCdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * CellIdentity is to represent a unique CDMA cell\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getNetworkId()", "label": "public int getNetworkId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Network Id 0..65535, {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE}\\n     *         if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSystemId()", "label": "public int getSystemId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return System Id 0..32767, {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE}\\n     *         if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getBasestationId()", "label": "public int getBasestationId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Base Station Id 0..65535, {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE}\\n     *         if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLongitude()", "label": "public int getLongitude()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Base station longitude, which is a decimal number as\\n     * specified in 3GPP2 C.S0005-A v6.0. It is represented in units\\n     * of 0.25 seconds and ranges from -2592000 to 2592000, both\\n     * values inclusive (corresponding to a range of -180\\n     * to +180 degrees). {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLatitude()", "label": "public int getLatitude()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return Base station latitude, which is a decimal number as\\n     * specified in 3GPP2 C.S0005-A v6.0. It is represented in units\\n     * of 0.25 seconds and ranges from -1296000 to 1296000, both\\n     * values inclusive (corresponding to a range of -90\\n     * to +90 degrees). {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellSignalStrengthCdma getCellSignalStrength()", "label": "public CellSignalStrengthCdma getCellSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellSignalStrengthCdma} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellSignalStrengthCdma", "label": "android.telephony.CellSignalStrengthCdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Signal strength related information.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getCdmaLevel()", "label": "public int getCdmaLevel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get cdma as level 0..4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getEvdoLevel()", "label": "public int getEvdoLevel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get Evdo as level 0..4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCdmaDbm()", "label": "public int getCdmaDbm()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the CDMA RSSI value in dBm\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getCdmaEcio()", "label": "public int getCdmaEcio()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the CDMA Ec/Io value in dB*10\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getEvdoDbm()", "label": "public int getEvdoDbm()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the EVDO RSSI value in dBm\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getEvdoEcio()", "label": "public int getEvdoEcio()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the EVDO Ec/Io value in dB*10\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getEvdoSnr()", "label": "public int getEvdoSnr()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the signal to noise ratio. Valid values are 0-8. 8 is the highest.\\n     \u0027}"}, {"color": "#97c2fc", "id": "requestCellInfoUpdate", "label": "requestCellInfoUpdate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellInfoWcdma", "label": "android.telephony.CellInfoWcdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link CellInfo} representing a WCDMA cell that provides identity and measurement info.\\n \u0027}"}, {"color": "#97c2fc", "id": "public CellIdentityWcdma getCellIdentity()", "label": "public CellIdentityWcdma getCellIdentity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellIdentityWcdma} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellIdentityWcdma", "label": "android.telephony.CellIdentityWcdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * CellIdentity to represent a unique UMTS cell\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getPsc()", "label": "public int getPsc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return 9-bit UMTS Primary Scrambling Code described in TS 25.331, 0..511,\\n     *         {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CellSignalStrengthWcdma getCellSignalStrength()", "label": "public CellSignalStrengthWcdma getCellSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return a {@link CellSignalStrengthWcdma} instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telephony.CellSignalStrengthWcdma", "label": "android.telephony.CellSignalStrengthWcdma", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Wcdma signal strength related information.\\n \u0027}"}, {"color": "#97c2fc", "id": "public int getEcNo()", "label": "public int getEcNo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the Ec/No (Energy per chip over the noise spectral density) as dB.\\n     *\\n     * Reference: TS 25.133 Section 9.1.2.3\\n     *\\n     * @return the Ec/No of the measured cell in the range [-24, 1] or\\n     * {@link android.telephony.CellInfo#UNAVAILABLE UNAVAILABLE} if unavailable\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void loge(String s)", "label": "private static void loge(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * log error\\n     \u0027}"}, {"color": "#97c2fc", "id": "FEATURE_TELEPHONY", "label": "FEATURE_TELEPHONY", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "Q", "label": "Q", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getCellLocation", "label": "getCellLocation", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void requestCellInfoUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)", "label": "public void requestCellInfoUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Requests all available cell information from the current subscription for observed\\n     * camped/registered, serving, and neighboring cells.\\n     *\\n     * \u003cp\u003eAny available results from this request will be provided by calls to\\n     * {@link android.telephony.PhoneStateListener#onCellInfoChanged onCellInfoChanged()}\\n     * for each active subscription.\\n     *\\n     * \u003cp\u003eThis method returns valid data for devices with\\n     * {@link android.content.pm.PackageManager#FEATURE_TELEPHONY FEATURE_TELEPHONY}. On devices\\n     * that do not implement this feature, the behavior is not reliable.\\n     *\\n     * @param executor the executor on which callback will be invoked.\\n     * @param callback a callback to receive CellInfo.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMmsUserAgent()", "label": "public String getMmsUserAgent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the MMS user agent.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getMmsUAProfUrl()", "label": "public String getMmsUAProfUrl()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the MMS user agent profile URL.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getSubId()", "label": "private int getSubId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return an appropriate subscription ID for any situation.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, then the provided\\n     * subscription ID is returned. Otherwise, the default subscription ID will be returned.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getSubId(int preferredSubId)", "label": "private int getSubId(int preferredSubId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Return an appropriate subscription ID for any situation.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, then the provided\\n     * subId is returned. Otherwise, the preferred subId which is based on caller\u0027s context is\\n     * returned.\\n     * {@see SubscriptionManager#getDefaultDataSubscriptionId()}\\n     * {@see SubscriptionManager#getDefaultVoiceSubscriptionId()}\\n     * {@see SubscriptionManager#getDefaultSmsSubscriptionId()}\\n     \"}"}, {"color": "#97c2fc", "id": "private int getPhoneId()", "label": "private int getPhoneId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return an appropriate phone ID for any situation.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, then the phoneId\\n     * associated with the provided subId is returned. Otherwise, the default phoneId associated\\n     * with the default subId will be returned.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getPhoneId(int preferredSubId)", "label": "private int getPhoneId(int preferredSubId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Return an appropriate phone ID for any situation.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, then the phoneId\\n     * associated with the provided subId is returned. Otherwise, return the phoneId associated\\n     * with the preferred subId based on caller\u0027s context.\\n     * {@see SubscriptionManager#getDefaultDataSubscriptionId()}\\n     * {@see SubscriptionManager#getDefaultVoiceSubscriptionId()}\\n     * {@see SubscriptionManager#getDefaultSmsSubscriptionId()}\\n     \"}"}, {"color": "#97c2fc", "id": "private static List\u003cT\u003e updateTelephonyProperty(List\u003cT\u003e prop, int phoneId, T value)", "label": "private static List\u003cT\u003e updateTelephonyProperty(List\u003cT\u003e prop, int phoneId, T value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts or updates a list property. Expands the list if its length is not enough.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static T getTelephonyProperty(int phoneId, List\u003cT\u003e prop, T defaultValue)", "label": "private static T getTelephonyProperty(int phoneId, List\u003cT\u003e prop, T defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets a typed per-phone telephony property from a schematized list property.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getIccAuthentication(int appType, int authType, String data)", "label": "public String getIccAuthentication(int appType, int authType, String data)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \" it\u0027s not public API.\"}"}, {"color": "#97c2fc", "id": "public String[] getForbiddenPlmns()", "label": "public String[] getForbiddenPlmns()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of Forbidden PLMNs from the USIM App\\n     * Returns null if the query fails.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return an array of forbidden PLMNs or null if not available\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int setForbiddenPlmns(@NonNull List\u003cString\u003e fplmns)", "label": "public int setForbiddenPlmns(@NonNull List\u003cString\u003e fplmns)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Replace the contents of the forbidden PLMN SIM file with the provided values.\\n     * Passing an empty list will clear the contents of the EFfplmn file.\\n     * If the provided list is shorter than the size of EFfplmn, then the list will be padded\\n     * up to the file size with \u0027FFFFFF\u0027. (required by 3GPP TS 31.102 spec 4.2.16)\\n     * If the list is longer than the size of EFfplmn, then the file will be written from the\\n     * beginning of the list up to the file size.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE\\n     * MODIFY_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param fplmns a list of PLMNs to be forbidden.\\n     *\\n     * @return number of PLMNs that were successfully written to the SIM FPLMN list.\\n     * This may be less than the number of PLMNs passed in where the SIM file does not have enough\\n     * room for all of the values passed in. Return -1 in the event of an unexpected failure\\n     \"}"}, {"color": "#97c2fc", "id": "MODIFY_PHONE_STATEMODIFY_PHONE_STATE", "label": "MODIFY_PHONE_STATEMODIFY_PHONE_STATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setNetworkSelectionModeAutomatic()", "label": "public void setNetworkSelectionModeAutomatic()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the network selection mode to automatic.\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)", "label": "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request a network scan.\\n     *\\n     * This method is asynchronous, so the network scan results will be returned by callback.\\n     * The returned NetworkScan will contain a callback method which can be used to stop the scan.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges})\\n     * and {@link android.Manifest.permission#ACCESS_FINE_LOCATION}.\\n     *\\n     * If the system-wide location switch is off, apps may still call this API, with the\\n     * following constraints:\\n     * \u003col\u003e\\n     *     \u003cli\u003eThe app must hold the {@code android.permission.NETWORK_SCAN} permission.\u003c/li\u003e\\n     *     \u003cli\u003eThe app must not supply any specific bands or channels to scan.\u003c/li\u003e\\n     *     \u003cli\u003eThe app must only specify MCC/MNC pairs that are\\n     *     associated to a SIM in the device.\u003c/li\u003e\\n     *     \u003cli\u003eReturned results will have no meaningful info other than signal strength\\n     *     and MCC/MNC info.\u003c/li\u003e\\n     * \u003c/ol\u003e\\n     *\\n     * @param request Contains all the RAT with bands/channels that need to be scanned.\\n     * @param executor The executor through which the callback should be invoked. Since the scan\\n     *        request may trigger multiple callbacks and they must be invoked in the same order as\\n     *        they are received by the platform, the user should provide an executor which executes\\n     *        tasks one at a time in serial order. For example AsyncTask.SERIAL_EXECUTOR.\\n     * @param callback Returns network scan results or errors.\\n     * @return A NetworkScan obj which contains a callback which can be used to stop the scan.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)", "label": "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Ask the radio to connect to the input network and change selection mode to manual.\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param operatorNumeric the PLMN ID of the network to select.\\n     * @param persistSelection whether the selection will persist until reboot. If true, only allows\\n     * attaching to the selected PLMN until reboot; otherwise, attach to the chosen PLMN and resume\\n     * normal network selection next time.\\n     * @return {@code true} on success; {@code false} on any failure.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "label": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Ask the radio to connect to the input network and change selection mode to manual.\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param operatorNumeric the PLMN ID of the network to select.\\n     * @param persistSelection whether the selection will persist until reboot.\\n     *         If true, only allows attaching to the selected PLMN until reboot; otherwise,\\n     *         attach to the chosen PLMN and resume normal network selection next time.\\n     * @param ran the initial suggested radio access network type.\\n     *         If registration fails, the RAN is not available after, the RAN is not within the\\n     *         network types specified by the preferred network types, or the value is\\n     *         {@link AccessNetworkConstants.AccessNetworkType#UNKNOWN}, modem will select\\n     *         the next best RAN for network registration.\\n     * @return {@code true} on success; {@code false} on any failure.\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNKNOWN", "label": "UNKNOWN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getNetworkSelectionMode()", "label": "public int getNetworkSelectionMode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the network selection mode.\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\\n     *  \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PRECISE_PHONE_STATE\\n     * READ_PRECISE_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return the network selection mode.\\n     \u0027}"}, {"color": "#97c2fc", "id": "READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE", "label": "READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getManualNetworkSelectionPlmn()", "label": "public String getManualNetworkSelectionPlmn()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the PLMN chosen for Manual Network Selection if active.\\n     * Return empty string if in automatic selection.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PRECISE_PHONE_STATE\\n     * READ_PRECISE_PHONE_STATE} or that the calling app has carrier privileges\\n     * (see {@link #hasCarrierPrivileges})\\n     *\\n     * @return manually selected network info on success or empty string on failure\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setPreferredNetworkTypeToGlobal()", "label": "public boolean setPreferredNetworkTypeToGlobal()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the preferred network type to global mode which includes LTE, CDMA, EvDo and GSM/WCDMA.\\n     *\\n     * \u003cp\u003eRequires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return true on success; false on any failure.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasCarrierPrivileges()", "label": "public boolean hasCarrierPrivileges()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Has the calling application been granted carrier privileges by the carrier.\\n     *\\n     * If any of the packages in the calling UID has carrier privileges, the\\n     * call will return true. This access is granted by the owner of the UICC\\n     * card and does not depend on the registered carrier.\\n     *\\n     * @return true if the app has carrier privileges.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setOperatorBrandOverride(String brand)", "label": "public boolean setOperatorBrandOverride(String brand)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Override the branding for the current ICCID.\\n     *\\n     * Once set, whenever the SIM is present in the device, the service\\n     * provider name (SPN) and the operator name will both be replaced by the\\n     * brand value input. To unset the value, the same function should be\\n     * called with a null brand value.\\n     *\\n     * \u003cp\u003eRequires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param brand The brand name to display/set.\\n     * @return true if the operation was executed correctly.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)", "label": "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sends an Unstructured Supplementary Service Data (USSD) request to the mobile network and\\n     * informs the caller of the response via the supplied {@code callback}.\\n     * \u003cp\u003eCarriers define USSD codes which can be sent by the user to request information such as\\n     * the user\u0027s current data balance or minutes balance.\\n     * \u003cp\u003eRequires permission:\\n     * {@link android.Manifest.permission#CALL_PHONE}\\n     * @param ussdRequest the USSD command to be executed.\\n     * @param callback called by the framework to inform the caller of the result of executing the\\n     *                 USSD request (see {@link UssdResponseCallback}).\\n     * @param handler the {@link Handler} to run the request on.\\n     \"}"}, {"color": "#97c2fc", "id": "UssdResponseCallback", "label": "UssdResponseCallback", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "android.os.Handler", "label": "android.os.Handler", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Delegate overriding selected methods of android.os.HandlerThread\\n *\\n * Through the layoutlib_create tool, selected methods of Handler have been replaced\\n * by calls to methods of the same name in this delegate class.\\n *\\n *\\n \u0027}"}, {"color": "#97c2fc", "id": "CALL_PHONE", "label": "CALL_PHONE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isConcurrentVoiceAndDataSupported()", "label": "public boolean isConcurrentVoiceAndDataSupported()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Whether the device is currently on a technology (e.g. UMTS or LTE) which can support\\n     * voice and data simultaneously. This can change based on location or network condition.\\n     *\\n     * @return {@code true} if simultaneous voice and data supported, and {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setDataEnabled(boolean enable)", "label": "public void setDataEnabled(boolean enable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Turns mobile data on or off.\\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the given\\n     * subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param enable Whether to enable mobile data.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isDataEnabled()", "label": "public boolean isDataEnabled()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether mobile data is enabled or not per user setting. There are other factors\\n     * that could disable mobile data, but they are not considered here.\\n     *\\n     * If this object has been created with {@link #createForSubscriptionId}, applies to the given\\n     * subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires one of the following permissions:\\n     * {@link android.Manifest.permission#ACCESS_NETWORK_STATE},\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE}, or that the calling app has carrier\\n     * privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * \u003cp\u003eNote that this does not take into account any data restrictions that may be present on the\\n     * calling app. Such restrictions may be inspected with\\n     * {@link ConnectivityManager#getRestrictBackgroundStatus}.\\n     *\\n     * @return true if mobile data is enabled.\\n     \u0027}"}, {"color": "#97c2fc", "id": "ACCESS_NETWORK_STATE", "label": "ACCESS_NETWORK_STATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getRestrictBackgroundStatus", "label": "getRestrictBackgroundStatus", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.net.ConnectivityManager", "label": "android.net.ConnectivityManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Class that answers queries about the state of network connectivity. It also\\n * notifies applications when network connectivity changes.\\n * \u003cp\u003e\\n * The primary responsibilities of this class are to:\\n * \u003col\u003e\\n * \u003cli\u003eMonitor network connections (Wi-Fi, GPRS, UMTS, etc.)\u003c/li\u003e\\n * \u003cli\u003eSend broadcast intents when network connectivity changes\u003c/li\u003e\\n * \u003cli\u003eAttempt to \"fail over\" to another network when connectivity to a network\\n * is lost\u003c/li\u003e\\n * \u003cli\u003eProvide an API that allows applications to query the coarse-grained or fine-grained\\n * state of the available networks\u003c/li\u003e\\n * \u003cli\u003eProvide an API that allows applications to request and select networks for their data\\n * traffic\u003c/li\u003e\\n * \u003c/ol\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": "public Network getActiveNetwork()", "label": "public Network getActiveNetwork()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Network} object corresponding to the currently active\\n     * default data network.  In the event that the current active default data\\n     * network disconnects, the returned {@code Network} object will no longer\\n     * be usable.  This will return {@code null} when there is no default\\n     * network.\\n     *\\n     * @return a {@link Network} object for the current default network or\\n     *        {@code null} if no default network is currently active\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.net.Network", "label": "android.net.Network", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A NetworkFactory is an entity that creates NetworkAgent objects.\\n * The bearers register with ConnectivityService using {@link #register} and\\n * their factory will start receiving scored NetworkRequests.  NetworkRequests\\n * can be filtered 3 ways: by NetworkCapabilities, by score and more complexly by\\n * overridden function.  All of these can be dynamic - changing NetworkCapabilities\\n * or score forces re-evaluation of all current requests.\\n *\\n * If any requests pass the filter some overrideable functions will be called.\\n * If the bearer only cares about very simple start/stopNetwork callbacks, those\\n * functions can be overridden.  If the bearer needs more interaction, it can\\n * override addNetworkRequest and removeNetworkRequest which will give it each\\n * request that passes their current filters.\\n * @hide\\n *\u0027}"}, {"color": "#97c2fc", "id": "public void register()", "label": "public void register()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Registers this NetworkFactory with the system. May only be called once per factory. \u0027}"}, {"color": "#97c2fc", "id": "public void terminate()", "label": "public void terminate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Unregisters this NetworkFactory. After this call, the object can no longer be used. \u0027}"}, {"color": "#97c2fc", "id": "protected void handleAddRequest(NetworkRequest request, int score, int servingProviderId)", "label": "protected void handleAddRequest(NetworkRequest request, int score, int servingProviderId)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Add a NetworkRequest that the bearer may want to attempt to satisfy.\\n     * @see #CMD_REQUEST_NETWORK\\n     *\\n     * @param request the request to handle.\\n     * @param score the score of the NetworkAgent currently satisfying this request.\\n     * @param servingProviderId the ID of the NetworkProvider that created the NetworkAgent\\n     *        currently satisfying this request.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean acceptRequest(NetworkRequest request, int score)", "label": "public boolean acceptRequest(NetworkRequest request, int score)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Overridable function to provide complex filtering.\\n     * Called for every request every time a new NetworkRequest is seen\\n     * and whenever the filterScore or filterNetworkCapabilities change.\\n     *\\n     * acceptRequest can be overridden to provide complex filter behavior\\n     * for the incoming requests\\n     *\\n     * For output, this class will call {@link #needNetworkFor} and\\n     * {@link #releaseNetworkFor} for every request that passes the filters.\\n     * If you don\u0027t need to see every request, you can leave the base\\n     * implementations of those two functions and instead override\\n     * {@link #startNetwork} and {@link #stopNetwork}.\\n     *\\n     * If you want to see every score fluctuation on every request, set\\n     * your score filter to a very high number and watch {@link #needNetworkFor}.\\n     *\\n     * @return {@code true} to accept the request.\\n     \"}"}, {"color": "#97c2fc", "id": "startNetwork", "label": "startNetwork", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "releaseNetworkFor", "label": "releaseNetworkFor", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "needNetworkFor", "label": "needNetworkFor", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "stopNetwork", "label": "stopNetwork", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void reevaluateAllRequests()", "label": "protected void reevaluateAllRequests()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Post a command, on this NetworkFactory Handler, to re-evaluate all\\n     * outstanding requests. Can be called from a factory implementation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void releaseRequestAsUnfulfillableByAnyFactory(NetworkRequest r)", "label": "protected void releaseRequestAsUnfulfillableByAnyFactory(NetworkRequest r)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Can be called by a factory to release a request as unfulfillable: the request will be\\n     * removed, and the caller will get a\\n     * {@link ConnectivityManager.NetworkCallback#onUnavailable()} callback after this function\\n     * returns.\\n     *\\n     * Note: this should only be called by factory which KNOWS that it is the ONLY factory which\\n     * is able to fulfill this request!\\n     \u0027}"}, {"color": "#97c2fc", "id": "onUnavailable()", "label": "onUnavailable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void startNetwork()", "label": "protected void startNetwork()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 override to do simple mode (request independent)\u0027}"}, {"color": "#97c2fc", "id": "protected void needNetworkFor(NetworkRequest networkRequest, int score)", "label": "protected void needNetworkFor(NetworkRequest networkRequest, int score)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 override to do fancier stuff\u0027}"}, {"color": "#97c2fc", "id": "public int getSerialNumber()", "label": "public int getSerialNumber()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 TODO: delete when all callers have migrated to NetworkProvider IDs. \u0027}"}, {"color": "#97c2fc", "id": "public Network[] getAllNetworks()", "label": "public Network[] getAllNetworks()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of all {@link Network} currently tracked by the\\n     * framework.\\n     *\\n     * @return an array of {@link Network} objects.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public LinkProperties getLinkProperties(@Nullable Network network)", "label": "public LinkProperties getLinkProperties(@Nullable Network network)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the {@link LinkProperties} for the given {@link Network}.  This\\n     * will return {@code null} if the network is unknown.\\n     *\\n     * @param network The {@link Network} object identifying the network in question.\\n     * @return The {@link LinkProperties} for the network, or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public NetworkCapabilities getNetworkCapabilities(@Nullable Network network)", "label": "public NetworkCapabilities getNetworkCapabilities(@Nullable Network network)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.  This\\n     * will return {@code null} if the network is unknown.\\n     *\\n     * @param network The {@link Network} object identifying the network in question.\\n     * @return The {@link android.net.NetworkCapabilities} for the network, or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "label": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request that keepalives be started on a IPsec NAT-T socket.\\n     *\\n     * @param network The {@link Network} the socket is on.\\n     * @param socket The socket that needs to be kept alive.\\n     * @param source The source address of the {@link UdpEncapsulationSocket}.\\n     * @param destination The destination address of the {@link UdpEncapsulationSocket}.\\n     * @param executor The executor on which callback will be invoked. The provided {@link Executor}\\n     *                 must run callback sequentially, otherwise the order of callbacks cannot be\\n     *                 guaranteed.\\n     * @param callback A {@link SocketKeepalive.Callback}. Used for notifications about keepalive\\n     *        changes. Must be extended by applications that use this API.\\n     *\\n     * @return A {@link SocketKeepalive} object that can be used to control the keepalive on the\\n     *         given socket.\\n     *\u0027}"}, {"color": "#97c2fc", "id": "android.net.SocketKeepalive", "label": "android.net.SocketKeepalive", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "SocketKeepalive.Callback", "label": "SocketKeepalive.Callback", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "android.annotation.CallbackExecutor", "label": "android.annotation.CallbackExecutor", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "android.net.IpSecManager.UdpEncapsulationSocket", "label": "android.net.IpSecManager.UdpEncapsulationSocket", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void addDefaultNetworkActiveListener(final OnNetworkActiveListener l)", "label": "public void addDefaultNetworkActiveListener(final OnNetworkActiveListener l)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Start listening to reports when the system\u0027s default data network is active, meaning it is\\n     * a good time to perform network traffic.  Use {@link #isDefaultNetworkActive()}\\n     * to determine the current state of the system\u0027s default network after registering the\\n     * listener.\\n     * \u003cp\u003e\\n     * If the process default network has been set with\\n     * {@link ConnectivityManager#bindProcessToNetwork} this function will not\\n     * reflect the process\u0027s default, but the system default.\\n     *\\n     * @param l The listener to be told when the network is active.\\n     \"}"}, {"color": "#97c2fc", "id": "isDefaultNetworkActive()", "label": "isDefaultNetworkActive()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "bindProcessToNetwork", "label": "bindProcessToNetwork", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void removeDefaultNetworkActiveListener(@NonNull OnNetworkActiveListener l)", "label": "public void removeDefaultNetworkActiveListener(@NonNull OnNetworkActiveListener l)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Remove network active listener previously registered with\\n     * {@link #addDefaultNetworkActiveListener}.\\n     *\\n     * @param l Previously registered listener.\\n     \u0027}"}, {"color": "#97c2fc", "id": "addDefaultNetworkActiveListener", "label": "addDefaultNetworkActiveListener", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isDefaultNetworkActive()", "label": "public boolean isDefaultNetworkActive()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return whether the data network is currently active.  An active network means that\\n     * it is currently in a high power state for performing data transmission.  On some\\n     * types of networks, it may be expensive to move and stay in such a state, so it is\\n     * more power efficient to batch network traffic together when the radio is already in\\n     * this state.  This method tells you whether right now is currently a good time to\\n     * initiate network traffic, as the network is already active.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void reportNetworkConnectivity(@Nullable Network network, boolean hasConnectivity)", "label": "public void reportNetworkConnectivity(@Nullable Network network, boolean hasConnectivity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Report to the framework whether a network has working connectivity.\\n     * This provides a hint to the system that a particular network is providing\\n     * working connectivity or not.  In response the framework may re-evaluate\\n     * the network\u0027s connectivity and might take further action thereafter.\\n     *\\n     * @param network The {@link Network} the application was attempting to use\\n     *                or {@code null} to indicate the current default network.\\n     * @param hasConnectivity {@code true} if the application was able to successfully access the\\n     *                        Internet using {@code network} or {@code false} if not.\\n     \"}"}, {"color": "#97c2fc", "id": "public ProxyInfo getDefaultProxy()", "label": "public ProxyInfo getDefaultProxy()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Get the current default HTTP proxy settings.  If a global proxy is set it will be returned,\\n     * otherwise if this process is bound to a {@link Network} using\\n     * {@link #bindProcessToNetwork} then that {@code Network}\u0027s proxy is returned, otherwise\\n     * the default network\u0027s proxy is returned.\\n     *\\n     * @return the {@link ProxyInfo} for the current HTTP proxy, or {@code null} if no\\n     *        HTTP proxy is active.\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean isActiveNetworkMetered()", "label": "public boolean isActiveNetworkMetered()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns if the currently active data network is metered. A network is\\n     * classified as metered when the user is sensitive to heavy data usage on\\n     * that connection due to monetary costs, data limitations or\\n     * battery/performance issues. You should check this before doing large\\n     * data transfers, and warn the user or delay the operation until another\\n     * network is available.\\n     *\\n     * @return {@code true} if large transfers should be avoided, otherwise\\n     *        {@code false}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "label": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.\\n     *\\n     * \u003cp\u003eThis method will attempt to find the best network that matches the passed\\n     * {@link NetworkRequest}, and to bring up one that does if none currently satisfies the\\n     * criteria. The platform will evaluate which network is the best at its own discretion.\\n     * Throughput, latency, cost per byte, policy, user preference and other considerations\\n     * may be factored in the decision of what is considered the best network.\\n     *\\n     * \u003cp\u003eAs long as this request is outstanding, the platform will try to maintain the best network\\n     * matching this request, while always attempting to match the request to a better network if\\n     * possible. If a better match is found, the platform will switch this request to the now-best\\n     * network and inform the app of the newly best network by invoking\\n     * {@link NetworkCallback#onAvailable(Network)} on the provided callback. Note that the platform\\n     * will not try to maintain any other network than the best one currently matching the request:\\n     * a network not matching any network request may be disconnected at any time.\\n     *\\n     * \u003cp\u003eFor example, an application could use this method to obtain a connected cellular network\\n     * even if the device currently has a data connection over Ethernet. This may cause the cellular\\n     * radio to consume additional power. Or, an application could inform the system that it wants\\n     * a network supporting sending MMSes and have the system let it know about the currently best\\n     * MMS-supporting network through the provided {@link NetworkCallback}.\\n     *\\n     * \u003cp\u003eThe status of the request can be followed by listening to the various callbacks described\\n     * in {@link NetworkCallback}. The {@link Network} object passed to the callback methods can be\\n     * used to direct traffic to the network (although accessing some networks may be subject to\\n     * holding specific permissions). Callers will learn about the specific characteristics of the\\n     * network through\\n     * {@link NetworkCallback#onCapabilitiesChanged(Network, NetworkCapabilities)} and\\n     * {@link NetworkCallback#onLinkPropertiesChanged(Network, LinkProperties)}. The methods of the\\n     * provided {@link NetworkCallback} will only be invoked due to changes in the best network\\n     * matching the request at any given time; therefore when a better network matching the request\\n     * becomes available, the {@link NetworkCallback#onAvailable(Network)} method is called\\n     * with the new network after which no further updates are given about the previously-best\\n     * network, unless it becomes the best again at some later time. All callbacks are invoked\\n     * in order on the same thread, which by default is a thread created by the framework running\\n     * in the app.\\n     * {@see #requestNetwork(NetworkRequest, NetworkCallback, Handler)} to change where the\\n     * callbacks are invoked.\\n     *\\n     * \u003cp\u003eThis{@link NetworkRequest} will live until released via\\n     * {@link #unregisterNetworkCallback(NetworkCallback)} or the calling application exits, at\\n     * which point the system may let go of the network at any time.\\n     *\\n     * \u003cp\u003eA version of this method which takes a timeout is\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback, int)}, that an app can use to only\\n     * wait for a limited amount of time for the network to become unavailable.\\n     *\\n     * \u003cp\u003eIt is presently unsupported to request a network with mutable\\n     * {@link NetworkCapabilities} such as\\n     * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or\\n     * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}\\n     * as these {@code NetworkCapabilities} represent states that a particular\\n     * network may never attain, and whether a network will attain these states\\n     * is unknown prior to bringing up the network so the framework does not\\n     * know how to go about satisfying a request with these capabilities.\\n     *\\n     * \u003cp\u003eThis method requires the caller to hold either the\\n     * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission\\n     * or the ability to modify system settings as determined by\\n     * {@link android.provider.Settings.System#canWrite}.\u003c/p\u003e\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #registerNetworkCallback} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with\\n     * {@link #unregisterNetworkCallback(NetworkCallback)}.\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note\\n     *                        the callback must not be shared - it uniquely specifies this request.\\n     *                        The callback is invoked on the default internal Handler.\\n     * @throws IllegalArgumentException if {@code request} contains invalid network capabilities.\\n     * @throws SecurityException if missing the appropriate permissions.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "CHANGE_NETWORK_STATE", "label": "CHANGE_NETWORK_STATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "requestNetwork(NetworkRequest", "label": "requestNetwork(NetworkRequest", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "onLinkPropertiesChanged(Network", "label": "onLinkPropertiesChanged(Network", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "NetworkCallback", "label": "NetworkCallback", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "canWrite", "label": "canWrite", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "registerConnectivityDiagnosticsCallback", "label": "registerConnectivityDiagnosticsCallback", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.net.ConnectivityDiagnosticsManager", "label": "android.net.ConnectivityDiagnosticsManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Class that provides utilities for collecting network connectivity diagnostics information.\\n * Connectivity information is made available through triggerable diagnostics tools and by listening\\n * to System validations. Some diagnostics information may be permissions-restricted.\\n *\\n * \u003cp\u003eConnectivityDiagnosticsManager is intended for use by applications offering network\\n * connectivity on a user device. These tools will provide several mechanisms for these applications\\n * to be alerted to network conditions as well as diagnose potential network issues themselves.\\n *\\n * \u003cp\u003eThe primary responsibilities of this class are to:\\n *\\n * \u003cul\u003e\\n *   \u003cli\u003eAllow permissioned applications to register and unregister callbacks for network event\\n *       notifications\\n *   \u003cli\u003eInvoke callbacks for network event notifications, including:\\n *       \u003cul\u003e\\n *         \u003cli\u003eNetwork validations\\n *         \u003cli\u003eData stalls\\n *         \u003cli\u003eConnectivity reports from applications\\n *       \u003c/ul\u003e\\n * \u003c/ul\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": "public void registerConnectivityDiagnosticsCallback(@NonNull NetworkRequest request, @NonNull Executor e, @NonNull ConnectivityDiagnosticsCallback callback)", "label": "public void registerConnectivityDiagnosticsCallback(@NonNull NetworkRequest request, @NonNull Executor e, @NonNull ConnectivityDiagnosticsCallback callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers a ConnectivityDiagnosticsCallback with the System.\\n     *\\n     * \u003cp\u003eOnly apps that offer network connectivity to the user should be registering callbacks.\\n     * These are the only apps whose callbacks will be invoked by the system. Apps considered to\\n     * meet these conditions include:\\n     *\\n     * \u003cul\u003e\\n     *   \u003cli\u003eCarrier apps with active subscriptions\\n     *   \u003cli\u003eActive VPNs\\n     *   \u003cli\u003eWiFi Suggesters\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eCallbacks registered by apps not meeting the above criteria will not be invoked.\\n     *\\n     * \u003cp\u003eIf a registering app loses its relevant permissions, any callbacks it registered will\\n     * silently stop receiving callbacks.\\n     *\\n     * \u003cp\u003eEach register() call \u003cb\u003eMUST\u003c/b\u003e use a ConnectivityDiagnosticsCallback instance that is\\n     * not currently registered. If a ConnectivityDiagnosticsCallback instance is registered with\\n     * multiple NetworkRequests, an IllegalArgumentException will be thrown.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * callbacks in {@link ConnectivityManager}. Registering a callback with this method will count\\n     * toward this limit. If this limit is exceeded, an exception will be thrown. To avoid hitting\\n     * this issue and to conserve resources, make sure to unregister the callbacks with\\n     * {@link #unregisterConnectivityDiagnosticsCallback}.\\n     *\\n     * @param request The NetworkRequest that will be used to match with Networks for which\\n     *     callbacks will be fired\\n     * @param e The Executor to be used for running the callback method invocations\\n     * @param callback The ConnectivityDiagnosticsCallback that the caller wants registered with the\\n     *     System\\n     * @throws IllegalArgumentException if the same callback instance is registered with multiple\\n     *     NetworkRequests\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "unregisterConnectivityDiagnosticsCallback", "label": "unregisterConnectivityDiagnosticsCallback", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void unregisterConnectivityDiagnosticsCallback(@NonNull ConnectivityDiagnosticsCallback callback)", "label": "public void unregisterConnectivityDiagnosticsCallback(@NonNull ConnectivityDiagnosticsCallback callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unregisters a ConnectivityDiagnosticsCallback with the System.\\n     *\\n     * \u003cp\u003eIf the given callback is not currently registered with the System, this operation will be\\n     * a no-op.\\n     *\\n     * @param callback The ConnectivityDiagnosticsCallback to be unregistered from the System.\\n     \u0027}"}, {"color": "#97c2fc", "id": "onCapabilitiesChanged(Network", "label": "onCapabilitiesChanged(Network", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "onAvailable(Network)", "label": "onAvailable(Network)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "registerNetworkCallback", "label": "registerNetworkCallback", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "unregisterNetworkCallback(NetworkCallback)", "label": "unregisterNetworkCallback(NetworkCallback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "label": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.\\n     *\\n     * This method behaves identically to {@link #requestNetwork(NetworkRequest, NetworkCallback)}\\n     * but runs all the callbacks on the passed Handler.\\n     *\\n     * \u003cp\u003eThis method has the same permission requirements as\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback)}, is subject to the same limitations,\\n     * and throws the same exceptions in the same conditions.\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note\\n     *                        the callback must not be shared - it uniquely specifies this request.\\n     * @param handler {@link Handler} to specify the thread upon which the callback will be invoked.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "label": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}, limited\\n     * by a timeout.\\n     *\\n     * This function behaves identically to the non-timed-out version\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback)}, but if a suitable network\\n     * is not found within the given time (in milliseconds) the\\n     * {@link NetworkCallback#onUnavailable()} callback is called. The request can still be\\n     * released normally by calling {@link #unregisterNetworkCallback(NetworkCallback)} but does\\n     * not have to be released if timed-out (it is automatically released). Unregistering a\\n     * request that timed out is not an error.\\n     *\\n     * \u003cp\u003eDo not use this method to poll for the existence of specific networks (e.g. with a small\\n     * timeout) - {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} is provided\\n     * for that purpose. Calling this method will attempt to bring up the requested network.\\n     *\\n     * \u003cp\u003eThis method has the same permission requirements as\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback)}, is subject to the same limitations,\\n     * and throws the same exceptions in the same conditions.\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note\\n     *                        the callback must not be shared - it uniquely specifies this request.\\n     * @param timeoutMs The time in milliseconds to attempt looking for a suitable network\\n     *                  before {@link NetworkCallback#onUnavailable()} is called. The timeout must\\n     *                  be a positive value (i.e. \u003e0).\\n     \u0027}"}, {"color": "#97c2fc", "id": "registerNetworkCallback(NetworkRequest", "label": "registerNetworkCallback(NetworkRequest", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "label": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}, limited\\n     * by a timeout.\\n     *\\n     * This method behaves identically to\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback, int)} but runs all the callbacks\\n     * on the passed Handler.\\n     *\\n     * \u003cp\u003eThis method has the same permission requirements as\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback)}, is subject to the same limitations,\\n     * and throws the same exceptions in the same conditions.\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param networkCallback The {@link NetworkCallback} to be utilized for this request. Note\\n     *                        the callback must not be shared - it uniquely specifies this request.\\n     * @param handler {@link Handler} to specify the thread upon which the callback will be invoked.\\n     * @param timeoutMs The time in milliseconds to attempt looking for a suitable network\\n     *                  before {@link NetworkCallback#onUnavailable} is called.\\n     \u0027}"}, {"color": "#97c2fc", "id": "onUnavailable", "label": "onUnavailable", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "label": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.\\n     *\\n     * This function behaves identically to the version that takes a NetworkCallback, but instead\\n     * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means\\n     * the request may outlive the calling application and get called back when a suitable\\n     * network is found.\\n     * \u003cp\u003e\\n     * The operation is an Intent broadcast that goes to a broadcast receiver that\\n     * you registered with {@link Context#registerReceiver} or through the\\n     * \u0026lt;receiver\u0026gt; tag in an AndroidManifest.xml file\\n     * \u003cp\u003e\\n     * The operation Intent is delivered with two extras, a {@link Network} typed\\n     * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}\\n     * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing\\n     * the original requests parameters.  It is important to create a new,\\n     * {@link NetworkCallback} based request before completing the processing of the\\n     * Intent to reserve the network or it will be released shortly after the Intent\\n     * is processed.\\n     * \u003cp\u003e\\n     * If there is already a request for this Intent registered (with the equality of\\n     * two Intents defined by {@link Intent#filterEquals}), then it will be removed and\\n     * replaced by this one, effectively releasing the previous {@link NetworkRequest}.\\n     * \u003cp\u003e\\n     * The request may be released normally by calling\\n     * {@link #releaseNetworkRequest(android.app.PendingIntent)}.\\n     * \u003cp\u003eIt is presently unsupported to request a network with either\\n     * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or\\n     * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}\\n     * as these {@code NetworkCapabilities} represent states that a particular\\n     * network may never attain, and whether a network will attain these states\\n     * is unknown prior to bringing up the network so the framework does not\\n     * know how to go about satisfying a request with these capabilities.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #registerNetworkCallback} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with {@link #unregisterNetworkCallback(PendingIntent)}\\n     * or {@link #releaseNetworkRequest(PendingIntent)}.\\n     *\\n     * \u003cp\u003eThis method requires the caller to hold either the\\n     * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission\\n     * or the ability to modify system settings as determined by\\n     * {@link android.provider.Settings.System#canWrite}.\u003c/p\u003e\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param operation Action to perform when the network is available (corresponds\\n     *                  to the {@link NetworkCallback#onAvailable} call.  Typically\\n     *                  comes from {@link PendingIntent#getBroadcast}. Cannot be null.\\n     * @throws IllegalArgumentException if {@code request} contains invalid network capabilities.\\n     * @throws SecurityException if missing the appropriate permissions.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "releaseNetworkRequest(android.app.PendingIntent)", "label": "releaseNetworkRequest(android.app.PendingIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "releaseNetworkRequest(PendingIntent)", "label": "releaseNetworkRequest(PendingIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "registerReceiver", "label": "registerReceiver", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.content.Context", "label": "android.content.Context", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Proxying implementation of Context that simply delegates all of its calls to\\n * another Context.  Can be subclassed to modify behavior without changing\\n * the original Context.\\n \u0027}"}, {"color": "#97c2fc", "id": "protected void attachBaseContext(Context base)", "label": "protected void attachBaseContext(Context base)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the base context for this ContextWrapper.  All calls will then be\\n     * delegated to the base context.  Throws\\n     * IllegalStateException if a base context has already been set.\\n     *\\n     * @param base The new base context for this wrapper.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Context getBaseContext()", "label": "public Context getBaseContext()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the base context as set by the constructor or setBaseContext\\n     \u0027}"}, {"color": "#97c2fc", "id": "onAvailable", "label": "onAvailable", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "unregisterNetworkCallback(PendingIntent)", "label": "unregisterNetworkCallback(PendingIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "EXTRA_NETWORK_REQUEST", "label": "EXTRA_NETWORK_REQUEST", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "EXTRA_NETWORK", "label": "EXTRA_NETWORK", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void releaseNetworkRequest(@NonNull PendingIntent operation)", "label": "public void releaseNetworkRequest(@NonNull PendingIntent operation)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}\\n     * \u003cp\u003e\\n     * This method has the same behavior as\\n     * {@link #unregisterNetworkCallback(android.app.PendingIntent)} with respect to\\n     * releasing network resources and disconnecting.\\n     *\\n     * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the\\n     *                  PendingIntent passed to\\n     *                  {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the\\n     *                  corresponding NetworkRequest you\u0027d like to remove. Cannot be null.\\n     \"}"}, {"color": "#97c2fc", "id": "unregisterNetworkCallback(android.app.PendingIntent)", "label": "unregisterNetworkCallback(android.app.PendingIntent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "label": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers to receive notifications about all networks which satisfy the given\\n     * {@link NetworkRequest}.  The callbacks will continue to be called until\\n     * either the application exits or {@link #unregisterNetworkCallback(NetworkCallback)} is\\n     * called.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #requestNetwork} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with\\n     * {@link #unregisterNetworkCallback(NetworkCallback)}.\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param networkCallback The {@link NetworkCallback} that the system will call as suitable\\n     *                        networks change state.\\n     *                        The callback is invoked on the default internal Handler.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "requestNetwork", "label": "requestNetwork", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "label": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers to receive notifications about all networks which satisfy the given\\n     * {@link NetworkRequest}.  The callbacks will continue to be called until\\n     * either the application exits or {@link #unregisterNetworkCallback(NetworkCallback)} is\\n     * called.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #requestNetwork} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with\\n     * {@link #unregisterNetworkCallback(NetworkCallback)}.\\n     *\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param networkCallback The {@link NetworkCallback} that the system will call as suitable\\n     *                        networks change state.\\n     * @param handler {@link Handler} to specify the thread upon which the callback will be invoked.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "label": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers a PendingIntent to be sent when a network is available which satisfies the given\\n     * {@link NetworkRequest}.\\n     *\\n     * This function behaves identically to the version that takes a NetworkCallback, but instead\\n     * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means\\n     * the request may outlive the calling application and get called back when a suitable\\n     * network is found.\\n     * \u003cp\u003e\\n     * The operation is an Intent broadcast that goes to a broadcast receiver that\\n     * you registered with {@link Context#registerReceiver} or through the\\n     * \u0026lt;receiver\u0026gt; tag in an AndroidManifest.xml file\\n     * \u003cp\u003e\\n     * The operation Intent is delivered with two extras, a {@link Network} typed\\n     * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}\\n     * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing\\n     * the original requests parameters.\\n     * \u003cp\u003e\\n     * If there is already a request for this Intent registered (with the equality of\\n     * two Intents defined by {@link Intent#filterEquals}), then it will be removed and\\n     * replaced by this one, effectively releasing the previous {@link NetworkRequest}.\\n     * \u003cp\u003e\\n     * The request may be released normally by calling\\n     * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #requestNetwork} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with {@link #unregisterNetworkCallback(PendingIntent)}\\n     * or {@link #releaseNetworkRequest(PendingIntent)}.\\n     *\\n     * @param request {@link NetworkRequest} describing this request.\\n     * @param operation Action to perform when the network is available (corresponds\\n     *                  to the {@link NetworkCallback#onAvailable} call.  Typically\\n     *                  comes from {@link PendingIntent#getBroadcast}. Cannot be null.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)", "label": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers to receive notifications about changes in the system default network. The callbacks\\n     * will continue to be called until either the application exits or\\n     * {@link #unregisterNetworkCallback(NetworkCallback)} is called.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #requestNetwork} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with\\n     * {@link #unregisterNetworkCallback(NetworkCallback)}.\\n     *\\n     * @param networkCallback The {@link NetworkCallback} that the system will call as the\\n     *                        system default network changes.\\n     *                        The callback is invoked on the default internal Handler.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "label": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers to receive notifications about changes in the system default network. The callbacks\\n     * will continue to be called until either the application exits or\\n     * {@link #unregisterNetworkCallback(NetworkCallback)} is called.\\n     *\\n     * \u003cp\u003eTo avoid performance issues due to apps leaking callbacks, the system will limit the\\n     * number of outstanding requests to 100 per app (identified by their UID), shared with\\n     * all variants of this method, of {@link #requestNetwork} as well as\\n     * {@link ConnectivityDiagnosticsManager#registerConnectivityDiagnosticsCallback}.\\n     * Requesting a network with this method will count toward this limit. If this limit is\\n     * exceeded, an exception will be thrown. To avoid hitting this issue and to conserve resources,\\n     * make sure to unregister the callbacks with\\n     * {@link #unregisterNetworkCallback(NetworkCallback)}.\\n     *\\n     * @param networkCallback The {@link NetworkCallback} that the system will call as the\\n     *                        system default network changes.\\n     * @param handler {@link Handler} to specify the thread upon which the callback will be invoked.\\n     * @throws RuntimeException if the app already has too many callbacks registered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean requestBandwidthUpdate(@NonNull Network network)", "label": "public boolean requestBandwidthUpdate(@NonNull Network network)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Requests bandwidth update for a given {@link Network} and returns whether the update request\\n     * is accepted by ConnectivityService. Once accepted, ConnectivityService will poll underlying\\n     * network connection for updated bandwidth information. The caller will be notified via\\n     * {@link ConnectivityManager.NetworkCallback} if there is an update. Notice that this\\n     * method assumes that the caller has previously called\\n     * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} to listen for network\\n     * changes.\\n     *\\n     * @param network {@link Network} specifying which network you\u0027re interested.\\n     * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.\\n     \"}"}, {"color": "#97c2fc", "id": "ConnectivityManager.NetworkCallback", "label": "ConnectivityManager.NetworkCallback", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback)", "label": "public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unregisters a {@code NetworkCallback} and possibly releases networks originating from\\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and\\n     * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.\\n     * If the given {@code NetworkCallback} had previously been used with\\n     * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request\\n     * will be disconnected.\\n     *\\n     * Notifications that would have triggered that {@code NetworkCallback} will immediately stop\\n     * triggering it as soon as this call returns.\\n     *\\n     * @param networkCallback The {@link NetworkCallback} used when making the request.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void unregisterNetworkCallback(@NonNull PendingIntent operation)", "label": "public void unregisterNetworkCallback(@NonNull PendingIntent operation)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unregisters a callback previously registered via\\n     * {@link #registerNetworkCallback(NetworkRequest, android.app.PendingIntent)}.\\n     *\\n     * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the\\n     *                  PendingIntent passed to\\n     *                  {@link #registerNetworkCallback(NetworkRequest, android.app.PendingIntent)}.\\n     *                  Cannot be null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getMultipathPreference(@Nullable Network network)", "label": "public int getMultipathPreference(@Nullable Network network)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Provides a hint to the calling application on whether it is desirable to use the\\n     * multinetwork APIs (e.g., {@link Network#openConnection}, {@link Network#bindSocket}, etc.)\\n     * for multipath data transfer on this network when it is not the system default network.\\n     * Applications desiring to use multipath network protocols should call this method before\\n     * each such operation.\\n     *\\n     * @param network The network on which the application desires to use multipath data.\\n     *                If {@code null}, this method will return the a preference that will generally\\n     *                apply to metered networks.\\n     * @return a bitwise OR of zero or more of the  {@code MULTIPATH_PREFERENCE_*} constants.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean bindProcessToNetwork(@Nullable Network network)", "label": "public boolean bindProcessToNetwork(@Nullable Network network)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Binds the current process to {@code network}.  All Sockets created in the future\\n     * (and not explicitly bound via a bound SocketFactory from\\n     * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to\\n     * {@code network}.  All host name resolutions will be limited to {@code network} as well.\\n     * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to\\n     * work and all host name resolutions will fail.  This is by design so an application doesn\u0027t\\n     * accidentally use Sockets it thinks are still bound to a particular {@link Network}.\\n     * To clear binding pass {@code null} for {@code network}.  Using individually bound\\n     * Sockets created by Network.getSocketFactory().createSocket() and\\n     * performing network-specific host name resolutions via\\n     * {@link Network#getAllByName Network.getAllByName} is preferred to calling\\n     * {@code bindProcessToNetwork}.\\n     *\\n     * @param network The {@link Network} to bind the current process to, or {@code null} to clear\\n     *                the current binding.\\n     * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.\\n     \"}"}, {"color": "#97c2fc", "id": "public Network getBoundNetworkForProcess()", "label": "public Network getBoundNetworkForProcess()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@link Network} currently bound to this process via\\n     * {@link #bindProcessToNetwork}, or {@code null} if no {@link Network} is explicitly bound.\\n     *\\n     * @return {@code Network} to which this process is bound, or {@code null}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void checkLegacyRoutingApiAccess()", "label": "private void checkLegacyRoutingApiAccess()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 so is unsupported and may break in the future. http://b/22728205\u0027}"}, {"color": "#97c2fc", "id": "public int getRestrictBackgroundStatus()", "label": "public int getRestrictBackgroundStatus()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the calling application is subject to metered network restrictions while\\n     * running on background.\\n     *\\n     * @return {@link #RESTRICT_BACKGROUND_STATUS_DISABLED},\\n     * {@link #RESTRICT_BACKGROUND_STATUS_ENABLED},\\n     * or {@link #RESTRICT_BACKGROUND_STATUS_WHITELISTED}\\n     \u0027}"}, {"color": "#97c2fc", "id": "RESTRICT_BACKGROUND_STATUS_ENABLED", "label": "RESTRICT_BACKGROUND_STATUS_ENABLED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "RESTRICT_BACKGROUND_STATUS_DISABLED", "label": "RESTRICT_BACKGROUND_STATUS_DISABLED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "RESTRICT_BACKGROUND_STATUS_WHITELISTED", "label": "RESTRICT_BACKGROUND_STATUS_WHITELISTED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public byte[] getNetworkWatchlistConfigHash()", "label": "public byte[] getNetworkWatchlistConfigHash()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The network watchlist is a list of domains and IP addresses that are associated with\\n     * potentially harmful apps. This method returns the SHA-256 of the watchlist config file\\n     * currently used by the system for validation purposes.\\n     *\\n     * @return Hash of network watchlist config file. Null if config does not exist.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)", "label": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the {@code uid} of the owner of a network connection.\\n     *\\n     * @param protocol The protocol of the connection. Only {@code IPPROTO_TCP} and {@code\\n     *     IPPROTO_UDP} currently supported.\\n     * @param local The local {@link InetSocketAddress} of a connection.\\n     * @param remote The remote {@link InetSocketAddress} of a connection.\\n     * @return {@code uid} if the connection is found and the app has permission to observe it\\n     *     (e.g., if it is associated with the calling VPN app\u0027s VpnService tunnel) or {@link\\n     *     android.os.Process#INVALID_UID} if the connection is not found.\\n     * @throws {@link SecurityException} if the caller is not the active VpnService for the current\\n     *     user.\\n     * @throws {@link IllegalArgumentException} if an unsupported protocol is requested.\\n     \"}"}, {"color": "#97c2fc", "id": "INVALID_UID", "label": "INVALID_UID", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.os.Process", "label": "android.os.Process", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Tools for managing OS processes.\\n \u0027}"}, {"color": "#97c2fc", "id": "public static final native long getElapsedCpuTime()", "label": "public static final native long getElapsedCpuTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns elapsed milliseconds of the time this process has run.\\n     * @return  Returns the number of milliseconds this process has return.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final long getStartElapsedRealtime()", "label": "public static final long getStartElapsedRealtime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the {@link SystemClock#elapsedRealtime()} at which this process was started.\\n     \u0027}"}, {"color": "#97c2fc", "id": "elapsedRealtime()", "label": "elapsedRealtime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.os.SystemClock", "label": "android.os.SystemClock", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Core timekeeping facilities.\\n *\\n * \u003cp\u003e Three different clocks are available, and they should not be confused:\\n *\\n * \u003cul\u003e\\n *     \u003cli\u003e \u003cp\u003e {@link System#currentTimeMillis System.currentTimeMillis()}\\n *     is the standard \"wall\" clock (time and date) expressing milliseconds\\n *     since the epoch.  The wall clock can be set by the user or the phone\\n *     network (see {@link #setCurrentTimeMillis}), so the time may jump\\n *     backwards or forwards unpredictably.  This clock should only be used\\n *     when correspondence with real-world dates and times is important, such\\n *     as in a calendar or alarm clock application.  Interval or elapsed\\n *     time measurements should use a different clock.  If you are using\\n *     System.currentTimeMillis(), consider listening to the\\n *     {@link android.content.Intent#ACTION_TIME_TICK ACTION_TIME_TICK},\\n *     {@link android.content.Intent#ACTION_TIME_CHANGED ACTION_TIME_CHANGED}\\n *     and {@link android.content.Intent#ACTION_TIMEZONE_CHANGED\\n *     ACTION_TIMEZONE_CHANGED} {@link android.content.Intent Intent}\\n *     broadcasts to find out when the time changes.\\n *\\n *     \u003cli\u003e \u003cp\u003e {@link #uptimeMillis} is counted in milliseconds since the\\n *     system was booted.  This clock stops when the system enters deep\\n *     sleep (CPU off, display dark, device waiting for external input),\\n *     but is not affected by clock scaling, idle, or other power saving\\n *     mechanisms.  This is the basis for most interval timing\\n *     such as {@link Thread#sleep(long) Thread.sleep(millls)},\\n *     {@link Object#wait(long) Object.wait(millis)}, and\\n *     {@link System#nanoTime System.nanoTime()}.  This clock is guaranteed\\n *     to be monotonic, and is suitable for interval timing when the\\n *     interval does not span device sleep.  Most methods that accept a\\n *     timestamp value currently expect the {@link #uptimeMillis} clock.\\n *\\n *     \u003cli\u003e \u003cp\u003e {@link #elapsedRealtime} and {@link #elapsedRealtimeNanos}\\n *     return the time since the system was booted, and include deep sleep.\\n *     This clock is guaranteed to be monotonic, and continues to tick even\\n *     when the CPU is in power saving modes, so is the recommend basis\\n *     for general purpose interval timing.\\n *\\n * \u003c/ul\u003e\\n *\\n * There are several mechanisms for controlling the timing of events:\\n *\\n * \u003cul\u003e\\n *     \u003cli\u003e \u003cp\u003e Standard functions like {@link Thread#sleep(long)\\n *     Thread.sleep(millis)} and {@link Object#wait(long) Object.wait(millis)}\\n *     are always available.  These functions use the {@link #uptimeMillis}\\n *     clock; if the device enters sleep, the remainder of the time will be\\n *     postponed until the device wakes up.  These synchronous functions may\\n *     be interrupted with {@link Thread#interrupt Thread.interrupt()}, and\\n *     you must handle {@link InterruptedException}.\\n *\\n *     \u003cli\u003e \u003cp\u003e {@link #sleep SystemClock.sleep(millis)} is a utility function\\n *     very similar to {@link Thread#sleep(long) Thread.sleep(millis)}, but it\\n *     ignores {@link InterruptedException}.  Use this function for delays if\\n *     you do not use {@link Thread#interrupt Thread.interrupt()}, as it will\\n *     preserve the interrupted state of the thread.\\n *\\n *     \u003cli\u003e \u003cp\u003e The {@link android.os.Handler} class can schedule asynchronous\\n *     callbacks at an absolute or relative time.  Handler objects also use the\\n *     {@link #uptimeMillis} clock, and require an {@link android.os.Looper\\n *     event loop} (normally present in any GUI application).\\n *\\n *     \u003cli\u003e \u003cp\u003e The {@link android.app.AlarmManager} can trigger one-time or\\n *     recurring events which occur even when the device is in deep sleep\\n *     or your application is not running.  Events may be scheduled with your\\n *     choice of {@link java.lang.System#currentTimeMillis} (RTC) or\\n *     {@link #elapsedRealtime} (ELAPSED_REALTIME), and cause an\\n *     {@link android.content.Intent} broadcast when they occur.\\n * \u003c/ul\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": "public static void sleep(long ms)", "label": "public static void sleep(long ms)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Waits a given number of milliseconds (of uptimeMillis) before returning.\\n     * Similar to {@link java.lang.Thread#sleep(long)}, but does not throw\\n     * {@link InterruptedException}; {@link Thread#interrupt()} events are\\n     * deferred until the next interruptible operation.  Does not return until\\n     * at least the specified number of milliseconds has elapsed.\\n     *\\n     * @param ms to sleep before returning, in milliseconds of uptime.\\n     \u0027}"}, {"color": "#97c2fc", "id": "interrupt()", "label": "interrupt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "sleep(long)", "label": "sleep(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "InterruptedException", "label": "InterruptedException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static boolean setCurrentTimeMillis(long millis)", "label": "public static boolean setCurrentTimeMillis(long millis)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the current wall time, in milliseconds.  Requires the calling\\n     * process to have appropriate permissions.\\n     *\\n     * @return if the clock was successfully set to the specified time.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long uptimeMillis()", "label": "public static native long uptimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns milliseconds since boot, not counting time spent in deep sleep.\\n     *\\n     * @return milliseconds of non-sleep uptime since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long elapsedRealtime()", "label": "public static native long elapsedRealtime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns milliseconds since boot, including time spent in sleep.\\n     *\\n     * @return elapsed milliseconds since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long elapsedRealtimeNanos()", "label": "public static native long elapsedRealtimeNanos()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns nanoseconds since boot, including time spent in sleep.\\n     *\\n     * @return elapsed nanoseconds since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long currentThreadTimeMillis()", "label": "public static native long currentThreadTimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns milliseconds running in the current thread.\\n     *\\n     * @return elapsed milliseconds in the thread\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Clock currentGnssTimeClock()", "label": "public static Clock currentGnssTimeClock()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@link Clock} that starts at January 1, 1970 00:00:00.0 UTC,\\n     * synchronized using the device\u0027s location provider.\\n     *\\n     * @throws DateTimeException when the location provider has not had a location fix since boot.\\n     \"}"}, {"color": "#97c2fc", "id": "java.time.Clock", "label": "java.time.Clock", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static final long getStartUptimeMillis()", "label": "public static final long getStartUptimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the {@link SystemClock#uptimeMillis()} at which this process was started.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean is64Bit()", "label": "public static final boolean is64Bit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the current process is a 64-bit runtime.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final int myPid()", "label": "public static final int myPid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the identifier of this process, which can be used with\\n     * {@link #killProcess} and {@link #sendSignal}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "killProcess", "label": "killProcess", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "sendSignal", "label": "sendSignal", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static final int myTid()", "label": "public static final int myTid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the identifier of the calling thread, which be used with\\n     * {@link #setThreadPriority(int, int)}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "setThreadPriority(int", "label": "setThreadPriority(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static final int myUid()", "label": "public static final int myUid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the identifier of this process\u0027s uid.  This is the kernel uid\\n     * that the process is running under, which is the identity of its\\n     * app-specific sandbox.  It is different from {@link #myUserHandle} in that\\n     * a uid identifies a specific app sandbox in a specific user.\\n     \"}"}, {"color": "#97c2fc", "id": "myUserHandle", "label": "myUserHandle", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static UserHandle myUserHandle()", "label": "public static UserHandle myUserHandle()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this process\u0027s user handle.  This is the\\n     * user the process is running under.  It is distinct from\\n     * {@link #myUid()} in that a particular user will have multiple\\n     * distinct apps running under it each with their own uid.\\n     \"}"}, {"color": "#97c2fc", "id": "myUid()", "label": "myUid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isApplicationUid(int uid)", "label": "public static boolean isApplicationUid(int uid)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether the given uid belongs to an application.\\n     * @param uid A kernel uid.\\n     * @return Whether the uid corresponds to an application sandbox running in\\n     *     a specific user.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean isIsolated()", "label": "public static final boolean isIsolated()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether the current process is in an isolated sandbox.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final native int getUidForName(String name)", "label": "public static final native int getUidForName(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the UID assigned to a particular user name, or -1 if there is\\n     * none.  If the given string consists of only numbers, it is converted\\n     * directly to a uid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final native int getGidForName(String name)", "label": "public static final native int getGidForName(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the GID assigned to a particular user name, or -1 if there is\\n     * none.  If the given string consists of only numbers, it is converted\\n     * directly to a gid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final native void setThreadPriority(int tid, int priority) throws IllegalArgumentException, SecurityException", "label": "public static final native void setThreadPriority(int tid, int priority) throws IllegalArgumentException, SecurityException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the priority of a thread, based on Linux priorities.\\n     *\\n     * @param tid The identifier of the thread/process to change. It should be\\n     * the native thread id but not the managed id of {@link java.lang.Thread}.\\n     * @param priority A Linux priority level, from -20 for highest scheduling\\n     * priority to 19 for lowest scheduling priority.\\n     *\\n     * @throws IllegalArgumentException Throws IllegalArgumentException if\\n     * \u003cvar\u003etid\u003c/var\u003e does not exist.\\n     * @throws SecurityException Throws SecurityException if your process does\\n     * not have permission to modify the given thread, or to use the given\\n     * priority.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.Thread", "label": "java.lang.Thread", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static final native int[] getExclusiveCores()", "label": "public static final native int[] getExclusiveCores()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * On some devices, the foreground process may have one or more CPU\\n     * cores exclusively reserved for it. This method can be used to\\n     * retrieve which cores that are (if any), so the calling process\\n     * can then use sched_setaffinity() to lock a thread to these cores.\\n     * Note that the calling process must currently be running in the\\n     * foreground for this method to return any cores.\\n     *\\n     * The CPU core(s) exclusively reserved for the foreground process will\\n     * stay reserved for as long as the process stays in the foreground.\\n     *\\n     * As soon as a process leaves the foreground, those CPU cores will\\n     * no longer be reserved for it, and will most likely be reserved for\\n     * the new foreground process. It\u0027s not necessary to change the affinity\\n     * of your process when it leaves the foreground (if you had previously\\n     * set it to use a reserved core); the OS will automatically take care\\n     * of resetting the affinity at that point.\\n     *\\n     * @return an array of integers, indicating the CPU cores exclusively\\n     * reserved for this process. The array will have length zero if no\\n     * CPU cores are exclusively reserved for this process at this point\\n     * in time.\\n     \"}"}, {"color": "#97c2fc", "id": "public static final native void setThreadPriority(int priority) throws IllegalArgumentException, SecurityException", "label": "public static final native void setThreadPriority(int priority) throws IllegalArgumentException, SecurityException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the priority of the calling thread, based on Linux priorities.  See\\n     * {@link #setThreadPriority(int, int)} for more information.\\n     * \\n     * @param priority A Linux priority level, from -20 for highest scheduling\\n     * priority to 19 for lowest scheduling priority.\\n     * \\n     * @throws IllegalArgumentException Throws IllegalArgumentException if\\n     * \u003cvar\u003etid\u003c/var\u003e does not exist.\\n     * @throws SecurityException Throws SecurityException if your process does\\n     * not have permission to modify the given thread, or to use the given\\n     * priority.\\n     * \\n     * @see #setThreadPriority(int, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final native int getThreadPriority(int tid) throws IllegalArgumentException", "label": "public static final native int getThreadPriority(int tid) throws IllegalArgumentException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the current priority of a thread, based on Linux priorities.\\n     * \\n     * @param tid The identifier of the thread/process. If tid equals zero, the priority of the\\n     * calling process/thread will be returned.\\n     * \\n     * @return Returns the current priority, as a Linux priority level,\\n     * from -20 for highest scheduling priority to 19 for lowest scheduling\\n     * priority.\\n     * \\n     * @throws IllegalArgumentException Throws IllegalArgumentException if\\n     * \u003cvar\u003etid\u003c/var\u003e does not exist.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final void killProcess(int pid)", "label": "public static final void killProcess(int pid)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Kill the process with the given PID.\\n     * Note that, though this API allows us to request to\\n     * kill any process based on its PID, the kernel will\\n     * still impose standard restrictions on which PIDs you\\n     * are actually able to kill.  Typically this means only\\n     * the process running the caller\u0027s packages/application\\n     * and any additional processes created by that app; packages\\n     * sharing a common UID will also be able to kill each\\n     * other\u0027s processes.\\n     \"}"}, {"color": "#97c2fc", "id": "public static final native void sendSignal(int pid, int signal)", "label": "public static final native void sendSignal(int pid, int signal)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send a signal to the given process.\\n     * \\n     * @param pid The pid of the target process.\\n     * @param signal The signal to send.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.InetSocketAddress", "label": "java.net.InetSocketAddress", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public boolean isDataRoamingEnabled()", "label": "public boolean isDataRoamingEnabled()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether mobile data roaming is enabled on the subscription.\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultDataSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires one of the following permissions:\\n     * {@link android.Manifest.permission#ACCESS_NETWORK_STATE},\\n     * {@link android.Manifest.permission#READ_PHONE_STATE} or that the calling app\\n     * has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return {@code true} if the data roaming is enabled on the subscription, otherwise return\\n     * {@code false}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean canChangeDtmfToneLength()", "label": "public boolean canChangeDtmfToneLength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Whether the device supports configuring the DTMF tone length.\\n     *\\n     * @return {@code true} if the DTMF tone length can be changed, and {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isWorldPhone()", "label": "public boolean isWorldPhone()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Whether the device is a world phone.\\n     *\\n     * @return {@code true} if the device is a world phone, and {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isRttSupported()", "label": "public boolean isRttSupported()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the device currently supports RTT (Real-time text). Based both on carrier\\n     * support for the feature and device firmware support.\\n     *\\n     * @return {@code true} if the device and carrier both support RTT, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isHearingAidCompatibilitySupported()", "label": "public boolean isHearingAidCompatibilitySupported()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Whether the phone supports hearing aid compatibility.\\n     *\\n     * @return {@code true} if the device supports hearing aid compatibility, and {@code false}\\n     * otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)", "label": "public int getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the subscription ID for the given phone account handle.\\n     *\\n     * @param phoneAccountHandle the phone account handle for outgoing calls\\n     * @return subscription ID for the given phone account handle; or\\n     *         {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}\\n     *         if not available; or throw a SecurityException if the caller doesn\u0027t have the\\n     *         permission.\\n     \"}"}, {"color": "#97c2fc", "id": "public ServiceState getServiceState()", "label": "public ServiceState getServiceState()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the current {@link ServiceState} information.\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges})\\n     * and {@link android.Manifest.permission#ACCESS_COARSE_LOCATION}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "ACCESS_COARSE_LOCATION", "label": "ACCESS_COARSE_LOCATION", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Uri getVoicemailRingtoneUri(PhoneAccountHandle accountHandle)", "label": "public Uri getVoicemailRingtoneUri(PhoneAccountHandle accountHandle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the URI for the per-account voicemail ringtone set in Phone settings.\\n     *\\n     * @param accountHandle The handle for the {@link PhoneAccount} for which to retrieve the\\n     * voicemail ringtone.\\n     * @return The URI for the ringtone to play when receiving a voicemail from a specific\\n     * PhoneAccount.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.telecom.PhoneAccount", "label": "android.telecom.PhoneAccount", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The unique identifier for a {@link PhoneAccount}. A {@code PhoneAccountHandle} is made of two\\n * parts:\\n * \u003cul\u003e\\n *  \u003cli\u003eThe component name of the associated connection service.\u003c/li\u003e\\n *  \u003cli\u003eA string identifier that is unique across {@code PhoneAccountHandle}s with the same\\n *      component name.\u003c/li\u003e\\n * \u003c/ul\u003e\\n *\\n * Note: This Class requires a non-null {@link ComponentName} and {@link UserHandle} to operate\\n * properly. Passing in invalid parameters will generate a log warning.\\n *\\n * See {@link PhoneAccount}, {@link TelecomManager}.\\n \u0027}"}, {"color": "#97c2fc", "id": "public ComponentName getComponentName()", "label": "public ComponentName getComponentName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The {@code ComponentName} of the connection service which is responsible for making phone\\n     * calls using this {@code PhoneAccountHandle}.\\n     *\\n     * @return A suitable {@code ComponentName}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getId()", "label": "public String getId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * A string that uniquely distinguishes this particular {@code PhoneAccountHandle} from all the\\n     * others supported by the connection service that created it.\\n     * \u003cp\u003e\\n     * A connection service must select identifiers that are stable for the lifetime of\\n     * their users\u0027 relationship with their service, across many Android devices. For example, a\\n     * good set of identifiers might be the email addresses with which with users registered for\\n     * their accounts with a particular service. Depending on how a service chooses to operate,\\n     * a bad set of identifiers might be an increasing series of integers\\n     * ({@code 0}, {@code 1}, {@code 2}, ...) that are generated locally on each phone and could\\n     * collide with values generated on other phones or after a data wipe of a given phone.\\n     *\\n     * Important: A non-unique identifier could cause non-deterministic call-log backup/restore\\n     * behavior.\\n     *\\n     * @return A service-specific unique identifier for this {@code PhoneAccountHandle}.\\n     \"}"}, {"color": "#97c2fc", "id": "public UserHandle getUserHandle()", "label": "public UserHandle getUserHandle()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return the {@link UserHandle} to use when connecting to this PhoneAccount.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.os.UserHandle", "label": "android.os.UserHandle", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Representation of a user on the device.\\n \u0027}"}, {"color": "#97c2fc", "id": "public static UserHandle getUserHandleForUid(int uid)", "label": "public static UserHandle getUserHandleForUid(int uid)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the user for a given uid.\\n     * @param uid A uid for an application running in a particular user.\\n     * @return A {@link UserHandle} for that user.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void writeToParcel(UserHandle h, Parcel out)", "label": "public static void writeToParcel(UserHandle h, Parcel out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a UserHandle to a Parcel, handling null pointers.  Must be\\n     * read with {@link #readFromParcel(Parcel)}.\\n     *\\n     * @param h The UserHandle to be written.\\n     * @param out The Parcel in which the UserHandle will be placed.\\n     *\\n     * @see #readFromParcel(Parcel)\\n     \u0027}"}, {"color": "#97c2fc", "id": "readFromParcel(Parcel)", "label": "readFromParcel(Parcel)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static UserHandle readFromParcel(Parcel in)", "label": "public static UserHandle readFromParcel(Parcel in)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read a UserHandle from a Parcel that was previously written\\n     * with {@link #writeToParcel(UserHandle, Parcel)}, returning either\\n     * a null or new object as appropriate.\\n     *\\n     * @param in The Parcel from which to read the UserHandle\\n     * @return Returns a new UserHandle matching the previously written\\n     * object, or null if a null had been written.\\n     *\\n     * @see #writeToParcel(UserHandle, Parcel)\\n     \u0027}"}, {"color": "#97c2fc", "id": "writeToParcel(UserHandle", "label": "writeToParcel(UserHandle", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isVoicemailVibrationEnabled(PhoneAccountHandle accountHandle)", "label": "public boolean isVoicemailVibrationEnabled(PhoneAccountHandle accountHandle)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether vibration is set for voicemail notification in Phone settings.\\n     *\\n     * @param accountHandle The handle for the {@link PhoneAccount} for which to retrieve the\\n     * voicemail vibration setting.\\n     * @return {@code true} if the vibration is set for this PhoneAccount, {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSimCarrierId()", "label": "public int getSimCarrierId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns carrier id of the current subscription.\\n     * \u003cp\u003eTo recognize a carrier (including MVNO) as a first-class identity, Android assigns each\\n     * carrier with a canonical integer a.k.a. carrier id. The carrier ID is an Android\\n     * platform-wide identifier for a carrier. AOSP maintains carrier ID assignments in\\n     * \u003ca href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\"\u003ehere\u003c/a\u003e\\n     *\\n     * \u003cp\u003eApps which have carrier-specific configurations or business logic can use the carrier id\\n     * as an Android platform-wide identifier for carriers.\\n     *\\n     * @return Carrier id of the current subscription. Return {@link #UNKNOWN_CARRIER_ID} if the\\n     * subscription is unavailable or the carrier cannot be identified.\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNKNOWN_CARRIER_ID", "label": "UNKNOWN_CARRIER_ID", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getSimCarrierIdName()", "label": "public CharSequence getSimCarrierIdName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns carrier id name of the current subscription.\\n     * \u003cp\u003eCarrier id name is a user-facing name of carrier id returned by\\n     * {@link #getSimCarrierId()}, usually the brand name of the subsidiary\\n     * (e.g. T-Mobile). Each carrier could configure multiple {@link #getSimOperatorName() SPN} but\\n     * should have a single carrier name. Carrier name is not a canonical identity,\\n     * use {@link #getSimCarrierId()} instead.\\n     * \u003cp\u003eThe returned carrier name is unlocalized.\\n     *\\n     * @return Carrier name of the current subscription. Return {@code null} if the subscription is\\n     * unavailable or the carrier cannot be identified.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSimOperatorName()", "label": "getSimOperatorName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getSimCarrierId()", "label": "getSimCarrierId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getSimSpecificCarrierId()", "label": "public int getSimSpecificCarrierId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns fine-grained carrier ID of the current subscription.\\n     *\\n     * A specific carrier ID can represent the fact that a carrier may be in effect an aggregation\\n     * of other carriers (ie in an MVNO type scenario) where each of these specific carriers which\\n     * are used to make up the actual carrier service may have different carrier configurations.\\n     * A specific carrier ID could also be used, for example, in a scenario where a carrier requires\\n     * different carrier configuration for different service offering such as a prepaid plan.\\n     *\\n     * the specific carrier ID would be used for configuration purposes, but apps wishing to know\\n     * about the carrier itself should use the regular carrier ID returned by\\n     * {@link #getSimCarrierId()}.\\n     *\\n     * e.g, Tracfone SIMs could return different specific carrier ID based on IMSI from current\\n     * subscription while carrier ID remains the same.\\n     *\\n     * \u003cp\u003eFor carriers without fine-grained specific carrier ids, return {@link #getSimCarrierId()}\\n     * \u003cp\u003eSpecific carrier ids are defined in the same way as carrier id\\n     * \u003ca href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\"\u003ehere\u003c/a\u003e\\n     * except each with a \"parent\" id linking to its top-level carrier id.\\n     *\\n     * @return Returns fine-grained carrier id of the current subscription.\\n     * Return {@link #UNKNOWN_CARRIER_ID} if the subscription is unavailable or the carrier cannot\\n     * be identified.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public CharSequence getSimSpecificCarrierIdName()", "label": "public CharSequence getSimSpecificCarrierIdName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Similar like {@link #getSimCarrierIdName()}, returns user-facing name of the\\n     * specific carrier id returned by {@link #getSimSpecificCarrierId()}.\\n     *\\n     * The specific carrier ID would be used for configuration purposes, but apps wishing to know\\n     * about the carrier itself should use the regular carrier ID returned by\\n     * {@link #getSimCarrierIdName()}.\\n     *\\n     * \u003cp\u003eThe returned name is unlocalized.\\n     *\\n     * @return user-facing name of the subscription specific carrier id. Return {@code null} if the\\n     * subscription is unavailable or the carrier cannot be identified.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSimCarrierIdName()", "label": "getSimCarrierIdName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getSimSpecificCarrierId()", "label": "getSimSpecificCarrierId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int getCarrierIdFromSimMccMnc()", "label": "public int getCarrierIdFromSimMccMnc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns carrier id based on sim MCCMNC (returned by {@link #getSimOperator()}) only.\\n     * This is used for fallback when configurations/logic for exact carrier id\\n     * {@link #getSimCarrierId()} are not found.\\n     *\\n     * Android carrier id table \u003ca href=\"https://android.googlesource.com/platform/packages/providers/TelephonyProvider/+/master/assets/latest_carrier_id/carrier_list.textpb\"\u003ehere\u003c/a\u003e\\n     * can be updated out-of-band, its possible a MVNO (Mobile Virtual Network Operator) carrier\\n     * was not fully recognized and assigned to its MNO (Mobile Network Operator) carrier id\\n     * by default. After carrier id table update, a new carrier id was assigned. If apps don\\\u0027t\\n     * take the update with the new id, it might be helpful to always fallback by using carrier\\n     * id based on MCCMNC if there is no match.\\n     *\\n     * @return matching carrier id from sim MCCMNC. Return {@link #UNKNOWN_CARRIER_ID} if the\\n     * subscription is unavailable or the carrier cannot be identified.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSimOperator()", "label": "getSimOperator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isManualNetworkSelectionAllowed()", "label": "public boolean isManualNetworkSelectionAllowed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks if manual network selection is allowed.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PRECISE_PHONE_STATE\\n     * READ_PRECISE_PHONE_STATE} or that the calling app has carrier privileges\\n     * (see {@link #hasCarrierPrivileges})\\n     *\\n     * \u003cp\u003eIf this object has been created with {@link #createForSubscriptionId}, applies to the\\n     * given subId. Otherwise, applies to {@link SubscriptionManager#getDefaultSubscriptionId()}.\\n     *\\n     * @return {@code true} if manual network selection is allowed, otherwise return {@code false}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SignalStrength getSignalStrength()", "label": "public SignalStrength getSignalStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the most recently available signal strength information.\\n     *\\n     * Get the most recent SignalStrength information reported by the modem. Due\\n     * to power saving this information may not always be current.\\n     * @return the most recent cached signal strength info from the modem\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()", "label": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the emergency number list based on current locale, sim, default, modem and network.\\n     *\\n     * \u003cp\u003eIn each returned list, the emergency number {@link EmergencyNumber} coming from higher\\n     * priority sources will be located at the smaller index; the priority order of sources are:\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG}\\n     *\\n     * \u003cp\u003eThe subscriptions which the returned list would be based on, are all the active\\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\\n     *\\n     * \u003cp\u003eRequires permission {@link android.Manifest.permission#READ_PHONE_STATE} or the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return Map including the keys as the active subscription IDs (Note: if there is no active\\n     * subscription, the key is {@link SubscriptionManager#getDefaultSubscriptionId}) and the value\\n     * as the list of {@link EmergencyNumber}; empty Map if this information is not available;\\n     * or throw a SecurityException if the caller does not have the permission.\\n     \u0027}"}, {"color": "#97c2fc", "id": "EMERGENCY_NUMBER_SOURCE_DATABASE", "label": "EMERGENCY_NUMBER_SOURCE_DATABASE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.emergency.EmergencyNumber", "label": "android.telephony.emergency.EmergencyNumber", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A parcelable class that wraps and retrieves the information of number, service category(s) and\\n * country code for a specific emergency number.\\n \u0027}"}, {"color": "#97c2fc", "id": "public String getMnc()", "label": "public String getMnc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the Mobile Network Code of the emergency number.\\n     *\\n     * @return the Mobile Network Code of the emergency number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cInteger\u003e getEmergencyServiceCategories()", "label": "public List\u003cInteger\u003e getEmergencyServiceCategories()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the emergency service categories of the emergency number.\\n     *\\n     * Note: if the emergency number is in {@link #EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED}, only\\n     * {@link #EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED} is returned and it means the number is in\\n     * all categories.\\n     *\\n     * @return a list of the emergency service categories\\n     \u0027}"}, {"color": "#97c2fc", "id": "EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED", "label": "EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public List\u003cString\u003e getEmergencyUrns()", "label": "public List\u003cString\u003e getEmergencyUrns()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the list of emergency Uniform Resources Names (URN) of the emergency number.\\n     *\\n     * For example, {@code urn:service:sos} is the generic URN for contacting emergency services\\n     * of all type.\\n     *\\n     * Reference: 3gpp 24.503, Section 5.1.6.8.1 - General;\\n     *            RFC 5031\\n     *\\n     * @return list of emergency Uniform Resources Names (URN) or an empty list if the emergency\\n     *         number does not have a specified emergency Uniform Resource Name.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private boolean serviceUnspecified()", "label": "private boolean serviceUnspecified()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks if the emergency service category is unspecified for the emergency number\\n     * {@link #EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED}.\\n     *\\n     * @return {@code true} if the emergency service category is unspecified for the emergency\\n     * number {@link #EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED}; {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isInEmergencyServiceCategories(@EmergencyServiceCategories int categories)", "label": "public boolean isInEmergencyServiceCategories(@EmergencyServiceCategories int categories)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks if the emergency number is in the supplied emergency service category(s).\\n     *\\n     * @param categories - the supplied emergency service categories\\n     *\\n     * @return {@code true} if the emergency number is in the specified emergency service\\n     * category(s) or if its emergency service category is\\n     * {@link #EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED}; {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cInteger\u003e getEmergencyNumberSources()", "label": "public List\u003cInteger\u003e getEmergencyNumberSources()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a list of sources of the emergency number.\\n     *\\n     * @return a list of emergency number sources\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isFromSources(@EmergencyNumberSources int sources)", "label": "public boolean isFromSources(@EmergencyNumberSources int sources)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks if the emergency number is from the specified emergency number source(s).\\n     *\\n     * @return {@code true} if the emergency number is from the specified emergency number\\n     * source(s); {@code false} otherwise.\\n     *\\n     * @param sources - the supplied emergency number sources\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getEmergencyCallRouting()", "label": "public int getEmergencyCallRouting()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the emergency call routing information.\\n     *\\n     * \u003cp\u003eSome regions require some emergency numbers which are not routed using typical emergency\\n     * call processing, but are instead placed as regular phone calls. The emergency call routing\\n     * field provides information about how an emergency call will be routed when it is placed.\\n     *\\n     * @return the emergency call routing requirement\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int getDisplayPriorityScore()", "label": "private int getDisplayPriorityScore()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Calculate the score for display priority.\\n     *\\n     * A higher display priority score means the emergency number has a higher display priority.\\n     * The score is higher if the source is defined for a higher display priority.\\n     *\\n     * The priority of sources are defined as follows:\\n     *     EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING \u003e\\n     *     EMERGENCY_NUMBER_SOURCE_SIM \u003e\\n     *     EMERGENCY_NUMBER_SOURCE_DATABASE \u003e\\n     *     EMERGENCY_NUMBER_SOURCE_DEFAULT \u003e\\n     *     EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(@NonNull EmergencyNumber emergencyNumber)", "label": "public int compareTo(@NonNull EmergencyNumber emergencyNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compare the display priority for this emergency number and the supplied emergency number.\\n     *\\n     * @param emergencyNumber the supplied emergency number\\n     * @return a negative value if the supplied emergency number has a lower display priority;\\n     *         a positive value if the supplied emergency number has a higher display priority;\\n     *         0 if both have equal display priority.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "label": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the per-category emergency number list based on current locale, sim, default, modem\\n     * and network.\\n     *\\n     * \u003cp\u003eIn each returned list, the emergency number {@link EmergencyNumber} coming from higher\\n     * priority sources will be located at the smaller index; the priority order of sources are:\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_NETWORK_SIGNALING} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_SIM} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DATABASE} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_DEFAULT} \u003e\\n     * {@link EmergencyNumber#EMERGENCY_NUMBER_SOURCE_MODEM_CONFIG}\\n     *\\n     * \u003cp\u003eThe subscriptions which the returned list would be based on, are all the active\\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\\n     *\\n     * \u003cp\u003eRequires permission {@link android.Manifest.permission#READ_PHONE_STATE} or the calling\\n     * app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @param categories the emergency service categories which are the bitwise-OR combination of\\n     * the following constants:\\n     * \u003col\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_POLICE} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AMBULANCE} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_FIRE_BRIGADE} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MARINE_GUARD} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MOUNTAIN_RESCUE} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_MIEC} \u003c/li\u003e\\n     * \u003cli\u003e{@link EmergencyNumber#EMERGENCY_SERVICE_CATEGORY_AIEC} \u003c/li\u003e\\n     * \u003c/ol\u003e\\n     * @return Map including the keys as the active subscription IDs (Note: if there is no active\\n     * subscription, the key is {@link SubscriptionManager#getDefaultSubscriptionId}) and the value\\n     * as the list of {@link EmergencyNumber}; empty Map if this information is not available;\\n     * or throw a SecurityException if the caller does not have the permission.\\n     * @throws IllegalStateException if the Telephony process is not currently available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isEmergencyNumber(@NonNull String number)", "label": "public boolean isEmergencyNumber(@NonNull String number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Identifies if the supplied phone number is an emergency number that matches a known\\n     * emergency number based on current locale, SIM card(s), Android database, modem, network,\\n     * or defaults.\\n     *\\n     * \u003cp\u003eThis method assumes that only dialable phone numbers are passed in; non-dialable\\n     * numbers are not considered emergency numbers. A dialable phone number consists only\\n     * of characters/digits identified by {@link PhoneNumberUtils#isDialable(char)}.\\n     *\\n     * \u003cp\u003eThe subscriptions which the identification would be based on, are all the active\\n     * subscriptions, no matter which subscription could be used to create TelephonyManager.\\n     *\\n     * @param number - the number to look up\\n     * @return {@code true} if the given number is an emergency number based on current locale,\\n     * SIM card(s), Android database, modem, network or defaults; {@code false} otherwise.\\n     * @throws IllegalStateException if the Telephony process is not currently available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "isDialable(char)", "label": "isDialable(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.telephony.PhoneNumberUtils", "label": "android.telephony.PhoneNumberUtils", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Various utilities for dealing with phone number strings.\\n \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isISODigit(char c)", "label": "public static boolean isISODigit(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 True if c is ISO-LATIN characters 0-9 \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean is12Key(char c)", "label": "public static final boolean is12Key(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 True if c is ISO-LATIN characters 0-9, *, # \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean isDialable(char c)", "label": "public static final boolean isDialable(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 True if c is ISO-LATIN characters 0-9, *, # , +, WILD  \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean isReallyDialable(char c)", "label": "public static final boolean isReallyDialable(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 True if c is ISO-LATIN characters 0-9, *, # , + (no WILD)  \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean isNonSeparator(char c)", "label": "public static final boolean isNonSeparator(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 True if c is ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE   \u0027}"}, {"color": "#97c2fc", "id": "public static final boolean isStartsPostDial(char c)", "label": "public static final boolean isStartsPostDial(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 This any anything to the right of this char is part of the\\n     *  post-dial string (eg this is PAUSE or WAIT)\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean isSeparator(char ch)", "label": "private static boolean isSeparator(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Returns true if ch is not dialable or alpha char \u0027}"}, {"color": "#97c2fc", "id": "public static String getNumberFromIntent(Intent intent, Context context)", "label": "public static String getNumberFromIntent(Intent intent, Context context)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Extracts the phone number from an Intent.\\n     *\\n     * @param intent the intent to get the number of\\n     * @param context a context to use for database access\\n     *\\n     * @return the phone number that would be called by the intent, or\\n     *         \u003ccode\u003enull\u003c/code\u003e if the number cannot be found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String extractNetworkPortion(String phoneNumber)", "label": "public static String extractNetworkPortion(String phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Extracts the network address portion and canonicalizes\\n     *  (filters out separators.)\\n     *  Network address portion is everything up to DTMF control digit\\n     *  separators (pause or wait), but without non-dialable characters.\\n     *\\n     *  Please note that the GSM wild character is allowed in the result.\\n     *  This must be resolved before dialing.\\n     *\\n     *  Returns null if phoneNumber == null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String stripSeparators(String phoneNumber)", "label": "public static String stripSeparators(String phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Strips separators from a phone number string.\\n     * @param phoneNumber phone number to strip.\\n     * @return phone string stripped of separators.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int minPositive(int a, int b)", "label": "private static int minPositive(int a, int b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 or -1 if both are negative \u0027}"}, {"color": "#97c2fc", "id": "private static int indexOfLastNetworkChar(String a)", "label": "private static int indexOfLastNetworkChar(String a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 index of the last character of the network portion\\n     *  (eg anything after is a post-dial string)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean compare(String a, String b)", "label": "public static boolean compare(String a, String b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compare phone numbers a and b, return true if they\u0027re identical enough for caller ID purposes.\\n     \"}"}, {"color": "#97c2fc", "id": "public static boolean compare(Context context, String a, String b)", "label": "public static boolean compare(Context context, String a, String b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compare phone numbers a and b, and return true if they\u0027re identical\\n     * enough for caller ID purposes. Checks a resource to determine whether\\n     * to use a strict or loose comparison algorithm.\\n     \"}"}, {"color": "#97c2fc", "id": "public static String toCallerIDMinMatch(String phoneNumber)", "label": "public static String toCallerIDMinMatch(String phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the rightmost minimum matched characters in the network portion\\n     * in *reversed* order\\n     *\\n     * This can be used to do a database lookup against the column\\n     * that stores getStrippedReversed()\\n     *\\n     * Returns null if phoneNumber == null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String getStrippedReversed(String phoneNumber)", "label": "public static String getStrippedReversed(String phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the network portion reversed.\\n     * This string is intended to go into an index column for a\\n     * database lookup.\\n     *\\n     * Returns null if phoneNumber == null\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static String internalGetStrippedReversed(String np, int numDigits)", "label": "private static String internalGetStrippedReversed(String np, int numDigits)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the last numDigits of the reversed phone number\\n     * Returns null if np == null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String stringFromStringAndTOA(String s, int TOA)", "label": "public static String stringFromStringAndTOA(String s, int TOA)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Basically: makes sure there\u0027s a + in front of a\\n     * TOA_International number\\n     *\\n     * Returns null if s == null\\n     \"}"}, {"color": "#97c2fc", "id": "public static String calledPartyBCDToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "label": "public static String calledPartyBCDToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     *  3GPP TS 24.008 10.5.4.7\\n     *  Called Party BCD Number\\n     *\\n     *  See Also TS 51.011 10.5.1 \"dialing number/ssc string\"\\n     *  and TS 11.11 \"10.3.1 EF adn (Abbreviated dialing numbers)\"\\n     *\\n     * @param bytes the data buffer\\n     * @param offset should point to the TOA (aka. TON/NPI) octet after the length byte\\n     * @param length is the number of bytes including TOA byte\\n     *                and must be at least 2\\n     * @param bcdExtType used to determine the extended bcd coding\\n     * @see #BCD_EXTENDED_TYPE_EF_ADN\\n     * @see #BCD_EXTENDED_TYPE_CALLED_PARTY\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "label": "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Like calledPartyBCDToString, but field does not start with a\\n     * TOA byte. For example: SIM ADN extension fields\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static char bcdToChar(byte b, @BcdExtendType int bcdExtType)", "label": "private static char bcdToChar(byte b, @BcdExtendType int bcdExtType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the correspond character for given {@code b} based on {@code bcdExtType}, or 0 on\\n     * invalid code.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isWellFormedSmsAddress(String address)", "label": "public static boolean isWellFormedSmsAddress(String address)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return true iff the network portion of \u003ccode\u003eaddress\u003c/code\u003e is,\\n     * as far as we can tell on the device, suitable for use as an SMS\\n     * destination address.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static byte[] networkPortionToCalledPartyBCD(String s)", "label": "public static byte[] networkPortionToCalledPartyBCD(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Note: calls extractNetworkPortion(), so do not use for\\n     * SIM EF[ADN] style records\\n     *\\n     * Returns null if network portion is empty.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static byte[] networkPortionToCalledPartyBCDWithLength(String s)", "label": "public static byte[] networkPortionToCalledPartyBCDWithLength(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Same as {@link #networkPortionToCalledPartyBCD}, but includes a\\n     * one-byte length prefix.\\n     \u0027}"}, {"color": "#97c2fc", "id": "networkPortionToCalledPartyBCD", "label": "networkPortionToCalledPartyBCD", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static byte[] numberToCalledPartyBCD(String number, @BcdExtendType int bcdExtType)", "label": "public static byte[] numberToCalledPartyBCD(String number, @BcdExtendType int bcdExtType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Convert a dialing number to BCD byte array\\n     *\\n     * @param number dialing number string. If the dialing number starts with \u0027+\u0027, set to\\n     * international TOA\\n     * @param bcdExtType used to determine the extended bcd coding\\n     * @see #BCD_EXTENDED_TYPE_EF_ADN\\n     * @see #BCD_EXTENDED_TYPE_CALLED_PARTY\\n     *\\n     * @return BCD byte array\\n     \"}"}, {"color": "#97c2fc", "id": "private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, @BcdExtendType int bcdExtType)", "label": "private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, @BcdExtendType int bcdExtType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If includeLength is true, prepend a one-byte length value to\\n     * the return array.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void removeDashes(Editable text)", "label": "private static void removeDashes(Editable text)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes all dashes from the number.\\n     *\\n     * @param text the number to clear from dashes\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String formatNumberToE164(String phoneNumber, String defaultCountryIso)", "label": "public static String formatNumberToE164(String phoneNumber, String defaultCountryIso)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Formats the specified {@code phoneNumber} to the E.164 representation.\\n     *\\n     * @param phoneNumber the phone number to format.\\n     * @param defaultCountryIso the ISO 3166-1 two letters country code.\\n     * @return the E.164 representation, or null if the given phone number is not valid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String formatNumberToRFC3966(String phoneNumber, String defaultCountryIso)", "label": "public static String formatNumberToRFC3966(String phoneNumber, String defaultCountryIso)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Formats the specified {@code phoneNumber} to the RFC3966 representation.\\n     *\\n     * @param phoneNumber the phone number to format.\\n     * @param defaultCountryIso the ISO 3166-1 two letters country code.\\n     * @return the RFC3966 representation, or null if the given phone number is not valid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static String formatNumberInternal(String rawPhoneNumber, String defaultCountryIso, PhoneNumberFormat formatIdentifier)", "label": "private static String formatNumberInternal(String rawPhoneNumber, String defaultCountryIso, PhoneNumberFormat formatIdentifier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Formats the raw phone number (string) using the specified {@code formatIdentifier}.\\n     * \u003cp\u003e\\n     * The given phone number must have an area code and could have a country code.\\n     * \u003cp\u003e\\n     * The defaultCountryIso is used to validate the given number and generate the formatted number\\n     * if the specified number doesn\u0027t have a country code.\\n     *\\n     * @param rawPhoneNumber The phone number to format.\\n     * @param defaultCountryIso The ISO 3166-1 two letters country code.\\n     * @param formatIdentifier The (enum) identifier of the desired format.\\n     * @return the formatted representation, or null if the specified number is not valid.\\n     \"}"}, {"color": "#97c2fc", "id": "public static String formatNumber(String phoneNumber, String defaultCountryIso)", "label": "public static String formatNumber(String phoneNumber, String defaultCountryIso)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Format a phone number.\\n     * \u003cp\u003e\\n     * If the given number doesn\u0027t have the country code, the phone will be\\n     * formatted to the default country\u0027s convention.\\n     *\\n     * @param phoneNumber\\n     *            the number to be formatted.\\n     * @param defaultCountryIso\\n     *            the ISO 3166-1 two letters country code whose convention will\\n     *            be used if the given number doesn\u0027t have the country code.\\n     * @return the formatted number, or null if the given number is not valid.\\n     \"}"}, {"color": "#97c2fc", "id": "public static String formatNumber(String phoneNumber, String phoneNumberE164, String defaultCountryIso)", "label": "public static String formatNumber(String phoneNumber, String phoneNumberE164, String defaultCountryIso)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Format the phone number only if the given number hasn\u0027t been formatted.\\n     * \u003cp\u003e\\n     * The number which has only dailable character is treated as not being\\n     * formatted.\\n     *\\n     * @param phoneNumber\\n     *            the number to be formatted.\\n     * @param phoneNumberE164\\n     *            the E164 format number whose country code is used if the given\\n     *            phoneNumber doesn\u0027t have the country code.\\n     * @param defaultCountryIso\\n     *            the ISO 3166-1 two letters country code whose convention will\\n     *            be used if the phoneNumberE164 is null or invalid, or if phoneNumber\\n     *            contains IDD.\\n     * @return the formatted number if the given number has been formatted,\\n     *            otherwise, return the given number.\\n     \"}"}, {"color": "#97c2fc", "id": "public static String normalizeNumber(String phoneNumber)", "label": "public static String normalizeNumber(String phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Normalize a phone number by removing the characters other than digits. If\\n     * the given number has keypad letters, the letters will be converted to\\n     * digits first.\\n     *\\n     * @param phoneNumber the number to be normalized.\\n     * @return the normalized number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String replaceUnicodeDigits(String number)", "label": "public static String replaceUnicodeDigits(String number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces all unicode(e.g. Arabic, Persian) digits with their decimal digit equivalents.\\n     *\\n     * @param number the number to perform the replacement on.\\n     * @return the replaced number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean isEmergencyNumberInternal(String number, boolean useExactMatch)", "label": "private static boolean isEmergencyNumberInternal(String number, boolean useExactMatch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Helper function for isEmergencyNumber(String) and\\n     * isPotentialEmergencyNumber(String).\\n     *\\n     * @param number the number to look up.\\n     *\\n     * @param useExactMatch if true, consider a number to be an emergency\\n     *           number only if it *exactly* matches a number listed in\\n     *           the RIL / SIM.  If false, a number is considered to be an\\n     *           emergency number if it simply starts with the same digits\\n     *           as any of the emergency numbers listed in the RIL / SIM.\\n     *           (Setting useExactMatch to false allows you to identify\\n     *           number that could *potentially* result in emergency calls\\n     *           since many networks will actually ignore trailing digits\\n     *           after a valid emergency number.)\\n     *\\n     * @return true if the number is in the list of emergency numbers\\n     *         listed in the RIL / sim, otherwise return false.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean isEmergencyNumberInternal(int subId, String number, boolean useExactMatch)", "label": "private static boolean isEmergencyNumberInternal(int subId, String number, boolean useExactMatch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Helper function for isEmergencyNumber(String) and\\n     * isPotentialEmergencyNumber(String).\\n     *\\n     * @param subId the subscription id of the SIM.\\n     * @param number the number to look up.\\n     *\\n     * @param useExactMatch if true, consider a number to be an emergency\\n     *           number only if it *exactly* matches a number listed in\\n     *           the RIL / SIM.  If false, a number is considered to be an\\n     *           emergency number if it simply starts with the same digits\\n     *           as any of the emergency numbers listed in the RIL / SIM.\\n     *           (Setting useExactMatch to false allows you to identify\\n     *           number that could *potentially* result in emergency calls\\n     *           since many networks will actually ignore trailing digits\\n     *           after a valid emergency number.)\\n     *\\n     * @return true if the number is in the list of emergency numbers\\n     *         listed in the RIL / sim, otherwise return false.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean isEmergencyNumberInternal(String number, String defaultCountryIso, boolean useExactMatch)", "label": "private static boolean isEmergencyNumberInternal(String number, String defaultCountryIso, boolean useExactMatch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Helper function for isEmergencyNumber(String, String) and\\n     * isPotentialEmergencyNumber(String, String).\\n     *\\n     * @param number the number to look up.\\n     * @param defaultCountryIso the specific country which the number should be checked against\\n     * @param useExactMatch if true, consider a number to be an emergency\\n     *           number only if it *exactly* matches a number listed in\\n     *           the RIL / SIM.  If false, a number is considered to be an\\n     *           emergency number if it simply starts with the same digits\\n     *           as any of the emergency numbers listed in the RIL / SIM.\\n     *\\n     * @return true if the number is an emergency number for the specified country.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isVoiceMailNumber(String number)", "label": "public static boolean isVoiceMailNumber(String number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * isVoiceMailNumber: checks a given number against the voicemail\\n     *   number provided by the RIL and SIM card. The caller must have\\n     *   the READ_PHONE_STATE credential.\\n     *\\n     * @param number the number to look up.\\n     * @return true if the number is in the list of voicemail. False\\n     * otherwise, including if the caller does not have the permission\\n     * to read the VM number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String convertKeypadLettersToDigits(String input)", "label": "public static String convertKeypadLettersToDigits(String input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Translates any alphabetic letters (i.e. [A-Za-z]) in the\\n     * specified phone number into the equivalent numeric digits,\\n     * according to the phone keypad letter mapping described in\\n     * ITU E.161 and ISO/IEC 9995-8.\\n     *\\n     * @return the input string, with alpha letters converted to numeric\\n     *         digits using the phone keypad letter mapping.  For example,\\n     *         an input of \"1-800-GOOG-411\" will return \"1-800-4664-411\".\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static CharSequence createTtsSpannable(CharSequence phoneNumber)", "label": "public static CharSequence createTtsSpannable(CharSequence phoneNumber)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Wrap the supplied {@code CharSequence} with a {@code TtsSpan}, annotating it as\\n     * containing a phone number in its entirety.\\n     *\\n     * @param phoneNumber A {@code CharSequence} the entirety of which represents a phone number.\\n     * @return A {@code CharSequence} with appropriate annotations.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void addTtsSpan(Spannable s, int start, int endExclusive)", "label": "public static void addTtsSpan(Spannable s, int start, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attach a {@link TtsSpan} to the supplied {@code Spannable} at the indicated location,\\n     * annotating that location as containing a phone number.\\n     *\\n     * @param s A {@code Spannable} to annotate.\\n     * @param start The starting character position of the phone number in {@code s}.\\n     * @param endExclusive The position after the ending character in the phone number {@code s}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "android.text.style.TtsSpan", "label": "android.text.style.TtsSpan", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A span that supplies additional meta-data for the associated text intended\\n * for text-to-speech engines. If the text is being processed by a\\n * text-to-speech engine, the engine may use the data in this span in addition\\n * to or instead of its associated text.\\n *\\n * Each instance of a TtsSpan has a type, for example {@link #TYPE_DATE}\\n * or {@link #TYPE_MEASURE}. And a list of arguments, provided as\\n * key-value pairs in a bundle.\\n *\\n * The inner classes are there for convenience and provide builders for each\\n * TtsSpan type.\\n \u0027}"}, {"color": "#97c2fc", "id": "public String getType()", "label": "public String getType()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the type.\\n     * @return The type of this instance.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PersistableBundle getArgs()", "label": "public PersistableBundle getArgs()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a bundle of the arguments set.\\n     * @return The bundle of the arguments set.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static TtsSpan createTtsSpan(String phoneNumberString)", "label": "public static TtsSpan createTtsSpan(String phoneNumberString)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create a {@code TtsSpan} for the supplied {@code String}.\\n     *\\n     * @param phoneNumberString A {@code String} the entirety of which represents a phone number.\\n     * @return A {@code TtsSpan} for {@param phoneNumberString}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static String splitAtNonNumerics(CharSequence number)", "label": "private static String splitAtNonNumerics(CharSequence number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 a digit or the characters * and #, to produce a result like \"20 123 456#\".\u0027}"}, {"color": "#97c2fc", "id": "private static boolean isOneNanp(String dialStr)", "label": "private static boolean isOneNanp(String dialStr)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * This function checks if the passed in string conforms to 1-NANP format\\n    \u0027}"}, {"color": "#97c2fc", "id": "private static String processPlusCode(String networkDialStr, boolean useNanp)", "label": "private static String processPlusCode(String networkDialStr, boolean useNanp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This function handles the plus code conversion\\n     * If the number format is\\n     * 1)+1NANP,remove +,\\n     * 2)other than +1NANP, any + numbers,replace + with the current IDP\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int findDialableIndexFromPostDialStr(String postDialStr)", "label": "private static int findDialableIndexFromPostDialStr(String postDialStr)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 in the post dial string\u0027}"}, {"color": "#97c2fc", "id": "private static String appendPwCharBackToOrigDialStr(int dialableIndex, String origStr, String dialStr)", "label": "private static String appendPwCharBackToOrigDialStr(int dialableIndex, String origStr, String dialStr)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 dial string based on the dialable index passed in\u0027}"}, {"color": "#97c2fc", "id": "private static boolean matchIntlPrefix(String a, int len)", "label": "private static boolean matchIntlPrefix(String a, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 all of a up to len must be an international prefix or\\n     *  separators/non-dialing digits\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean matchIntlPrefixAndCC(String a, int len)", "label": "private static boolean matchIntlPrefixAndCC(String a, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \" all of \u0027a\u0027 up to len must be a (+|00|011)country code)\\n     *  We\u0027re fast and loose with the country code. Any \\\\d{1,3} matches \"}"}, {"color": "#97c2fc", "id": "private static boolean matchTrunkPrefix(String a, int len)", "label": "private static boolean matchTrunkPrefix(String a, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \" all of \u0027a\u0027 up to len must match non-US trunk prefix (\u00270\u0027) \"}"}, {"color": "#97c2fc", "id": "private static boolean isCountryCallingCode(int countryCallingCodeCandidate)", "label": "private static boolean isCountryCallingCode(int countryCallingCodeCandidate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @return true when input is valid Country Calling Code.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int tryGetISODigit(char ch)", "label": "private static int tryGetISODigit(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns integer corresponding to the input if input \"ch\" is\\n     * ISO-LATIN characters 0-9.\\n     * Returns -1 otherwise\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static CountryCallingCodeAndNewIndex tryGetCountryCallingCodeAndNewIndex(String str, boolean acceptThailandCase)", "label": "private static CountryCallingCodeAndNewIndex tryGetCountryCallingCodeAndNewIndex(String str, boolean acceptThailandCase)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Note that this function does not strictly care the country calling code with\\n     * 3 length (like Morocco: +212), assuming it is enough to use the first two\\n     * digit to compare two phone numbers.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int tryGetTrunkPrefixOmittedIndex(String str, int currentIndex)", "label": "private static int tryGetTrunkPrefixOmittedIndex(String str, int currentIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Currently this function simply ignore the first digit assuming it is\\n     * trunk prefix. Actually trunk prefix is different in each country.\\n     *\\n     * e.g.\\n     * \"+79161234567\" equals \"89161234567\" (Russian trunk digit is 8)\\n     * \"+33123456789\" equals \"0123456789\" (French trunk digit is 0)\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean checkPrefixIsIgnorable(final String str, int forwardIndex, int backwardIndex)", "label": "private static boolean checkPrefixIsIgnorable(final String str, int forwardIndex, int backwardIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return true if the prefix of \"str\" is \"ignorable\". Here, \"ignorable\" means\\n     * that \"str\" has only one digit and separator characters. The one digit is\\n     * assumed to be trunk prefix.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int getDefaultVoiceSubId()", "label": "private static int getDefaultVoiceSubId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns Default voice subscription Id.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer\u003cInteger\u003e callback)", "label": "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer\u003cInteger\u003e callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Set preferred opportunistic data subscription id.\\n     *\\n     * Switch internet data to preferred opportunistic data subscription id. This api\\n     * can result in lose of internet connectivity for short period of time while internet data\\n     * is handed over.\\n     * \u003cp\u003eRequires that the calling app has carrier privileges on both primary and\\n     * secondary subscriptions (see\\n     * {@link #hasCarrierPrivileges}), or has permission\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\\n     *\\n     * @param subId which opportunistic subscription\\n     * {@link SubscriptionManager#getOpportunisticSubscriptions} is preferred for cellular data.\\n     * Pass {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID} to unset the preference\\n     * @param needValidation whether validation is needed before switch happens.\\n     * @param executor The executor of where the callback will execute.\\n     * @param callback Callback will be triggered once it succeeds or failed.\\n     *                 See {@link TelephonyManager.SetOpportunisticSubscriptionResult}\\n     *                 for more details. Pass null if don\u0027t care about the result.\\n     \"}"}, {"color": "#97c2fc", "id": "TelephonyManager.SetOpportunisticSubscriptionResult", "label": "TelephonyManager.SetOpportunisticSubscriptionResult", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public int getPreferredOpportunisticDataSubscription()", "label": "public int getPreferredOpportunisticDataSubscription()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get preferred opportunistic data subscription Id\\n     *\\n     * \u003cp\u003eRequires that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}),\\n     * or has either READ_PRIVILEGED_PHONE_STATE\\n     * or {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} permission.\\n     * @return subId preferred opportunistic subscription id or\\n     * {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID} if there are no preferred\\n     * subscription id\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void updateAvailableNetworks(@NonNull List\u003cAvailableNetworkInfo\u003e availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer\u003cInteger\u003e callback)", "label": "public void updateAvailableNetworks(@NonNull List\u003cAvailableNetworkInfo\u003e availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer\u003cInteger\u003e callback)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Update availability of a list of networks in the current location.\\n     *\\n     * This api should be called to inform OpportunisticNetwork Service about the availability\\n     * of a network at the current location. This information will be used by OpportunisticNetwork\\n     * service to enable modem stack and to attach to the network. If an empty list is passed,\\n     * it is assumed that no network is available and will result in disabling the modem stack\\n     * to save power. This api do not switch internet data once network attach is completed.\\n     * Use {@link TelephonyManager#setPreferredOpportunisticDataSubscription}\\n     * to switch internet data after network attach is complete.\\n     * Requires that the calling app has carrier privileges on both primary and\\n     * secondary subscriptions (see {@link #hasCarrierPrivileges}), or has permission\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.\\n     * @param availableNetworks is a list of available network information.\\n     * @param executor The executor of where the callback will execute.\\n     * @param callback Callback will be triggered once it succeeds or failed.\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "setPreferredOpportunisticDataSubscription", "label": "setPreferredOpportunisticDataSubscription", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isModemEnabledForSlot(int slotIndex)", "label": "public boolean isModemEnabledForSlot(int slotIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * It indicates whether modem is enabled or not per slot.\\n     * It\u0027s the corresponding status of TelephonyManager.enableModemForSlot.\\n     *\\n     * \u003cp\u003eRequires Permission:\\n     * READ_PRIVILEGED_PHONE_STATE or\\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * @param slotIndex which slot it\u0027s checking.\\n     \"}"}, {"color": "#97c2fc", "id": "public int isMultiSimSupported()", "label": "public int isMultiSimSupported()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns if the usage of multiple SIM cards at the same time to register on the network\\n     * (e.g. Dual Standby or Dual Active) is supported by the device and by the carrier.\\n     *\\n     * \u003cp\u003eRequires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\\n     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return {@link #MULTISIM_ALLOWED} if the device supports multiple SIMs.\\n     * {@link #MULTISIM_NOT_SUPPORTED_BY_HARDWARE} if the device does not support multiple SIMs.\\n     * {@link #MULTISIM_NOT_SUPPORTED_BY_CARRIER} in the device supports multiple SIMs, but the\\n     * functionality is restricted by the carrier.\\n     \u0027}"}, {"color": "#97c2fc", "id": "MULTISIM_NOT_SUPPORTED_BY_HARDWARE", "label": "MULTISIM_NOT_SUPPORTED_BY_HARDWARE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MULTISIM_NOT_SUPPORTED_BY_CARRIER", "label": "MULTISIM_NOT_SUPPORTED_BY_CARRIER", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MULTISIM_ALLOWED", "label": "MULTISIM_ALLOWED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void switchMultiSimConfig(int numOfSims)", "label": "public void switchMultiSimConfig(int numOfSims)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Switch configs to enable multi-sim or switch back to single-sim\\n     * \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} or that the\\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * Note: with only carrier privileges, it is not allowed to switch from multi-sim\\n     * to single-sim\\n     *\\n     * @param numOfSims number of live SIMs we want to switch to\\n     * @throws android.os.RemoteException\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean doesSwitchMultiSimConfigTriggerReboot()", "label": "public boolean doesSwitchMultiSimConfigTriggerReboot()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get whether making changes to modem configurations by {@link #switchMultiSimConfig(int)} will\\n     * trigger device reboot.\\n     * The modem configuration change refers to switching from single SIM configuration to DSDS\\n     * or the other way around.\\n     *\\n     *  \u003cp\u003eRequires Permission:\\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} or that the\\n     * calling app has carrier privileges (see {@link #hasCarrierPrivileges}).\\n     *\\n     * @return {@code true} if reboot will be triggered after making changes to modem\\n     * configurations, otherwise return {@code false}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "switchMultiSimConfig(int)", "label": "switchMultiSimConfig(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getActiveModemCount()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSupportedModemCount()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public TelephonyManager createForSubscriptionId(int subId)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public TelephonyManager createForPhoneAccountHandle(PhoneAccountHandle phoneAccountHandle)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getDeviceSoftwareVersion()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getImei()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getImei(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getTypeAllocationCode()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getTypeAllocationCode(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMeid()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMeid(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getManufacturerCode()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getManufacturerCode(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNai()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPhoneType()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String getProcCmdLine()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNetworkOperatorName()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNetworkOperator()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNetworkSpecifier()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PersistableBundle getCarrierConfig()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isNetworkRoaming()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNetworkCountryIso()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNetworkCountryIso(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDataNetworkType()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getVoiceNetworkType()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasIccCard()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasIccCard(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSimState()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getSimCardStateFromSimState(int simState)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getLogicalSlotIndex(int physicalSlotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getSimApplicationStateFromSimState(int simState)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSimState(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getSimOperator()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getSimOperatorName()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getSimCountryIso()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getSimSerialNumber()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCardIdForDefaultEuicc()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getSubscriberId()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getGroupIdLevel1()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getLine1Number()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setLine1NumberForDisplay(String alphaTag, String number)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getVoiceMailNumber()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setVoiceMailNumber(String alphaTag, String number)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getVisualVoicemailPackageName()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setVisualVoicemailSmsFilterSettings(VisualVoicemailSmsFilterSettings settings)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getVoiceMailAlphaTag()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendDialerSpecialCode(String inputCode)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCallState()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDataActivity()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDataState()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isVoiceCapable()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isSmsCapable()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cCellInfo\u003e getAllCellInfo()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void requestCellInfoUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMmsUserAgent()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMmsUAProfUrl()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getSubId()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getSubId(int preferredSubId)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getPhoneId()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getPhoneId(int preferredSubId)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static List\u003cT\u003e updateTelephonyProperty(List\u003cT\u003e prop, int phoneId, T value)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static T getTelephonyProperty(int phoneId, List\u003cT\u003e prop, T defaultValue)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getIccAuthentication(int appType, int authType, String data)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] getForbiddenPlmns()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int setForbiddenPlmns(@NonNull List\u003cString\u003e fplmns)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setNetworkSelectionModeAutomatic()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getNetworkSelectionMode()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getManualNetworkSelectionPlmn()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setPreferredNetworkTypeToGlobal()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasCarrierPrivileges()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setOperatorBrandOverride(String brand)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isConcurrentVoiceAndDataSupported()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setDataEnabled(boolean enable)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isDataEnabled()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isDataRoamingEnabled()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canChangeDtmfToneLength()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isWorldPhone()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isRttSupported()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isHearingAidCompatibilitySupported()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ServiceState getServiceState()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Uri getVoicemailRingtoneUri(PhoneAccountHandle accountHandle)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isVoicemailVibrationEnabled(PhoneAccountHandle accountHandle)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSimCarrierId()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getSimCarrierIdName()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSimSpecificCarrierId()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getSimSpecificCarrierIdName()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCarrierIdFromSimMccMnc()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isManualNetworkSelectionAllowed()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SignalStrength getSignalStrength()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isEmergencyNumber(@NonNull String number)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer\u003cInteger\u003e callback)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPreferredOpportunisticDataSubscription()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void updateAvailableNetworks(@NonNull List\u003cAvailableNetworkInfo\u003e availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer\u003cInteger\u003e callback)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isModemEnabledForSlot(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int isMultiSimSupported()"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void switchMultiSimConfig(int numOfSims)"}, {"arrows": "to", "from": "android.telephony.TelephonyManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean doesSwitchMultiSimConfigTriggerReboot()"}, {"arrows": "to", "from": "public int getSupportedModemCount()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getActiveModemCount"}, {"arrows": "to", "from": "public String getDeviceSoftwareVersion()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getImei()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getImei(int)"}, {"arrows": "to", "from": "public String getImei(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getImei(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getImei(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRoleHeld(String)"}, {"arrows": "to", "from": "android.app.role.RoleManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Intent createRequestRoleIntent(@NonNull String roleName)"}, {"arrows": "to", "from": "android.app.role.RoleManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isRoleAvailable(@NonNull String roleName)"}, {"arrows": "to", "from": "android.app.role.RoleManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isRoleHeld(@NonNull String roleName)"}, {"arrows": "to", "from": "public Intent createRequestRoleIntent(@NonNull String roleName)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESULT_CANCELED"}, {"arrows": "to", "from": "public String getMeid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getMeid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getMeid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRoleHeld(String)"}, {"arrows": "to", "from": "public String getMeid(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getMeid(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getMeid(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRoleHeld(String)"}, {"arrows": "to", "from": "public String getNai()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getNai()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getNai()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRoleHeld(String)"}, {"arrows": "to", "from": "public String getNetworkOperatorName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPhoneType()"}, {"arrows": "to", "from": "public String getNetworkOperator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPhoneType()"}, {"arrows": "to", "from": "public String getNetworkSpecifier()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setNetworkSpecifier(String)"}, {"arrows": "to", "from": "public String getNetworkSpecifier()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "android.net.NetworkRequest", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.net.NetworkRequest", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasCapability(@NetCapability int capability)"}, {"arrows": "to", "from": "android.net.NetworkRequest", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canBeSatisfiedBy(@Nullable NetworkCapabilities nc)"}, {"arrows": "to", "from": "android.net.NetworkRequest", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasTransport(@Transport int transportType)"}, {"arrows": "to", "from": "android.net.NetworkRequest", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public NetworkSpecifier getNetworkSpecifier()"}, {"arrows": "to", "from": "public boolean canBeSatisfiedBy(@Nullable NetworkCapabilities nc)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasCapability(@NetCapability int capability)"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void combineNetCapabilities(@NonNull NetworkCapabilities nc)"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasTransport(@Transport int transportType)"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getOwnerUid()"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void combineAdministratorUids(@NonNull final NetworkCapabilities nc)"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLinkUpstreamBandwidthKbps()"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLinkDownstreamBandwidthKbps()"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public NetworkSpecifier getNetworkSpecifier()"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public TransportInfo getTransportInfo()"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSignalStrength()"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void combineUids(@NonNull NetworkCapabilities nc)"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean satisfiedByRequestor(NetworkCapabilities nc)"}, {"arrows": "to", "from": "android.net.NetworkCapabilities", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void combineRequestor(@NonNull NetworkCapabilities nc)"}, {"arrows": "to", "from": "public NetworkSpecifier getNetworkSpecifier()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkSpecifier"}, {"arrows": "to", "from": "public TransportInfo getTransportInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.TransportInfo"}, {"arrows": "to", "from": "public PersistableBundle getCarrierConfig()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public PersistableBundle getCarrierConfig()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getNetworkCountryIso()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPhoneType()"}, {"arrows": "to", "from": "public String getNetworkCountryIso(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPhoneType()"}, {"arrows": "to", "from": "public String getNetworkCountryIso(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNetworkCountryIso()"}, {"arrows": "to", "from": "public int getDataNetworkType()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public int getDataNetworkType()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefaultDataSubscriptionId()"}, {"arrows": "to", "from": "public int getDataNetworkType()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int getDataNetworkType()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SubscriptionInfo getActiveSubscriptionInfo(int subId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cSubscriptionInfo\u003e getAccessibleSubscriptionInfoList()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getActiveSubscriptionInfoCount()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getActiveSubscriptionInfoCountMax()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getSlotIndex(int subscriptionId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int[] getSubscriptionIds(int slotIndex)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getDefaultSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getDefaultVoiceSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getDefaultSmsSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getDefaultDataSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isValidSubscriptionId(int subscriptionId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUsableSubscriptionId(int subscriptionId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isNetworkRoaming(int subId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isActiveSubscriptionId(int subscriptionId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cSubscriptionPlan\u003e getSubscriptionPlans(int subId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setSubscriptionPlans(int subId, @NonNull List\u003cSubscriptionPlan\u003e plans)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long timeoutMillis)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long timeoutMillis)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canManageSubscription(SubscriptionInfo info)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cSubscriptionInfo\u003e getOpportunisticSubscriptions()"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setOpportunistic(boolean opportunistic, int subId)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ParcelUuid createSubscriptionGroup(@NonNull List\u003cInteger\u003e subIdList)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void addSubscriptionsIntoGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void removeSubscriptionsFromGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cSubscriptionInfo\u003e getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)"}, {"arrows": "to", "from": "android.telephony.SubscriptionManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getActiveDataSubscriptionId()"}, {"arrows": "to", "from": "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnSubscriptionsChangedListener"}, {"arrows": "to", "from": "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionInfo"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getIccId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSimSlotIndex()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCarrierId()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getDisplayName()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getCarrierName()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Bitmap createIconBitmap(Context context)"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getIconTint()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNumber()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDataRoaming()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMccString()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMncString()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getCountryIso()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isEmbedded()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isOpportunistic()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ParcelUuid getGroupUuid()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSubscriptionType()"}, {"arrows": "to", "from": "android.telephony.SubscriptionInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCardId()"}, {"arrows": "to", "from": "public int getSubscriptionId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public int getSubscriptionId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public String getIccId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getNumber()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public ParcelUuid getGroupUuid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isOpportunistic()"}, {"arrows": "to", "from": "public int getCardId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCardId()"}, {"arrows": "to", "from": "android.telephony.UiccCardInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isEuicc()"}, {"arrows": "to", "from": "android.telephony.UiccCardInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCardId()"}, {"arrows": "to", "from": "android.telephony.UiccCardInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getEid()"}, {"arrows": "to", "from": "android.telephony.UiccCardInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getIccId()"}, {"arrows": "to", "from": "android.telephony.UiccCardInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSlotIndex()"}, {"arrows": "to", "from": "android.telephony.UiccCardInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isRemovable()"}, {"arrows": "to", "from": "public String getEid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isEuicc()"}, {"arrows": "to", "from": "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnSubscriptionsChangedListener"}, {"arrows": "to", "from": "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionInfo"}, {"arrows": "to", "from": "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnSubscriptionsChangedListener"}, {"arrows": "to", "from": "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnOpportunisticSubscriptionsChangedListener"}, {"arrows": "to", "from": "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnOpportunisticSubscriptionsChangedListener"}, {"arrows": "to", "from": "public SubscriptionInfo getActiveSubscriptionInfo(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public SubscriptionInfo getActiveSubscriptionInfo(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnSubscriptionsChangedListener"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onSubscriptionsChanged"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionInfo"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getActiveSubscriptionInfoList"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getCompleteActiveSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionInfo"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getAccessibleSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OnSubscriptionsChangedListener"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getAccessibleSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onSubscriptionsChanged"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getAccessibleSubscriptionInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionInfo"}, {"arrows": "to", "from": "public int getActiveSubscriptionInfoCount()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int getActiveSubscriptionInfoCount()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getActiveSubscriptionInfoList"}, {"arrows": "to", "from": "public int getActiveSubscriptionInfoCount()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public int getActiveSubscriptionInfoCountMax()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getActiveSubscriptionInfoCount"}, {"arrows": "to", "from": "public int getActiveSubscriptionInfoCountMax()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getActiveSubscriptionInfoList"}, {"arrows": "to", "from": "public static int getSlotIndex(int subscriptionId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "INVALID_SIM_SLOT_INDEX"}, {"arrows": "to", "from": "public static boolean isValidSubscriptionId(int subscriptionId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUsableSubscriptionId(int)"}, {"arrows": "to", "from": "public static boolean isValidSubscriptionId(int subscriptionId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isActiveSubscriptionId(int)"}, {"arrows": "to", "from": "public static boolean isUsableSubscriptionId(int subscriptionId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isActiveSubscriptionId(int)"}, {"arrows": "to", "from": "public List\u003cSubscriptionPlan\u003e getSubscriptionPlans(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING"}, {"arrows": "to", "from": "android.telephony.CarrierConfigManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PersistableBundle getConfigForSubId(int subId)"}, {"arrows": "to", "from": "android.telephony.CarrierConfigManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PersistableBundle getConfig()"}, {"arrows": "to", "from": "android.telephony.CarrierConfigManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)"}, {"arrows": "to", "from": "android.telephony.CarrierConfigManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void notifyConfigChangedForSubId(int subId)"}, {"arrows": "to", "from": "android.telephony.CarrierConfigManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PersistableBundle getConfigByComponentForSubId(@NonNull String prefix, int subId)"}, {"arrows": "to", "from": "public PersistableBundle getConfigForSubId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionManager"}, {"arrows": "to", "from": "public PersistableBundle getConfigForSubId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.PersistableBundle"}, {"arrows": "to", "from": "public PersistableBundle getConfigForSubId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isConfigForIdentifiedCarrier(PersistableBundle)"}, {"arrows": "to", "from": "public PersistableBundle getConfigForSubId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "android.os.PersistableBundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object clone()"}, {"arrows": "to", "from": "android.os.PersistableBundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putPersistableBundle(@Nullable String key, @Nullable PersistableBundle value)"}, {"arrows": "to", "from": "android.os.PersistableBundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PersistableBundle getPersistableBundle(@Nullable String key)"}, {"arrows": "to", "from": "android.os.PersistableBundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.os.PersistableBundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel parcel, int flags)"}, {"arrows": "to", "from": "public PersistableBundle deepCopy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.Bundle"}, {"arrows": "to", "from": "public PersistableBundle deepCopy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ArrayList"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void maybePrefillHasFds()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setClassLoader(ClassLoader loader)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ClassLoader getClassLoader()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object clone()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Bundle deepCopy()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void clear()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void remove(String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putAll(Bundle bundle)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasFileDescriptors()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putByte(@Nullable String key, byte value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putChar(@Nullable String key, char value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putShort(@Nullable String key, short value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putFloat(@Nullable String key, float value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putCharSequence(@Nullable String key, @Nullable CharSequence value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putParcelable(@Nullable String key, @Nullable Parcelable value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putSize(@Nullable String key, @Nullable Size value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putSizeF(@Nullable String key, @Nullable SizeF value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putParcelableArray(@Nullable String key, @Nullable Parcelable[] value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putParcelableArrayList(@Nullable String key, @Nullable ArrayList\u003c? extends Parcelable\u003e value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putSparseParcelableArray(@Nullable String key, @Nullable SparseArray\u003c? extends Parcelable\u003e value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putIntegerArrayList(@Nullable String key, @Nullable ArrayList\u003cInteger\u003e value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putStringArrayList(@Nullable String key, @Nullable ArrayList\u003cString\u003e value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putCharSequenceArrayList(@Nullable String key, @Nullable ArrayList\u003cCharSequence\u003e value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putSerializable(@Nullable String key, @Nullable Serializable value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putByteArray(@Nullable String key, @Nullable byte[] value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putShortArray(@Nullable String key, @Nullable short[] value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putCharArray(@Nullable String key, @Nullable char[] value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putFloatArray(@Nullable String key, @Nullable float[] value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putCharSequenceArray(@Nullable String key, @Nullable CharSequence[] value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putBundle(@Nullable String key, @Nullable Bundle value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void putBinder(@Nullable String key, @Nullable IBinder value)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte getByte(String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Byte getByte(String key, byte defaultValue)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char getChar(String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char getChar(String key, char defaultValue)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short getShort(String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short getShort(String key, short defaultValue)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public float getFloat(String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public float getFloat(String key, float defaultValue)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getCharSequence(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getCharSequence(@Nullable String key, CharSequence defaultValue)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Size getSize(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SizeF getSizeF(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Bundle getBundle(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public T getParcelable(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Parcelable[] getParcelableArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ArrayList\u003cT\u003e getParcelableArrayList(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SparseArray\u003cT\u003e getSparseParcelableArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Serializable getSerializable(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ArrayList\u003cInteger\u003e getIntegerArrayList(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ArrayList\u003cString\u003e getStringArrayList(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ArrayList\u003cCharSequence\u003e getCharSequenceArrayList(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getByteArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short[] getShortArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char[] getCharArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public float[] getFloatArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence[] getCharSequenceArray(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IBinder getBinder(@Nullable String key)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel parcel, int flags)"}, {"arrows": "to", "from": "android.os.Bundle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void readFromParcel(Parcel parcel)"}, {"arrows": "to", "from": "private void maybePrefillHasFds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FLAG_HAS_FDS_KNOWN"}, {"arrows": "to", "from": "private void maybePrefillHasFds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasFileDescriptors()"}, {"arrows": "to", "from": "private void maybePrefillHasFds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mParcelledData"}, {"arrows": "to", "from": "public Bundle deepCopy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.PersistableBundle"}, {"arrows": "to", "from": "public Bundle deepCopy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ArrayList"}, {"arrows": "to", "from": "public void putBinder(@Nullable String key, @Nullable IBinder value)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.IBinder"}, {"arrows": "to", "from": "public T getParcelable(@Nullable String key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ClassLoader"}, {"arrows": "to", "from": "public T getParcelable(@Nullable String key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setClassLoader(ClassLoader)"}, {"arrows": "to", "from": "public Parcelable[] getParcelableArray(@Nullable String key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ClassLoader"}, {"arrows": "to", "from": "public Parcelable[] getParcelableArray(@Nullable String key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setClassLoader(ClassLoader)"}, {"arrows": "to", "from": "public ArrayList\u003cT\u003e getParcelableArrayList(@Nullable String key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ClassLoader"}, {"arrows": "to", "from": "public ArrayList\u003cT\u003e getParcelableArrayList(@Nullable String key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setClassLoader(ClassLoader)"}, {"arrows": "to", "from": "public void writeToStream(@NonNull OutputStream outputStream) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.util.proto.ProtoOutputStream"}, {"arrows": "to", "from": "public void writeToStream(@NonNull OutputStream outputStream) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.PersistableBundle"}, {"arrows": "to", "from": "public void writeToStream(@NonNull OutputStream outputStream) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readFromStream"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRawSize()"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, double val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, float val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, int val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, long val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, boolean val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, @Nullable String val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(long fieldId, @Nullable byte[] val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long start(long fieldId)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void end(long token)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeUnsignedVarintFromSignedInt(int val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeUtf8String(int id, String val)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private long startObjectImpl(final int id, boolean repeated)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void endObjectImpl(long token, boolean repeated)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long makeFieldId(int id, long fieldFlags)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int checkFieldId(long fieldId, long expectedFlags)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int getTagSize(int id)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeTag(int id, @WireType int wireType)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeKnownLengthHeader(int id, int size)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void assertNotCompacted()"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes()"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void compactIfNecessary()"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int editEncodedSize(int rawSize)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void compactSizes(int rawSize)"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void flush()"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int readRawTag()"}, {"arrows": "to", "from": "android.util.proto.ProtoOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void dump(@NonNull String tag)"}, {"arrows": "to", "from": "public void write(long fieldId, boolean val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalStateException"}, {"arrows": "to", "from": "public long start(long fieldId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "end(long)"}, {"arrows": "to", "from": "public void end(long token)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "start(long)"}, {"arrows": "to", "from": "public static int checkFieldId(long fieldId, long expectedFlags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalArgumentException"}, {"arrows": "to", "from": "public void flush()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flush()"}, {"arrows": "to", "from": "public void flush()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getBytes()"}, {"arrows": "to", "from": "public void flush()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "end(long)"}, {"arrows": "to", "from": "public static PersistableBundle readFromStream(@NonNull InputStream inputStream) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.PersistableBundle"}, {"arrows": "to", "from": "public static PersistableBundle readFromStream(@NonNull InputStream inputStream) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "writeToStream"}, {"arrows": "to", "from": "public static PersistableBundle readFromStream(@NonNull InputStream inputStream) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "public PersistableBundle getConfig()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isConfigForIdentifiedCarrier(PersistableBundle)"}, {"arrows": "to", "from": "public PersistableBundle getConfig()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ACTION_CARRIER_CONFIG_CHANGED"}, {"arrows": "to", "from": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getConfigForSubId(int)"}, {"arrows": "to", "from": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.PersistableBundle"}, {"arrows": "to", "from": "public static boolean isConfigForIdentifiedCarrier(PersistableBundle bundle)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getConfig()"}, {"arrows": "to", "from": "public void notifyConfigChangedForSubId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onLoadConfig"}, {"arrows": "to", "from": "public PersistableBundle getConfigByComponentForSubId(@NonNull String prefix, int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionManager"}, {"arrows": "to", "from": "public PersistableBundle getConfigByComponentForSubId(@NonNull String prefix, int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public void setSubscriptionPlans(int subId, @NonNull List\u003cSubscriptionPlan\u003e plans)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING"}, {"arrows": "to", "from": "public void setSubscriptionPlans(int subId, @NonNull List\u003cSubscriptionPlan\u003e plans)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionPlan"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getTitle()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence getSummary()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getDataLimitBytes()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDataLimitBehavior()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getDataUsageBytes()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getDataUsageTime()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int[] getNetworkTypes()"}, {"arrows": "to", "from": "android.telephony.SubscriptionPlan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Iterator\u003cRange\u003cZonedDateTime\u003e\u003e cycleIterator()"}, {"arrows": "to", "from": "public long getDataLimitBytes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDataLimitBehavior()"}, {"arrows": "to", "from": "public int getDataLimitBehavior()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDataLimitBytes()"}, {"arrows": "to", "from": "public long getDataUsageBytes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDataUsageTime()"}, {"arrows": "to", "from": "public long getDataUsageTime()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDataUsageBytes()"}, {"arrows": "to", "from": "public int[] getNetworkTypes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.Annotation.NetworkType"}, {"arrows": "to", "from": "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long timeoutMillis)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING"}, {"arrows": "to", "from": "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long timeoutMillis)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getOpportunisticSubscriptions()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getOpportunisticSubscriptions()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public boolean setOpportunistic(boolean opportunistic, int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public ParcelUuid createSubscriptionGroup(@NonNull List\u003cInteger\u003e subIdList)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getActiveSubscriptionInfoList()"}, {"arrows": "to", "from": "public ParcelUuid createSubscriptionGroup(@NonNull List\u003cInteger\u003e subIdList)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canManageSubscription(SubscriptionInfo)"}, {"arrows": "to", "from": "public ParcelUuid createSubscriptionGroup(@NonNull List\u003cInteger\u003e subIdList)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public void addSubscriptionsIntoGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createSubscriptionGroup(List)"}, {"arrows": "to", "from": "public void addSubscriptionsIntoGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canManageSubscription(SubscriptionInfo)"}, {"arrows": "to", "from": "public void addSubscriptionsIntoGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public void removeSubscriptionsFromGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createSubscriptionGroup(List)"}, {"arrows": "to", "from": "public void removeSubscriptionsFromGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canManageSubscription(SubscriptionInfo)"}, {"arrows": "to", "from": "public void removeSubscriptionsFromGroup(@NonNull List\u003cInteger\u003e subIdList, @NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createSubscriptionGroup(List)"}, {"arrows": "to", "from": "public List\u003cSubscriptionInfo\u003e getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public static int getActiveDataSubscriptionId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onActiveDataSubscriptionIdChanged(int)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onServiceStateChanged(ServiceState serviceState)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onMessageWaitingIndicatorChanged(boolean mwi)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onCallForwardingIndicatorChanged(boolean cfi)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onCellLocationChanged(CellLocation location)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onDataConnectionStateChanged(int state, int networkType)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onDataActivity(int direction)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onSignalStrengthsChanged(SignalStrength signalStrength)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onDisplayInfoChanged(@NonNull TelephonyDisplayInfo telephonyDisplayInfo)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onActiveDataSubscriptionIdChanged(int subId)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onRegistrationFailed(@NonNull CellIdentity cellIdentity, @NonNull String chosenPlmn, int domain, int causeCode, int additionalCauseCode)"}, {"arrows": "to", "from": "android.telephony.PhoneStateListener", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void onBarringInfoChanged(@NonNull BarringInfo barringInfo)"}, {"arrows": "to", "from": "public void onServiceStateChanged(ServiceState serviceState)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.ServiceState"}, {"arrows": "to", "from": "public void onServiceStateChanged(ServiceState serviceState)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ACCESS_FINE_LOCATION"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getState()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDuplexMode()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getChannelNumber()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int[] getCellBandwidths()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getRoaming()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getOperatorAlphaLong()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getOperatorAlphaShort()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getOperatorNumeric()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getIsManualSelection()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean equalsHandlesNulls(Object a, Object b)"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCdmaNetworkId()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCdmaSystemId()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cNetworkRegistrationInfo\u003e getNetworkRegistrationInfoList()"}, {"arrows": "to", "from": "android.telephony.ServiceState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isSearching()"}, {"arrows": "to", "from": "public String getOperatorNumeric()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "countryCodeForMcc(int)"}, {"arrows": "to", "from": "public int getCdmaNetworkId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNKNOWN_ID"}, {"arrows": "to", "from": "public int getCdmaSystemId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNKNOWN_ID"}, {"arrows": "to", "from": "public List\u003cNetworkRegistrationInfo\u003e getNetworkRegistrationInfoList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.NetworkRegistrationInfo"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTransportType()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDomain()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isRegistered()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isSearching()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRegisteredPlmn()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isRoaming()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cInteger\u003e getAvailableServices()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAccessNetworkTechnology()"}, {"arrows": "to", "from": "android.telephony.NetworkRegistrationInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentity getCellIdentity()"}, {"arrows": "to", "from": "public boolean isSearching()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRANSPORT_TYPE_WLAN"}, {"arrows": "to", "from": "public int getAccessNetworkTechnology()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.Annotation.NetworkType"}, {"arrows": "to", "from": "public CellIdentity getCellIdentity()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellIdentityNr"}, {"arrows": "to", "from": "public void onMessageWaitingIndicatorChanged(boolean mwi)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onCellLocationChanged(CellLocation location)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onCallStateChanged(@CallState int state, String phoneNumber)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onCallStateChanged(@CallState int state, String phoneNumber)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void onCallStateChanged(@CallState int state, String phoneNumber)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_CALL_LOG"}, {"arrows": "to", "from": "public void onDataConnectionStateChanged(int state)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onCellInfoChanged(List\u003cCellInfo\u003e cellInfo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onCallDisconnectCauseChanged(int disconnectCause, int preciseDisconnectCause)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.DisconnectCause"}, {"arrows": "to", "from": "public void onCallDisconnectCauseChanged(int disconnectCause, int preciseDisconnectCause)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onCallDisconnectCauseChanged(int disconnectCause, int preciseDisconnectCause)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.PreciseDisconnectCause"}, {"arrows": "to", "from": "public void onImsCallDisconnectCauseChanged(@NonNull ImsReasonInfo imsReasonInfo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onImsCallDisconnectCauseChanged(@NonNull ImsReasonInfo imsReasonInfo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.ims.ImsReasonInfo"}, {"arrows": "to", "from": "android.telephony.ims.ImsReasonInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCode()"}, {"arrows": "to", "from": "android.telephony.ims.ImsReasonInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getExtraCode()"}, {"arrows": "to", "from": "android.telephony.ims.ImsReasonInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getExtraMessage()"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.ims.ImsReasonInfo"}, {"arrows": "to", "from": "public void onPreciseDataConnectionStateChanged(@NonNull PreciseDataConnectionState dataConnectionState)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.PreciseDataConnectionState"}, {"arrows": "to", "from": "public void onPreciseDataConnectionStateChanged(@NonNull PreciseDataConnectionState dataConnectionState)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onPreciseDataConnectionStateChanged(@NonNull PreciseDataConnectionState dataConnectionState)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public void onPreciseDataConnectionStateChanged(@NonNull PreciseDataConnectionState dataConnectionState)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "android.telephony.PreciseDataConnectionState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getState()"}, {"arrows": "to", "from": "android.telephony.PreciseDataConnectionState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getNetworkType()"}, {"arrows": "to", "from": "android.telephony.PreciseDataConnectionState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public LinkProperties getLinkProperties()"}, {"arrows": "to", "from": "android.telephony.PreciseDataConnectionState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLastCauseCode()"}, {"arrows": "to", "from": "android.telephony.PreciseDataConnectionState", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ApnSetting getApnSetting()"}, {"arrows": "to", "from": "public LinkProperties getLinkProperties()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.LinkProperties"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setInterfaceName(@Nullable String iface)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getInterfaceName()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cLinkAddress\u003e getLinkAddresses()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setLinkAddresses(@NonNull Collection\u003cLinkAddress\u003e addresses)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setDnsServers(@NonNull Collection\u003cInetAddress\u003e dnsServers)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cInetAddress\u003e getDnsServers()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isPrivateDnsActive()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setDhcpServerAddress(@Nullable Inet4Address serverAddress)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Inet4Address getDhcpServerAddress()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getPrivateDnsServerName()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setDomains(@Nullable String domains)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getDomains()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setMtu(int mtu)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getMtu()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean addRoute(@NonNull RouteInfo route)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cRouteInfo\u003e getRoutes()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setHttpProxy(@Nullable ProxyInfo proxy)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ProxyInfo getHttpProxy()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IpPrefix getNat64Prefix()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setNat64Prefix(@Nullable IpPrefix prefix)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void clear()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean hasIpv4AddressOnInterface(String iface)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isWakeOnLanSupported()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.net.LinkProperties", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public void setInterfaceName(@Nullable String iface)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.RouteInfo"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IpPrefix getDestination()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getGateway()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getInterface()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isDefaultRoute()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasGateway()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean matches(InetAddress destination)"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.net.RouteInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public IpPrefix getDestination()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.IpPrefix"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getAddress()"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getRawAddress()"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPrefixLength()"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contains(@NonNull InetAddress address)"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.net.IpPrefix", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public InetAddress getAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public boolean contains(@NonNull InetAddress address)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public InetAddress getGateway()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public boolean matches(InetAddress destination)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public List\u003cLinkAddress\u003e getLinkAddresses()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.LinkAddress"}, {"arrows": "to", "from": "public List\u003cLinkAddress\u003e getLinkAddresses()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ArrayList"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean isIpv6ULA()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void init(InetAddress address, int prefixLength, int flags, int scope, long deprecationTime, long expirationTime)"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getAddress()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPrefixLength()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getFlags()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getScope()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.net.LinkAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public void setLinkAddresses(@NonNull Collection\u003cLinkAddress\u003e addresses)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": "public void setLinkAddresses(@NonNull Collection\u003cLinkAddress\u003e addresses)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.LinkAddress"}, {"arrows": "to", "from": "public void setDnsServers(@NonNull Collection\u003cInetAddress\u003e dnsServers)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public void setDnsServers(@NonNull Collection\u003cInetAddress\u003e dnsServers)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": "public List\u003cInetAddress\u003e getDnsServers()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public List\u003cInetAddress\u003e getDnsServers()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ArrayList"}, {"arrows": "to", "from": "public boolean isPrivateDnsActive()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPrivateDnsServerName"}, {"arrows": "to", "from": "public String getPrivateDnsServerName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDnsServers"}, {"arrows": "to", "from": "public String getPrivateDnsServerName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isPrivateDnsActive"}, {"arrows": "to", "from": "public void setDomains(@Nullable String domains)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "String"}, {"arrows": "to", "from": "public String getDomains()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "String"}, {"arrows": "to", "from": "public boolean addRoute(@NonNull RouteInfo route)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.RouteInfo"}, {"arrows": "to", "from": "public boolean addRoute(@NonNull RouteInfo route)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RouteInfo.RouteKey"}, {"arrows": "to", "from": "public boolean addRoute(@NonNull RouteInfo route)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalArgumentException"}, {"arrows": "to", "from": "public List\u003cRouteInfo\u003e getRoutes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.RouteInfo"}, {"arrows": "to", "from": "public List\u003cRouteInfo\u003e getRoutes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ArrayList"}, {"arrows": "to", "from": "public void setHttpProxy(@Nullable ProxyInfo proxy)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ProxyInfo"}, {"arrows": "to", "from": "android.net.ProxyInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ProxyInfo buildPacProxy(Uri pacUri)"}, {"arrows": "to", "from": "android.net.ProxyInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Uri getPacFileUrl()"}, {"arrows": "to", "from": "android.net.ProxyInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getHost()"}, {"arrows": "to", "from": "android.net.ProxyInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPort()"}, {"arrows": "to", "from": "android.net.ProxyInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] getExclusionList()"}, {"arrows": "to", "from": "android.net.ProxyInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isValid()"}, {"arrows": "to", "from": "public static ProxyInfo buildDirectProxy(String host, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ProxyInfo"}, {"arrows": "to", "from": "public static ProxyInfo buildDirectProxy(String host, int port, List\u003cString\u003e exclList)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ProxyInfo"}, {"arrows": "to", "from": "public static ProxyInfo buildPacProxy(@NonNull Uri pacUrl, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ProxyInfo"}, {"arrows": "to", "from": "public ProxyInfo getHttpProxy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ProxyInfo"}, {"arrows": "to", "from": "public int getLastCauseCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getState"}, {"arrows": "to", "from": "public void onUserMobileDataStateChanged(boolean enabled)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyManager"}, {"arrows": "to", "from": "public void onDisplayInfoChanged(@NonNull TelephonyDisplayInfo telephonyDisplayInfo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.TelephonyDisplayInfo"}, {"arrows": "to", "from": "public void onDisplayInfoChanged(@NonNull TelephonyDisplayInfo telephonyDisplayInfo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void onDisplayInfoChanged(@NonNull TelephonyDisplayInfo telephonyDisplayInfo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "android.telephony.TelephonyDisplayInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getNetworkType()"}, {"arrows": "to", "from": "android.telephony.TelephonyDisplayInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getOverrideNetworkType()"}, {"arrows": "to", "from": "public int getVoiceNetworkType()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int getVoiceNetworkType()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getSimOperator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIM_STATE_READY"}, {"arrows": "to", "from": "public String getSimOperatorName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIM_STATE_READY"}, {"arrows": "to", "from": "public String getSimSerialNumber()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getSimSerialNumber()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getSimSerialNumber()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRoleHeld(String)"}, {"arrows": "to", "from": "public int getCardIdForDefaultEuicc()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNINITIALIZED_CARD_ID"}, {"arrows": "to", "from": "public int getCardIdForDefaultEuicc()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNSUPPORTED_CARD_ID"}, {"arrows": "to", "from": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isEuicc()"}, {"arrows": "to", "from": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCardId()"}, {"arrows": "to", "from": "public List\u003cUiccCardInfo\u003e getUiccCardsInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.UiccCardInfo"}, {"arrows": "to", "from": "public String getSubscriberId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getSubscriberId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getSubscriberId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRoleHeld(String)"}, {"arrows": "to", "from": "public String getGroupIdLevel1()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getGroupIdLevel1()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getLine1Number()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getLine1Number()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_SMS"}, {"arrows": "to", "from": "public String getLine1Number()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public String getLine1Number()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_NUMBERS"}, {"arrows": "to", "from": "public boolean setLine1NumberForDisplay(String alphaTag, String number)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getVoiceMailNumber()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getVoiceMailNumber()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public boolean setVoiceMailNumber(String alphaTag, String number)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getVisualVoicemailPackageName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getVisualVoicemailPackageName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public void setVisualVoicemailSmsFilterSettings(VisualVoicemailSmsFilterSettings settings)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onSmsReceived(VisualVoicemailTask"}, {"arrows": "to", "from": "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SEND_SMS"}, {"arrows": "to", "from": "public void sendVisualVoicemailSms(String number, int port, String text, PendingIntent sentIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.VisualVoicemailService"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ArrayList\u003cString\u003e divideMessage(String text)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, long messageId)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static ISms getISmsServiceOrThrow()"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getDefaultSmsSubscriptionId()"}, {"arrows": "to", "from": "android.telephony.SmsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setSmscAddress(@NonNull String smsc)"}, {"arrows": "to", "from": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.provider.Telephony"}, {"arrows": "to", "from": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SEND_SMS"}, {"arrows": "to", "from": "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.app.PendingIntent"}, {"arrows": "to", "from": "android.app.PendingIntent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void create()"}, {"arrows": "to", "from": "android.app.PendingIntent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void createWithCancelFlag()"}, {"arrows": "to", "from": "android.app.PendingIntent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void createWithUpdateFlag()"}, {"arrows": "to", "from": "android.app.PendingIntent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void cancel()"}, {"arrows": "to", "from": "public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sendTextMessage("}, {"arrows": "to", "from": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SEND_SMS"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESULT_SMS_GENERIC_ERROR"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT_3GPP2"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESULT_SMS_HANDLED"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESULT_REMOTE_EXCEPTION"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SmsMessage createFromPdu(byte[] pdu, String format)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getTPLayerLengthForPDU(String pdu)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int[] calculateLength(CharSequence msgBody, boolean use7bitOnly)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int[] calculateLength(String messageBody, boolean use7bitOnly)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SubmitPdu getSubmitPdu(String scAddress, String destinationAddress, String message, boolean statusReportRequested)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SubmitPdu getSubmitPdu(String scAddress, String destinationAddress, short destinationPort, byte[] data, boolean statusReportRequested)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getServiceCenterAddress()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getOriginatingAddress()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getDisplayOriginatingAddress()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMessageBody()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public MessageClass getMessageClass()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getDisplayMessageBody()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getPseudoSubject()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getTimestampMillis()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isEmail()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getEmailBody()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getEmailFrom()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getProtocolIdentifier()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isReplace()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isCphsMwiMessage()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMWIClearMessage()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMWISetMessage()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMwiDontStore()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getUserData()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getPdu()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getStatusOnIcc()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getIndexOnIcc()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getStatus()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isStatusReportMessage()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isReplyPathPresent()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean useCdmaFormatForMoSms()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean useCdmaFormatForMoSms(int subId)"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isCdmaVoice()"}, {"arrows": "to", "from": "android.telephony.SmsMessage", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isCdmaVoice(int subId)"}, {"arrows": "to", "from": "public static SmsMessage createFromPdu(byte[] pdu, String format)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SMS_RECEIVED_ACTION"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.provider.Telephony"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SEND_SMS"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList\u003cString\u003e parts, ArrayList\u003cPendingIntent\u003e sentIntents, ArrayList\u003cPendingIntent\u003e deliveryIntents)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.app.PendingIntent"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List\u003cString\u003e parts, @Nullable List\u003cPendingIntent\u003e sentIntents, @Nullable List\u003cPendingIntent\u003e deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SEND_SMS"}, {"arrows": "to", "from": "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.app.PendingIntent"}, {"arrows": "to", "from": "public static SmsManager getDefault()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public static SmsManager getDefault()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public static SmsManager getSmsManagerForSubscriptionId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public static SmsManager getSmsManagerForSubscriptionId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SubscriptionManager"}, {"arrows": "to", "from": "public static SmsManager getSmsManagerForSubscriptionId(int subId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSubscriptionId()"}, {"arrows": "to", "from": "private ArrayList\u003cSmsMessage\u003e createMessageListFromRawRecords(List\u003cSmsRawData\u003e records)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "private ArrayList\u003cSmsMessage\u003e createMessageListFromRawRecords(List\u003cSmsRawData\u003e records)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "private ArrayList\u003cSmsMessage\u003e createMessageListFromRawRecords(List\u003cSmsRawData\u003e records)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public Bundle getCarrierConfigValues()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public Bundle getCarrierConfigValues()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public Bundle getCarrierConfigValues()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public String createAppSpecificSmsToken(PendingIntent intent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public String createAppSpecificSmsToken(PendingIntent intent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public String createAppSpecificSmsToken(PendingIntent intent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public String getSmscAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public String getSmscAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.SmsManager"}, {"arrows": "to", "from": "public String getSmscAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public boolean setSmscAddress(@NonNull String smsc)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public boolean setSmscAddress(@NonNull String smsc)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSmsManagerForSubscriptionId(int)"}, {"arrows": "to", "from": "public boolean setSmscAddress(@NonNull String smsc)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public String getVoiceMailAlphaTag()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getVoiceMailAlphaTag()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public void sendDialerSpecialCode(String inputCode)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int getCallState()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telecom.ConnectionService"}, {"arrows": "to", "from": "public void listen(PhoneStateListener listener, int events)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public void listen(PhoneStateListener listener, int events)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalStateException"}, {"arrows": "to", "from": "public void listen(PhoneStateListener listener, int events)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "clearCallingIdentity()"}, {"arrows": "to", "from": "public void listen(PhoneStateListener listener, int events)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SecurityException"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellInfoLte"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellInfoTdscdma"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellInfoGsm"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellInfoCdma"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestCellInfoUpdate"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellInfoWcdma"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellInfo"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FEATURE_TELEPHONY"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Q"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public List\u003cCellInfo\u003e getAllCellInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCellLocation"}, {"arrows": "to", "from": "android.telephony.CellInfoLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentityLte getCellIdentity()"}, {"arrows": "to", "from": "android.telephony.CellInfoLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellSignalStrengthLte getCellSignalStrength()"}, {"arrows": "to", "from": "android.telephony.CellInfoLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.telephony.CellInfoLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellInfoLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellInfoLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public CellIdentityLte getCellIdentity()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellIdentityLte"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCi()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPci()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTac()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEarfcn()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int[] getBands()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getBandwidth()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMccString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMncString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMobileNetworkOperator()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cString\u003e getAdditionalPlmns()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ClosedSubscriberGroupInfo getClosedSubscriberGroupInfo()"}, {"arrows": "to", "from": "android.telephony.CellIdentityLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public int getCi()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "android.telephony.CellInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentity getCellIdentity()"}, {"arrows": "to", "from": "android.telephony.CellInfo", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellSignalStrength getCellSignalStrength()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getNci()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getNrarfcn()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int[] getBands()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPci()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTac()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMccString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMncString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cString\u003e getAdditionalPlmns()"}, {"arrows": "to", "from": "public int getNrarfcn()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getPci()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getTac()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public CellSignalStrength getCellSignalStrength()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellSignalStrengthNr"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int flip(int val)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSsRsrp()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSsRsrq()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSsSinr()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCsiRsrp()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCsiRsrq()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCsiSinr()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int updateLevelWithMeasure(int measure, int[] thresholds)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAsuLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthNr", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDbm()"}, {"arrows": "to", "from": "public int getSsRsrp()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getSsRsrq()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getSsSinr()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getCsiRsrp()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getCsiRsrq()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getCsiSinr()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "USE_SSSINR"}, {"arrows": "to", "from": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLevel()"}, {"arrows": "to", "from": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "USE_SSRSRP"}, {"arrows": "to", "from": "private boolean isLevelForParameter(@SignalLevelAndReportCriteriaSource int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "USE_SSRSRQ"}, {"arrows": "to", "from": "public int getAsuLevel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getDbm()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getEarfcn()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getBandwidth()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public CellSignalStrengthLte getCellSignalStrength()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellSignalStrengthLte"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean isLevelForParameter(int parameterType)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int updateLevelWithMeasure(int measure, int[] thresholds)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRsrq()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRssi()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRssnr()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRsrp()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCqi()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAsuLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTimingAdvance()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthLte", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "private boolean isLevelForParameter(int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "USE_RSSNR"}, {"arrows": "to", "from": "private boolean isLevelForParameter(int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLevel()"}, {"arrows": "to", "from": "private boolean isLevelForParameter(int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "USE_RSRQ"}, {"arrows": "to", "from": "private boolean isLevelForParameter(int parameterType)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "USE_RSRP"}, {"arrows": "to", "from": "public int getRsrq()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getRssi()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getRssnr()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getCqi()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getTimingAdvance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "android.telephony.CellInfoTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentityTdscdma getCellIdentity()"}, {"arrows": "to", "from": "android.telephony.CellInfoTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellSignalStrengthTdscdma getCellSignalStrength()"}, {"arrows": "to", "from": "android.telephony.CellInfoTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.telephony.CellInfoTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellInfoTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellInfoTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public CellIdentityTdscdma getCellIdentity()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellIdentityTdscdma"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMccString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMncString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMobileNetworkOperator()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLac()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCid()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCpid()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getUarfcn()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cString\u003e getAdditionalPlmns()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ClosedSubscriberGroupInfo getClosedSubscriberGroupInfo()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellIdentityTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public int getLac()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getCid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getCpid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getUarfcn()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public CellSignalStrengthTdscdma getCellSignalStrength()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellSignalStrengthTdscdma"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRscp()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAsuLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthTdscdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public int getRscp()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "android.telephony.CellInfoGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentityGsm getCellIdentity()"}, {"arrows": "to", "from": "android.telephony.CellInfoGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellSignalStrengthGsm getCellSignalStrength()"}, {"arrows": "to", "from": "android.telephony.CellInfoGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.telephony.CellInfoGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellInfoGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellInfoGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public CellIdentityGsm getCellIdentity()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellIdentityGsm"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLac()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCid()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getArfcn()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getBsic()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMobileNetworkOperator()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMccString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMncString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cString\u003e getAdditionalPlmns()"}, {"arrows": "to", "from": "android.telephony.CellIdentityGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public int getArfcn()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getBsic()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public CellSignalStrengthGsm getCellSignalStrength()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellSignalStrengthGsm"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTimingAdvance()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAsuLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRssi()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getBitErrorRate()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthGsm", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public int getBitErrorRate()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "android.telephony.CellInfoCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentityCdma getCellIdentity()"}, {"arrows": "to", "from": "android.telephony.CellInfoCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellSignalStrengthCdma getCellSignalStrength()"}, {"arrows": "to", "from": "android.telephony.CellInfoCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.telephony.CellInfoCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellInfoCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellInfoCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public CellIdentityCdma getCellIdentity()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellIdentityCdma"}, {"arrows": "to", "from": "android.telephony.CellIdentityCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getNetworkId()"}, {"arrows": "to", "from": "android.telephony.CellIdentityCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSystemId()"}, {"arrows": "to", "from": "android.telephony.CellIdentityCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getBasestationId()"}, {"arrows": "to", "from": "android.telephony.CellIdentityCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLongitude()"}, {"arrows": "to", "from": "android.telephony.CellIdentityCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLatitude()"}, {"arrows": "to", "from": "android.telephony.CellIdentityCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public int getNetworkId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getSystemId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getBasestationId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getLongitude()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public int getLatitude()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public CellSignalStrengthCdma getCellSignalStrength()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellSignalStrengthCdma"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAsuLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCdmaLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEvdoLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCdmaDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCdmaEcio()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEvdoDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEvdoEcio()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEvdoSnr()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthCdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "android.telephony.CellInfoWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellIdentityWcdma getCellIdentity()"}, {"arrows": "to", "from": "android.telephony.CellInfoWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CellSignalStrengthWcdma getCellSignalStrength()"}, {"arrows": "to", "from": "android.telephony.CellInfoWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "android.telephony.CellInfoWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellInfoWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellInfoWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "public CellIdentityWcdma getCellIdentity()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellIdentityWcdma"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLac()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getCid()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPsc()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMccString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMncString()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMobileNetworkOperator()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getUarfcn()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cString\u003e getAdditionalPlmns()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ClosedSubscriberGroupInfo getClosedSubscriberGroupInfo()"}, {"arrows": "to", "from": "android.telephony.CellIdentityWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "public int getPsc()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public CellSignalStrengthWcdma getCellSignalStrength()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.CellSignalStrengthWcdma"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getDbm()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getAsuLevel()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEcNo()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeToParcel(Parcel dest, int flags)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int describeContents()"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void log(String s)"}, {"arrows": "to", "from": "android.telephony.CellSignalStrengthWcdma", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void loge(String s)"}, {"arrows": "to", "from": "public int getEcNo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNAVAILABLE"}, {"arrows": "to", "from": "public void requestCellInfoUpdate(@NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FEATURE_TELEPHONY"}, {"arrows": "to", "from": "private int getSubId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "private int getSubId(int preferredSubId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "private int getPhoneId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "private int getPhoneId(int preferredSubId)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public String[] getForbiddenPlmns()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String[] getForbiddenPlmns()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public int setForbiddenPlmns(@NonNull List\u003cString\u003e fplmns)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int setForbiddenPlmns(@NonNull List\u003cString\u003e fplmns)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATEMODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public void setNetworkSelectionModeAutomatic()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public void setNetworkSelectionModeAutomatic()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void setNetworkSelectionModeAutomatic()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ACCESS_FINE_LOCATION"}, {"arrows": "to", "from": "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNKNOWN"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean setNetworkSelectionModeManual(@NonNull String operatorNumeric, boolean persistSelection, @AccessNetworkConstants.RadioAccessNetworkType int ran)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public int getNetworkSelectionMode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public int getNetworkSelectionMode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE"}, {"arrows": "to", "from": "public int getNetworkSelectionMode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public String getManualNetworkSelectionPlmn()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE"}, {"arrows": "to", "from": "public String getManualNetworkSelectionPlmn()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean setPreferredNetworkTypeToGlobal()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean setOperatorBrandOverride(String brand)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UssdResponseCallback"}, {"arrows": "to", "from": "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.Handler"}, {"arrows": "to", "from": "public void sendUssdRequest(String ussdRequest, final UssdResponseCallback callback, Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CALL_PHONE"}, {"arrows": "to", "from": "public void setDataEnabled(boolean enable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public void setDataEnabled(boolean enable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefaultDataSubscriptionId()"}, {"arrows": "to", "from": "public void setDataEnabled(boolean enable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void setDataEnabled(boolean enable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public boolean isDataEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public boolean isDataEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ACCESS_NETWORK_STATE"}, {"arrows": "to", "from": "public boolean isDataEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRestrictBackgroundStatus"}, {"arrows": "to", "from": "public boolean isDataEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefaultDataSubscriptionId()"}, {"arrows": "to", "from": "public boolean isDataEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean isDataEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Network getActiveNetwork()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Network[] getAllNetworks()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public LinkProperties getLinkProperties(@Nullable Network network)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public NetworkCapabilities getNetworkCapabilities(@Nullable Network network)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void addDefaultNetworkActiveListener(final OnNetworkActiveListener l)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void removeDefaultNetworkActiveListener(@NonNull OnNetworkActiveListener l)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isDefaultNetworkActive()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void reportNetworkConnectivity(@Nullable Network network, boolean hasConnectivity)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ProxyInfo getDefaultProxy()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isActiveNetworkMetered()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void releaseNetworkRequest(@NonNull PendingIntent operation)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean requestBandwidthUpdate(@NonNull Network network)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void unregisterNetworkCallback(@NonNull PendingIntent operation)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getMultipathPreference(@Nullable Network network)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean bindProcessToNetwork(@Nullable Network network)"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Network getBoundNetworkForProcess()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void checkLegacyRoutingApiAccess()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRestrictBackgroundStatus()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getNetworkWatchlistConfigHash()"}, {"arrows": "to", "from": "android.net.ConnectivityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)"}, {"arrows": "to", "from": "public Network getActiveNetwork()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void register()"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void terminate()"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void handleAddRequest(NetworkRequest request, int score, int servingProviderId)"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean acceptRequest(NetworkRequest request, int score)"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void reevaluateAllRequests()"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void releaseRequestAsUnfulfillableByAnyFactory(NetworkRequest r)"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void startNetwork()"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void needNetworkFor(NetworkRequest networkRequest, int score)"}, {"arrows": "to", "from": "android.net.Network", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSerialNumber()"}, {"arrows": "to", "from": "public boolean acceptRequest(NetworkRequest request, int score)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "startNetwork"}, {"arrows": "to", "from": "public boolean acceptRequest(NetworkRequest request, int score)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "releaseNetworkFor"}, {"arrows": "to", "from": "public boolean acceptRequest(NetworkRequest request, int score)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "needNetworkFor"}, {"arrows": "to", "from": "public boolean acceptRequest(NetworkRequest request, int score)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "stopNetwork"}, {"arrows": "to", "from": "protected void releaseRequestAsUnfulfillableByAnyFactory(NetworkRequest r)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onUnavailable()"}, {"arrows": "to", "from": "public Network[] getAllNetworks()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public LinkProperties getLinkProperties(@Nullable Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public LinkProperties getLinkProperties(@Nullable Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.LinkProperties"}, {"arrows": "to", "from": "public NetworkCapabilities getNetworkCapabilities(@Nullable Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "public NetworkCapabilities getNetworkCapabilities(@Nullable Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.SocketKeepalive"}, {"arrows": "to", "from": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SocketKeepalive.Callback"}, {"arrows": "to", "from": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.annotation.CallbackExecutor"}, {"arrows": "to", "from": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.IpSecManager.UdpEncapsulationSocket"}, {"arrows": "to", "from": "public void addDefaultNetworkActiveListener(final OnNetworkActiveListener l)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDefaultNetworkActive()"}, {"arrows": "to", "from": "public void addDefaultNetworkActiveListener(final OnNetworkActiveListener l)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bindProcessToNetwork"}, {"arrows": "to", "from": "public void removeDefaultNetworkActiveListener(@NonNull OnNetworkActiveListener l)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "addDefaultNetworkActiveListener"}, {"arrows": "to", "from": "public void reportNetworkConnectivity(@Nullable Network network, boolean hasConnectivity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public ProxyInfo getDefaultProxy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public ProxyInfo getDefaultProxy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bindProcessToNetwork"}, {"arrows": "to", "from": "public ProxyInfo getDefaultProxy()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ProxyInfo"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CHANGE_NETWORK_STATE"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork(NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onLinkPropertiesChanged(Network"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canWrite"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onCapabilitiesChanged(Network"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onAvailable(Network)"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerNetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(NetworkCallback)"}, {"arrows": "to", "from": "android.net.ConnectivityDiagnosticsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerConnectivityDiagnosticsCallback(@NonNull NetworkRequest request, @NonNull Executor e, @NonNull ConnectivityDiagnosticsCallback callback)"}, {"arrows": "to", "from": "android.net.ConnectivityDiagnosticsManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void unregisterConnectivityDiagnosticsCallback(@NonNull ConnectivityDiagnosticsCallback callback)"}, {"arrows": "to", "from": "public void registerConnectivityDiagnosticsCallback(@NonNull NetworkRequest request, @NonNull Executor e, @NonNull ConnectivityDiagnosticsCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.ConnectivityManager"}, {"arrows": "to", "from": "public void registerConnectivityDiagnosticsCallback(@NonNull NetworkRequest request, @NonNull Executor e, @NonNull ConnectivityDiagnosticsCallback callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.Handler"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork(NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerNetworkCallback(NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(NetworkCallback)"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork(NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onUnavailable()"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.Handler"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onUnavailable"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork(NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "releaseNetworkRequest(android.app.PendingIntent)"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CHANGE_NETWORK_STATE"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "releaseNetworkRequest(PendingIntent)"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerReceiver"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkCapabilities"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.app.PendingIntent"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canWrite"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onAvailable"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(PendingIntent)"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EXTRA_NETWORK_REQUEST"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerNetworkCallback"}, {"arrows": "to", "from": "public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EXTRA_NETWORK"}, {"arrows": "to", "from": "android.content.Context", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void attachBaseContext(Context base)"}, {"arrows": "to", "from": "android.content.Context", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Context getBaseContext()"}, {"arrows": "to", "from": "public void releaseNetworkRequest(@NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(android.app.PendingIntent)"}, {"arrows": "to", "from": "public void releaseNetworkRequest(@NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork(NetworkRequest"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(NetworkCallback)"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.Handler"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(NetworkCallback)"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "releaseNetworkRequest(PendingIntent)"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerReceiver"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.app.PendingIntent"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.NetworkRequest"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "onAvailable"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(PendingIntent)"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EXTRA_NETWORK_REQUEST"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(android.app.PendingIntent)"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork"}, {"arrows": "to", "from": "public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EXTRA_NETWORK"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(NetworkCallback)"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerConnectivityDiagnosticsCallback"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.Handler"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unregisterNetworkCallback(NetworkCallback)"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork"}, {"arrows": "to", "from": "public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public boolean requestBandwidthUpdate(@NonNull Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerNetworkCallback(NetworkRequest"}, {"arrows": "to", "from": "public boolean requestBandwidthUpdate(@NonNull Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ConnectivityManager.NetworkCallback"}, {"arrows": "to", "from": "public boolean requestBandwidthUpdate(@NonNull Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerNetworkCallback(NetworkRequest"}, {"arrows": "to", "from": "public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "requestNetwork(NetworkRequest"}, {"arrows": "to", "from": "public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NetworkCallback"}, {"arrows": "to", "from": "public void unregisterNetworkCallback(@NonNull PendingIntent operation)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "registerNetworkCallback(NetworkRequest"}, {"arrows": "to", "from": "public boolean bindProcessToNetwork(@Nullable Network network)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public Network getBoundNetworkForProcess()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.net.Network"}, {"arrows": "to", "from": "public Network getBoundNetworkForProcess()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bindProcessToNetwork"}, {"arrows": "to", "from": "public int getRestrictBackgroundStatus()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESTRICT_BACKGROUND_STATUS_ENABLED"}, {"arrows": "to", "from": "public int getRestrictBackgroundStatus()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESTRICT_BACKGROUND_STATUS_DISABLED"}, {"arrows": "to", "from": "public int getRestrictBackgroundStatus()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RESTRICT_BACKGROUND_STATUS_WHITELISTED"}, {"arrows": "to", "from": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "INVALID_UID"}, {"arrows": "to", "from": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SecurityException"}, {"arrows": "to", "from": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetSocketAddress"}, {"arrows": "to", "from": "public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalArgumentException"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native long getElapsedCpuTime()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final long getStartElapsedRealtime()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final long getStartUptimeMillis()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean is64Bit()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final int myPid()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final int myTid()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final int myUid()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static UserHandle myUserHandle()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isApplicationUid(int uid)"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean isIsolated()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native int getUidForName(String name)"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native int getGidForName(String name)"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native void setThreadPriority(int tid, int priority) throws IllegalArgumentException, SecurityException"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native int[] getExclusiveCores()"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native void setThreadPriority(int priority) throws IllegalArgumentException, SecurityException"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native int getThreadPriority(int tid) throws IllegalArgumentException"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final void killProcess(int pid)"}, {"arrows": "to", "from": "android.os.Process", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final native void sendSignal(int pid, int signal)"}, {"arrows": "to", "from": "public static final long getStartElapsedRealtime()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "elapsedRealtime()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sleep(long ms)"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean setCurrentTimeMillis(long millis)"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long uptimeMillis()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long elapsedRealtime()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long elapsedRealtimeNanos()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long currentThreadTimeMillis()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Clock currentGnssTimeClock()"}, {"arrows": "to", "from": "public static void sleep(long ms)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "interrupt()"}, {"arrows": "to", "from": "public static void sleep(long ms)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sleep(long)"}, {"arrows": "to", "from": "public static void sleep(long ms)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "InterruptedException"}, {"arrows": "to", "from": "public static Clock currentGnssTimeClock()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.time.Clock"}, {"arrows": "to", "from": "public static final int myPid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "killProcess"}, {"arrows": "to", "from": "public static final int myPid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sendSignal"}, {"arrows": "to", "from": "public static final int myTid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setThreadPriority(int"}, {"arrows": "to", "from": "public static final int myUid()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "myUserHandle"}, {"arrows": "to", "from": "public static UserHandle myUserHandle()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "myUid()"}, {"arrows": "to", "from": "public static final native void setThreadPriority(int tid, int priority) throws IllegalArgumentException, SecurityException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Thread"}, {"arrows": "to", "from": "public static final native void setThreadPriority(int priority) throws IllegalArgumentException, SecurityException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setThreadPriority(int"}, {"arrows": "to", "from": "public boolean isDataRoamingEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public boolean isDataRoamingEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ACCESS_NETWORK_STATE"}, {"arrows": "to", "from": "public boolean isDataRoamingEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefaultDataSubscriptionId()"}, {"arrows": "to", "from": "public boolean isDataRoamingEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean isDataRoamingEnabled()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public ServiceState getServiceState()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public ServiceState getServiceState()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ACCESS_COARSE_LOCATION"}, {"arrows": "to", "from": "public ServiceState getServiceState()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.ServiceState"}, {"arrows": "to", "from": "public ServiceState getServiceState()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public ServiceState getServiceState()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public Uri getVoicemailRingtoneUri(PhoneAccountHandle accountHandle)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telecom.PhoneAccount"}, {"arrows": "to", "from": "android.telecom.PhoneAccount", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ComponentName getComponentName()"}, {"arrows": "to", "from": "android.telecom.PhoneAccount", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getId()"}, {"arrows": "to", "from": "android.telecom.PhoneAccount", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public UserHandle getUserHandle()"}, {"arrows": "to", "from": "public UserHandle getUserHandle()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.UserHandle"}, {"arrows": "to", "from": "android.os.UserHandle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static UserHandle getUserHandleForUid(int uid)"}, {"arrows": "to", "from": "android.os.UserHandle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void writeToParcel(UserHandle h, Parcel out)"}, {"arrows": "to", "from": "android.os.UserHandle", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static UserHandle readFromParcel(Parcel in)"}, {"arrows": "to", "from": "public static void writeToParcel(UserHandle h, Parcel out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readFromParcel(Parcel)"}, {"arrows": "to", "from": "public static UserHandle readFromParcel(Parcel in)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "writeToParcel(UserHandle"}, {"arrows": "to", "from": "public boolean isVoicemailVibrationEnabled(PhoneAccountHandle accountHandle)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telecom.PhoneAccount"}, {"arrows": "to", "from": "public int getSimCarrierId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNKNOWN_CARRIER_ID"}, {"arrows": "to", "from": "public CharSequence getSimCarrierIdName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimOperatorName()"}, {"arrows": "to", "from": "public CharSequence getSimCarrierIdName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimCarrierId()"}, {"arrows": "to", "from": "public int getSimSpecificCarrierId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimCarrierId()"}, {"arrows": "to", "from": "public int getSimSpecificCarrierId()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNKNOWN_CARRIER_ID"}, {"arrows": "to", "from": "public CharSequence getSimSpecificCarrierIdName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimCarrierIdName()"}, {"arrows": "to", "from": "public CharSequence getSimSpecificCarrierIdName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimSpecificCarrierId()"}, {"arrows": "to", "from": "public int getCarrierIdFromSimMccMnc()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimCarrierId()"}, {"arrows": "to", "from": "public int getCarrierIdFromSimMccMnc()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNKNOWN_CARRIER_ID"}, {"arrows": "to", "from": "public int getCarrierIdFromSimMccMnc()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSimOperator()"}, {"arrows": "to", "from": "public boolean isManualNetworkSelectionAllowed()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createForSubscriptionId"}, {"arrows": "to", "from": "public boolean isManualNetworkSelectionAllowed()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PRECISE_PHONE_STATEREAD_PRECISE_PHONE_STATE"}, {"arrows": "to", "from": "public boolean isManualNetworkSelectionAllowed()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EMERGENCY_NUMBER_SOURCE_DATABASE"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.emergency.EmergencyNumber"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getNumber()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getCountryIso()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMnc()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cInteger\u003e getEmergencyServiceCategories()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cString\u003e getEmergencyUrns()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean serviceUnspecified()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isInEmergencyServiceCategories(@EmergencyServiceCategories int categories)"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cInteger\u003e getEmergencyNumberSources()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isFromSources(@EmergencyNumberSources int sources)"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getEmergencyCallRouting()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int getDisplayPriorityScore()"}, {"arrows": "to", "from": "android.telephony.emergency.EmergencyNumber", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(@NonNull EmergencyNumber emergencyNumber)"}, {"arrows": "to", "from": "public List\u003cInteger\u003e getEmergencyServiceCategories()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED"}, {"arrows": "to", "from": "private boolean serviceUnspecified()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED"}, {"arrows": "to", "from": "public boolean isInEmergencyServiceCategories(@EmergencyServiceCategories int categories)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EMERGENCY_NUMBER_SOURCE_DATABASE"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.telephony.emergency.EmergencyNumber"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EMERGENCY_SERVICE_CATEGORY_UNSPECIFIED"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public Map\u003cInteger, List\u003cEmergencyNumber\u003e\u003e getEmergencyNumberList(@EmergencyServiceCategories int categories)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public boolean isEmergencyNumber(@NonNull String number)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDialable(char)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isISODigit(char c)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean is12Key(char c)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean isDialable(char c)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean isReallyDialable(char c)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean isNonSeparator(char c)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final boolean isStartsPostDial(char c)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isSeparator(char ch)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getNumberFromIntent(Intent intent, Context context)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String extractNetworkPortion(String phoneNumber)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String stripSeparators(String phoneNumber)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int minPositive(int a, int b)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int indexOfLastNetworkChar(String a)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean compare(String a, String b)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean compare(Context context, String a, String b)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toCallerIDMinMatch(String phoneNumber)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getStrippedReversed(String phoneNumber)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String internalGetStrippedReversed(String np, int numDigits)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String stringFromStringAndTOA(String s, int TOA)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String calledPartyBCDToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, @BcdExtendType int bcdExtType)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static char bcdToChar(byte b, @BcdExtendType int bcdExtType)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isWellFormedSmsAddress(String address)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte[] networkPortionToCalledPartyBCD(String s)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte[] networkPortionToCalledPartyBCDWithLength(String s)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte[] numberToCalledPartyBCD(String number, @BcdExtendType int bcdExtType)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, @BcdExtendType int bcdExtType)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void removeDashes(Editable text)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String formatNumberToE164(String phoneNumber, String defaultCountryIso)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String formatNumberToRFC3966(String phoneNumber, String defaultCountryIso)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String formatNumberInternal(String rawPhoneNumber, String defaultCountryIso, PhoneNumberFormat formatIdentifier)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String formatNumber(String phoneNumber, String defaultCountryIso)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String formatNumber(String phoneNumber, String phoneNumberE164, String defaultCountryIso)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String normalizeNumber(String phoneNumber)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String replaceUnicodeDigits(String number)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isEmergencyNumberInternal(String number, boolean useExactMatch)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isEmergencyNumberInternal(int subId, String number, boolean useExactMatch)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isEmergencyNumberInternal(String number, String defaultCountryIso, boolean useExactMatch)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isVoiceMailNumber(String number)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String convertKeypadLettersToDigits(String input)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static CharSequence createTtsSpannable(CharSequence phoneNumber)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void addTtsSpan(Spannable s, int start, int endExclusive)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static TtsSpan createTtsSpan(String phoneNumberString)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String splitAtNonNumerics(CharSequence number)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isOneNanp(String dialStr)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String processPlusCode(String networkDialStr, boolean useNanp)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int findDialableIndexFromPostDialStr(String postDialStr)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String appendPwCharBackToOrigDialStr(int dialableIndex, String origStr, String dialStr)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean matchIntlPrefix(String a, int len)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean matchIntlPrefixAndCC(String a, int len)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean matchTrunkPrefix(String a, int len)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isCountryCallingCode(int countryCallingCodeCandidate)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int tryGetISODigit(char ch)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static CountryCallingCodeAndNewIndex tryGetCountryCallingCodeAndNewIndex(String str, boolean acceptThailandCase)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int tryGetTrunkPrefixOmittedIndex(String str, int currentIndex)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean checkPrefixIsIgnorable(final String str, int forwardIndex, int backwardIndex)"}, {"arrows": "to", "from": "android.telephony.PhoneNumberUtils", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int getDefaultVoiceSubId()"}, {"arrows": "to", "from": "public static byte[] networkPortionToCalledPartyBCDWithLength(String s)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "networkPortionToCalledPartyBCD"}, {"arrows": "to", "from": "public static void addTtsSpan(Spannable s, int start, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.text.style.TtsSpan"}, {"arrows": "to", "from": "android.text.style.TtsSpan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getType()"}, {"arrows": "to", "from": "android.text.style.TtsSpan", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PersistableBundle getArgs()"}, {"arrows": "to", "from": "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer\u003cInteger\u003e callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TelephonyManager.SetOpportunisticSubscriptionResult"}, {"arrows": "to", "from": "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer\u003cInteger\u003e callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void setPreferredOpportunisticDataSubscription(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable Consumer\u003cInteger\u003e callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public int getPreferredOpportunisticDataSubscription()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int getPreferredOpportunisticDataSubscription()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public void updateAvailableNetworks(@NonNull List\u003cAvailableNetworkInfo\u003e availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer\u003cInteger\u003e callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setPreferredOpportunisticDataSubscription"}, {"arrows": "to", "from": "public void updateAvailableNetworks(@NonNull List\u003cAvailableNetworkInfo\u003e availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer\u003cInteger\u003e callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void updateAvailableNetworks(@NonNull List\u003cAvailableNetworkInfo\u003e availableNetworks, @Nullable @CallbackExecutor Executor executor, @UpdateAvailableNetworksResult @Nullable Consumer\u003cInteger\u003e callback)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public boolean isModemEnabledForSlot(int slotIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public int isMultiSimSupported()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MULTISIM_NOT_SUPPORTED_BY_HARDWARE"}, {"arrows": "to", "from": "public int isMultiSimSupported()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MULTISIM_NOT_SUPPORTED_BY_CARRIER"}, {"arrows": "to", "from": "public int isMultiSimSupported()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public int isMultiSimSupported()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}, {"arrows": "to", "from": "public int isMultiSimSupported()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MULTISIM_ALLOWED"}, {"arrows": "to", "from": "public void switchMultiSimConfig(int numOfSims)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public void switchMultiSimConfig(int numOfSims)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MODIFY_PHONE_STATE"}, {"arrows": "to", "from": "public boolean doesSwitchMultiSimConfigTriggerReboot()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasCarrierPrivileges"}, {"arrows": "to", "from": "public boolean doesSwitchMultiSimConfigTriggerReboot()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "switchMultiSimConfig(int)"}, {"arrows": "to", "from": "public boolean doesSwitchMultiSimConfigTriggerReboot()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_PHONE_STATE"}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": false
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  
                  // make a custom popup
                      var popup = document.createElement("div");
                      popup.className = 'popup';
                      popupTimeout = null;
                      popup.addEventListener('mouseover', function () {
                          console.log(popup)
                          if (popupTimeout !== null) {
                              clearTimeout(popupTimeout);
                              popupTimeout = null;
                          }
                      });
                      popup.addEventListener('mouseout', function () {
                          if (popupTimeout === null) {
                              hidePopup();
                          }
                      });
                      container.appendChild(popup);


                      // use the popup event to show
                      network.on("showPopup", function (params) {
                          showPopup(params);
                      });

                      // use the hide event to hide it
                      network.on("hidePopup", function (params) {
                          hidePopup();
                      });

                      // hiding the popup through css
                      function hidePopup() {
                          popupTimeout = setTimeout(function () { popup.style.display = 'none'; }, 500);
                      }

                      // showing the popup
                      function showPopup(nodeId) {
                          // get the data from the vis.DataSet
                          var nodeData = nodes.get([nodeId]);
                          popup.innerHTML = nodeData[0].title;

                          // get the position of the node
                          var posCanvas = network.getPositions([nodeId])[nodeId];

                          // get the bounding box of the node
                          var boundingBox = network.getBoundingBox(nodeId);

                          //position tooltip:
                          posCanvas.x = posCanvas.x + 0.5 * (boundingBox.right - boundingBox.left);

                          // convert coordinates to the DOM space
                          var posDOM = network.canvasToDOM(posCanvas);

                          // Give it an offset
                          posDOM.x += 10;
                          posDOM.y -= 20;

                          // show and place the tooltip.
                          popup.style.display = 'block';
                          popup.style.top = posDOM.y + 'px';
                          popup.style.left = posDOM.x + 'px';
                      }
                  


                  
                      network.on("stabilizationProgress", function(params) {
                          document.getElementById('loadingBar').removeAttribute("style");
                          var maxWidth = 496;
                          var minWidth = 20;
                          var widthFactor = params.iterations/params.total;
                          var width = Math.max(minWidth,maxWidth * widthFactor);
                          document.getElementById('bar').style.width = width + 'px';
                          document.getElementById('text').innerHTML = Math.round(widthFactor*100) + '%';
                      });
                      network.once("stabilizationIterationsDone", function() {
                          document.getElementById('text').innerHTML = '100%';
                          document.getElementById('bar').style.width = '496px';
                          document.getElementById('loadingBar').style.opacity = 0;
                          // really clean the dom element
                          setTimeout(function () {document.getElementById('loadingBar').style.display = 'none';}, 500);
                      });
                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>